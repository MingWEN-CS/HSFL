1a2,136
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> package com.google.javascript.jscomp.deps;
> 
> import com.google.common.collect.ArrayListMultimap;
> import com.google.common.collect.HashMultimap;
> import com.google.common.collect.HashMultiset;
> import com.google.common.collect.Lists;
> import com.google.common.collect.Maps;
> import com.google.common.collect.Multimap;
> import com.google.common.collect.Multimaps;
> import com.google.common.collect.Multiset;
> 
> import java.util.Collection;
> import java.util.Collections;
> import java.util.Comparator;
> import java.util.List;
> import java.util.Map;
> import java.util.PriorityQueue;
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> public class SortedDependencies<INPUT extends DependencyInfo> {
> 
>   
>   private final List<INPUT> sortedList;
> 
>   
>   private final List<INPUT> noProvides;
> 
>   public SortedDependencies(List<INPUT> inputs) {
>     final Map<String, INPUT> provides = Maps.newHashMap();
>     noProvides = Lists.newArrayList();
> 
>     
>     for (INPUT input : inputs) {
>       Collection<String> currentProvides = input.getProvides();
>       if (currentProvides.isEmpty()) {
>         noProvides.add(input);
>       }
> 
>       for (String provide : currentProvides) {
>         provides.put(provide, input);
>       }
>     }
> 
>     
>     final Multimap<INPUT, INPUT> deps = HashMultimap.create();
>     for (INPUT input : inputs) {
>       for (String req : input.getRequires()) {
>         INPUT dep = provides.get(req);
>         if (dep != null) {
>           deps.put(input, dep);
>         }
>       }
>     }
> 
>     
>     sortedList = topologicalStableSort(inputs, deps);
>   }
> 
>   public List<INPUT> getSortedList() {
>     return Collections.<INPUT>unmodifiableList(sortedList);
>   }
> 
>   public List<INPUT> getInputsWithoutProvides() {
>     return Collections.<INPUT>unmodifiableList(noProvides);
>   }
> 
>   private static <T> List<T> topologicalStableSort(
>       List<T> items, Multimap<T, T> deps) {
>     final Map<T, Integer> originalIndex = Maps.newHashMap();
>     for (int i = 0; i < items.size(); i++) {
>       originalIndex.put(items.get(i), i);
>     }
> 
>     PriorityQueue<T> inDegreeZero = new PriorityQueue<T>(items.size(),
>         new Comparator<T>() {
>       @Override
>       public int compare(T a, T b) {
>         return originalIndex.get(a).intValue() -
>             originalIndex.get(b).intValue();
>       }
>     });
>     List<T> result = Lists.newArrayList();
> 
>     Multiset<T> inDegree = HashMultiset.create();
>     Multimap<T, T> reverseDeps = ArrayListMultimap.create();
>     Multimaps.invertFrom(deps, reverseDeps);
> 
>     
>     for (T item : items) {
>       Collection<T> itemDeps = deps.get(item);
>       inDegree.add(item, itemDeps.size());
>       if (itemDeps.isEmpty()) {
>         inDegreeZero.add(item);
>       }
>     }
> 
>     
>     while (!inDegreeZero.isEmpty()) {
>       T item = inDegreeZero.remove();
>       result.add(item);
>       for (T inWaiting : reverseDeps.get(item)) {
>         inDegree.remove(inWaiting, 1);
>         if (inDegree.count(inWaiting) == 0) {
>           inDegreeZero.add(inWaiting);
>         }
>       }
>     }
> 
>     return result;
>   }
> }
