















package com.google.javascript.jscomp;

import com.google.javascript.rhino.TokenStream;
import javax.annotation.Nullable;
import com.google.common.collect.Sets;
import com.google.common.primitives.Chars;

import java.util.*;








final class NameGenerator {
  
  static final char[] FIRST_CHAR =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$".toCharArray();

  
  static final char[] NONFIRST_CHAR =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789$"
        .toCharArray();

  private final Set<String> reservedNames;
  private final String prefix;
  private int nameCount;

  private final char[] firstChars;
  private final char[] nonFirstChars;

  









  NameGenerator(Set<String> reservedNames, String prefix,
      @Nullable char[] reservedCharacters) {
    this.reservedNames = reservedNames;
    this.prefix = prefix;

    
    this.firstChars = reserveCharacters(FIRST_CHAR, reservedCharacters);
    this.nonFirstChars = reserveCharacters(NONFIRST_CHAR, reservedCharacters);

    checkPrefix(prefix);
  }

  






  static char[] reserveCharacters(char[] chars, char[] reservedCharacters) {
    if (reservedCharacters == null || reservedCharacters.length == 0) {
      return chars;
    }
    Set<Character> charSet = Sets.newLinkedHashSet(Chars.asList(chars));
    for (char reservedCharacter : reservedCharacters) {
      charSet.remove(reservedCharacter);
    }
    return Chars.toArray(charSet);
  }

  
  private void checkPrefix(String prefix) {
    if (prefix.length() > 0) {
      
      if (!contains(firstChars, prefix.charAt(0))) {
        throw new IllegalArgumentException("prefix must start with one of: " +
                                           Arrays.toString(firstChars));
      }
      for (int pos = 1; pos < prefix.length(); ++pos) {
        if (!contains(nonFirstChars, prefix.charAt(pos))) {
          throw new IllegalArgumentException("prefix has invalid characters, " +
                                             "must be one of: " +
                                             Arrays.toString(nonFirstChars));
        }
      }
    }
  }

  private boolean contains(char[] arr, char c) {
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == c) {
        return true;
      }
    }
    return false;
  }

  


  String generateNextName() {
    while (true) {
      String name = prefix;

      int i = nameCount;

      if (name.isEmpty()) {
        int pos = i % firstChars.length;
        name += firstChars[pos];
        i /= firstChars.length;
      }

      while (i > 0) {
        i--;
        int pos = i % nonFirstChars.length;
        name += nonFirstChars[pos];
        i /= nonFirstChars.length;
      }

      nameCount++;

      
      if (TokenStream.isKeyword(name) || reservedNames.contains(name)) {
        continue;
      }

      return name;
    }
  }
}
