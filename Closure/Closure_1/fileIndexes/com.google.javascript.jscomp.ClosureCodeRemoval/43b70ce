















package com.google.javascript.jscomp;

import com.google.common.collect.Lists;
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;

import java.util.List;














final class ClosureCodeRemoval implements CompilerPass {

  
  private final AbstractCompiler compiler;

  
  static final String ABSTRACT_METHOD_NAME = "goog.abstractMethod";

  



  private final List<RemovableAssignment> abstractMethodAssignmentNodes =
      Lists.newArrayList();


  


  private class RemovableAssignment {
    


    final Node node;

    


    final Node parent;

    


    final List<Node> assignAncestors = Lists.newArrayList();

    


    final Node lastAncestor;

    






    public RemovableAssignment(Node nameNode, Node assignNode,
        NodeTraversal traversal) {
      this.node = nameNode;
      this.parent = assignNode;

      Node ancestor = assignNode;
      do {
        ancestor = ancestor.getParent();
        assignAncestors.add(ancestor);
      } while (ancestor.getType() == Token.ASSIGN &&
               ancestor.getFirstChild().isQualifiedName());
      lastAncestor = ancestor.getParent();
    }

    


    public void remove() {
      Node rhs = node.getNext();
      Node last = parent;
      for (Node ancestor : assignAncestors) {
        if (NodeUtil.isExpressionNode(ancestor)) {
          lastAncestor.removeChild(ancestor);
        } else {
          rhs.detachFromParent();
          ancestor.replaceChild(last, rhs);
        }
        last = ancestor;
      }
      compiler.reportCodeChange();
    }
  }



  


  private class FindAbstractMethods extends AbstractPostOrderCallback {

    public void visit(NodeTraversal t, Node n, Node parent) {
      if (n.getType() == Token.ASSIGN) {
        Node nameNode = n.getFirstChild();
        Node valueNode = n.getLastChild();

        if (nameNode.isQualifiedName() &&
            valueNode.isQualifiedName() &&
            ABSTRACT_METHOD_NAME.equals(valueNode.getQualifiedName())) {
          abstractMethodAssignmentNodes.add(new RemovableAssignment(
              n.getFirstChild(), n, t));
        }
      }
    }
  }


  




  ClosureCodeRemoval(AbstractCompiler compiler) {
    this.compiler = compiler;
  }

  @Override
  public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, root, new FindAbstractMethods());

    for (RemovableAssignment assignment : abstractMethodAssignmentNodes) {
      assignment.remove();
    }
  }
}
