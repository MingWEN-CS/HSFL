25d24
< import java.util.regex.Pattern;
35d33
<   private final boolean late;
37,46d34
<   
< 
< 
< 
< 
< 
<   PeepholeReplaceKnownMethods(boolean late) {
<     this.late = late;
<   }
<   
106,108c94
<     if (functionNameString.equals("split")) {
<       subtree = tryFoldStringSplit(subtree, stringNode, firstArg);
<     } else if (firstArg == null) {
---
>     if (firstArg == null) {
661,715d646
<   
<   
< 
< 
<   private Node tryFoldStringSplit(Node n, Node stringNode, Node arg1) {
<     if (late) {
<       return n;
<     }
<     
<     Preconditions.checkArgument(n.isCall());
<     Preconditions.checkArgument(stringNode.isString());
< 
<     String separator = null;
<     String stringValue = stringNode.getString();
<     int limit = stringValue.length();
< 
<     if (arg1 != null) {
<       if (arg1.isString()) {
<         separator = arg1.getString();
<       } else if (!arg1.isNull()) {
<         return n;
<       }
<       
<       Node arg2 = arg1.getNext();
<       if (arg2 != null) {
<         if (arg2.isNumber()) {
<           limit = (int) arg2.getDouble();
<           if (limit < 0) {
<             return n;
<           }
<         } else {
<           return n;
<         }
<       }
<     }
<     
<     String[] stringArray;
<     if (separator != null) {
<       stringArray = stringValue.split(Pattern.quote(separator));
<     } else {
<       stringArray = new String[1];
<       stringArray[0] = stringValue;
<     }
<     
<     Node arrayOfStrings = IR.arraylit();
<     for (int i = 0; i < limit && i < stringArray.length; i++) {
<       arrayOfStrings.addChildToBack(
<           IR.string(stringArray[i]).srcref(stringNode));
<     }
<     
<     Node parent = n.getParent();
<     parent.replaceChild(n, arrayOfStrings);
<     reportCodeChange();
<     return arrayOfStrings;
<  }
