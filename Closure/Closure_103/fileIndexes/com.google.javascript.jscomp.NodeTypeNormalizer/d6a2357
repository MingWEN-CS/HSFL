















package com.google.javascript.jscomp;

import com.google.common.base.Preconditions;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;





class NodeTypeNormalizer implements CompilerPass {

  private final boolean assertOnChange;

  NodeTypeNormalizer() {
    this(false);
  }

  NodeTypeNormalizer(boolean forbidChanges) {
    this.assertOnChange = forbidChanges;
  }

  private void reportChange() {
    if (assertOnChange) {
      Preconditions.checkState(false, "normalizeNodeType constraints violated");
    }
  }

  @Override
  public void process(Node externs, Node root) {
    normalizeNodeTypes(root);
    normalizeJsDocAnnotations(root);
  }

  
















  private void normalizeJsDocAnnotations(Node n) {
    if (n.getType() == Token.OBJECTLIT) {
      for (Node key = n.getFirstChild();
           key != null; key = key.getNext().getNext()) {
        Node value = key.getNext();
        if (key.getJSDocInfo() != null &&
            key.getNext().getType() == Token.FUNCTION) {
          value.setJSDocInfo(key.getJSDocInfo());
        }
      }
    }

    
    
    


    if (n.getJSDocInfo() != null && n.getJSDocInfo().isJavaDispatch()) {
      if (n.getType() == Token.ASSIGN) {
        Node fnNode = n.getLastChild();
        Preconditions.checkState(fnNode.getType() == Token.FUNCTION);
        fnNode.putBooleanProp(Node.IS_DISPATCHER, true);
      }
    }

    for (Node child = n.getFirstChild();
         child != null; child = child.getNext()) {
      normalizeJsDocAnnotations(child);
    }
  }

  


  private void normalizeNodeTypes(Node n) {
    if (n.getType() == Token.EXPR_VOID) {
      n.setType(Token.EXPR_RESULT);
      reportChange();
    }

    
    
    if (n.getType() == Token.FUNCTION) {
      Preconditions.checkState(n.getProp(Node.FUNCTION_PROP) == null);
    }

    normalizeBlocks(n);

    for (Node child = n.getFirstChild();
         child != null; child = child.getNext()) {
      
      
      Preconditions.checkState(child.getParent() == n);

      normalizeNodeTypes(child);
    }
  }

  


  private void normalizeBlocks(Node n) {
    if (NodeUtil.isControlStructure(n)
        && n.getType() != Token.LABEL
        && n.getType() != Token.SWITCH) {
      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (NodeUtil.isControlStructureCodeBlock(n,c) &&
            c.getType() != Token.BLOCK) {
          Node newBlock = new Node(Token.BLOCK);
          n.replaceChild(c, newBlock);
          if (c.getType() != Token.EMPTY) {
            newBlock.addChildrenToFront(c);
          } else {
            newBlock.setWasEmptyNode(true);
          }
          c = newBlock;
          reportChange();
        }
      }
    }
  }

}
