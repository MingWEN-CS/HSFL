22a23
> import com.google.javascript.jscomp.SyntacticScopeCreator.RedeclarationHandler;
23a25
> import com.google.javascript.rhino.JSDocInfo;
66a69,82
>   static final DiagnosticType VAR_MULTIPLY_DECLARED_ERROR =
>       DiagnosticType.error(
>           "JSC_VAR_MULTIPLY_DECLARED_ERROR",
>           "Variable {0} first declared in {1}");
> 
>   static final DiagnosticType VAR_ARGUMENTS_SHADOWED_ERROR =
>     DiagnosticType.error(
>         "JSC_VAR_ARGUMENTS_SHADOWED_ERROR",
>         "Shadowing \"arguments\" is not allowed");
> 
>   
>   
>   private static final String ARGUMENTS = "arguments";
> 
90a107,120
>   
> 
> 
> 
> 
>   private ScopeCreator createScopeCreator() {
>     if (sanityCheck) {
>       return new SyntacticScopeCreator(compiler);
>     } else {
>       return new SyntacticScopeCreator(
>           compiler, new RedeclarationCheckHandler());
>     }
>   }
> 
92a123
>     ScopeCreator scopeCreator = createScopeCreator();
97c128,130
<       NodeTraversal.traverse(compiler, externs, new NameRefInExternsCheck());
---
>       NodeTraversal traversal = new NodeTraversal(
>           compiler, new NameRefInExternsCheck(), scopeCreator);
>       traversal.traverse(externs);
100,101c133,134
<     NodeTraversal.traverseRoots(
<         compiler, Lists.newArrayList(externs, root), this);
---
>     NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);
>     t.traverseRoots(Lists.newArrayList(externs, root));
110c143,144
<     NodeTraversal t = new NodeTraversal(compiler, this);
---
>     ScopeCreator scopeCreator = createScopeCreator();
>     NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);
113,114c147,148
<     t.traverseWithScope(scriptRoot,
<         SyntacticScopeCreator.generateUntypedTopScope(compiler));
---
>     Scope topScope = scopeCreator.createScope(compiler.getRoot(), null);
>     t.traverseWithScope(scriptRoot, topScope);
150c184
<       } else {
---
>       } else if (!(scope.isLocal() && ARGUMENTS.equals(varName))) {
259a294,360
>       }
>     }
>   }
> 
> 
>   
> 
> 
> 
> 
> 
>   static boolean hasDuplicateDeclarationSuppression(Node n, Scope.Var origVar) {
>     Preconditions.checkState(n.isName());
>     Node parent = n.getParent();
>     Node origParent = origVar.getParentNode();
> 
>     JSDocInfo info = n.getJSDocInfo();
>     if (info == null) {
>       info = parent.getJSDocInfo();
>     }
>     if (info != null && info.getSuppressions().contains("duplicate")) {
>       return true;
>     }
> 
>     info = origVar.nameNode.getJSDocInfo();
>     if (info == null) {
>       info = origParent.getJSDocInfo();
>     }
>     return (info != null && info.getSuppressions().contains("duplicate"));
>   }
> 
>   
> 
> 
>   private class RedeclarationCheckHandler implements RedeclarationHandler {
>     @Override
>     public void onRedeclaration(
>         Scope s, String name, Node n, CompilerInput input) {
>       Node parent = n.getParent();
> 
>       
>       if (s.isGlobal()) {
>         Scope.Var origVar = s.getVar(name);
>         Node origParent = origVar.getParentNode();
>         if (origParent.isCatch() &&
>             parent.isCatch()) {
>           
>           return;
>         }
> 
>         boolean allowDupe = hasDuplicateDeclarationSuppression(n, origVar);
> 
>         if (!allowDupe) {
>           compiler.report(
>               JSError.make(NodeUtil.getSourceName(n), n,
>                            VAR_MULTIPLY_DECLARED_ERROR,
>                            name,
>                            (origVar.input != null
>                             ? origVar.input.getName()
>                             : "??")));
>         }
>       } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {
>         
>         
>         compiler.report(
>             JSError.make(NodeUtil.getSourceName(n), n,
>                 VAR_ARGUMENTS_SHADOWED_ERROR));
