1a2,245
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> package com.google.javascript.jscomp;
> 
> import com.google.common.base.Preconditions;
> import com.google.common.collect.Lists;
> import com.google.common.collect.Maps;
> import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;
> import com.google.javascript.jscomp.Scope.Var;
> import com.google.javascript.rhino.Node;
> import com.google.javascript.rhino.Token;
> 
> import java.util.Iterator;
> import java.util.List;
> import java.util.Map;
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> class SymbolTable implements ScopeCreator, CodeChangeHandler {
>   static final DiagnosticType MISSING_VARIABLE =
>       DiagnosticType.warning(
>           "JSC_MISSING_VARIABLE",
>           "Missing variable name: {0}");
> 
>   static final DiagnosticType MOVED_VARIABLE =
>       DiagnosticType.warning(
>           "JSC_MOVED_VARIABLE",
>           "Moved variable name: {0}");
> 
>   static final DiagnosticType VARIABLE_COUNT_MISMATCH =
>       DiagnosticType.warning(
>           "JSC_VARIABLE_COUNT_MISMATCH",
>           "Variable count does not match." +
>           "\nCached : {0}\nActual : {1}");
> 
>   private final AbstractCompiler compiler;
>   private final ScopeCreator scopeCreator;
> 
>   
>   
>   private boolean locked = false;
> 
>   
>   
>   private MemoizedData cache = null;
> 
>   SymbolTable(AbstractCompiler compiler) {
>     this.compiler = compiler;
>     compiler.addChangeHandler(this);
> 
>     scopeCreator = new SyntacticScopeCreator(compiler);
>   }
> 
>   synchronized void acquire() {
>     Preconditions.checkState(!locked, "SymbolTable already acquired");
>     locked = true;
>   }
> 
>   synchronized void release() {
>     Preconditions.checkState(locked, "SymbolTable already released");
>     locked = false;
>   }
> 
>   
> 
> 
>   @Override
>   public Scope createScope(Node n, Scope parent) {
>     Preconditions.checkArgument(
>         n.getType() == Token.BLOCK || n.getType() == Token.FUNCTION);
>     ensureCacheInitialized();
> 
>     if (!cache.scopes.containsKey(n)) {
>       cache.scopes.put(n, scopeCreator.createScope(n, parent));
>     }
> 
>     return cache.scopes.get(n);
>   }
> 
>   
> 
> 
>   private void ensureCacheInitialized() {
>     Preconditions.checkState(locked, "Unacquired symbol table");
>     if (cache == null) {
>       cache = new MemoizedData();
>     }
>   }
> 
>   
> 
> 
> 
>   @Override
>   public void reportChange() {
>     if (!locked) {
>       cache = null;
>     }
>   }
> 
>   
> 
> 
>   private static class MemoizedData {
>     private Map<Node, Scope> scopes = Maps.newHashMap();
>   }
> 
>   
>   
> 
>   
> 
> 
> 
> 
> 
>   void verify(Node expectedRoot, Node actualRoot) {
>     VerifyingCallback callback = new VerifyingCallback(
>         expectedRoot, actualRoot);
>     callback.verify();
>   }
> 
>   
> 
> 
> 
>   private class VerifyingCallback implements ScopedCallback {
>     private final List<Scope> expectedScopes = Lists.newArrayList();
>     private final List<Scope> actualScopes = Lists.newArrayList();
>     private boolean collectingExpected = true;
>     private final Node actualRoot;
>     private final Node expectedRoot;
> 
>     private VerifyingCallback(Node expectedRoot, Node actualRoot) {
>       this.actualRoot = actualRoot;
>       this.expectedRoot = expectedRoot;
>     }
> 
>     @Override
>     public boolean shouldTraverse(
>         NodeTraversal nodeTraversal, Node n, Node parent) {
>       return true;
>     }
> 
>     @Override
>     public void visit(NodeTraversal t, Node n, Node parent) {}
> 
>     @Override
>     public void enterScope(NodeTraversal t) {}
> 
>     @Override
>     public void exitScope(NodeTraversal t) {
>       if (collectingExpected) {
>         expectedScopes.add(t.getScope());
>       } else {
>         actualScopes.add(t.getScope());
>       }
>     }
> 
>     private void verify() {
>       if (cache == null) {
>         
>         return;
>       }
> 
>       if (!cache.scopes.isEmpty()) {
>         verifyScopes();
>       }
>     }
> 
>     private void verifyScopes() {
>       collectingExpected = true;
>       NodeTraversal.traverse(compiler, expectedRoot, this);
> 
>       collectingExpected = false;
>       (new NodeTraversal(compiler, this, SymbolTable.this))
>           .traverse(actualRoot);
> 
>       
>       Preconditions.checkState(expectedScopes.size() == actualScopes.size());
> 
>       for (int i = 0; i < expectedScopes.size(); i++) {
>         Scope expectedScope = expectedScopes.get(i);
>         Scope actualScope = actualScopes.get(i);
>         if (expectedScope.getVarCount() != actualScope.getVarCount()) {
>           compiler.report(
>               JSError.make(
>                   VARIABLE_COUNT_MISMATCH,
>                   Integer.toString(expectedScope.getVarCount()),
>                   Integer.toString(actualScope.getVarCount())));
>         } else {
>           Iterator<Var> it = expectedScope.getVars();
>           while (it.hasNext()) {
>             Var var = it.next();
>             Scope.Var actualVar = actualScope.getVar(var.getName());
>             if (actualVar == null) {
>               compiler.report(
>                   JSError.make(MISSING_VARIABLE, var.getName()));
>             } else if (!isNodeAttached(actualVar.getNameNode())) {
>               compiler.report(
>                   JSError.make(MOVED_VARIABLE, var.getName()));
>             }
>           }
>         }
>       }
>     }
> 
>     private boolean isNodeAttached(Node node) {
>       
>       for (Node current = node;
>            current != null; current = current.getParent()) {
>         if (current.getType() == Token.SCRIPT) {
>           return true;
>         }
>       }
>       return false;
>     }
>   }
> }
