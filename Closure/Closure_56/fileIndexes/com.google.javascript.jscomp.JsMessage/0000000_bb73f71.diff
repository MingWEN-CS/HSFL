1a2,430
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> package com.google.javascript.jscomp;
> 
> import com.google.common.collect.Lists;
> import com.google.common.collect.Sets;
> import com.google.common.base.Hash;
> import com.google.common.base.Preconditions;
> 
> import java.util.Collections;
> import java.util.List;
> import java.util.Set;
> import java.util.regex.Matcher;
> import java.util.regex.Pattern;
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> public class JsMessage {
> 
>   
> 
> 
> 
>   public enum Style {
>     LEGACY, 
>     RELAX,  
>     CLOSURE; 
> 
>     
> 
> 
> 
> 
> 
> 
> 
>     static Style getFromParams(boolean useClosure,
>         boolean allowLegacyMessages) {
>       if (useClosure) {
>         return allowLegacyMessages ? RELAX : CLOSURE;
>       } else {
>         return LEGACY;
>       }
>     }
>   }
> 
>   private static final String MESSAGE_REPRESENTATION_FORMAT = "{$%s}";
> 
>   private final String key;
>   private final String id;
>   private final List<CharSequence> parts;
>   private final Set<String> placeholders;
>   private final String desc;
>   private final boolean hidden;
> 
>   private final String sourceName;
>   private final boolean isAnonymous;
>   private final boolean isExternal;
> 
>   
> 
> 
> 
> 
> 
> 
> 
> 
>   private JsMessage(String sourceName, String key,
>       boolean isAnonymous, boolean isExternal,
>       String id, List<CharSequence> parts, Set<String> placeholders,
>       String desc, boolean hidden) {
> 
>     Preconditions.checkState(key != null);
>     Preconditions.checkState(id != null);
> 
>     this.key = key;
>     this.id = id;
>     this.parts = Collections.unmodifiableList(parts);
>     this.placeholders = Collections.unmodifiableSet(placeholders);
>     this.desc = desc;
>     this.hidden = hidden;
> 
>     this.sourceName = sourceName;
>     this.isAnonymous = isAnonymous;
>     this.isExternal = isExternal;
>   }
> 
>   
> 
> 
>   public String getSourceName() {
>     return sourceName;
>   }
> 
>   
> 
> 
>   public String getKey() {
>     return key;
>   }
> 
>   public boolean isAnonymous() {
>     return isAnonymous;
>   }
> 
>   public boolean isExternal() {
>     return isExternal;
>   }
> 
>   
> 
> 
>   public String getId() {
>     return id;
>   }
> 
>   
> 
> 
> 
>   public String getDesc() {
>     return desc;
>   }
> 
>   
> 
> 
> 
>   public boolean isHidden() {
>     return hidden;
>   }
> 
>   
> 
> 
> 
>   public List<CharSequence> parts() {
>     return parts;
>   }
> 
>   
>   public Set<String> placeholders() {
>     return placeholders;
>   }
> 
>   @Override
>   public String toString() {
>     StringBuilder sb = new StringBuilder();
>     for (CharSequence p : parts) {
>       sb.append(p.toString());
>     }
>     return sb.toString();
>   }
> 
>   
>   public boolean isEmpty() {
>     for (CharSequence part : parts) {
>       if (part.length() > 0) {
>         return false;
>       }
>     }
> 
>     return true;
>   }
> 
>   @Override
>   public boolean equals(Object o) {
>     if (o == this) return true;
>     if (!(o instanceof JsMessage)) return false;
> 
>     JsMessage m = (JsMessage) o;
>     return id.equals(m.id) &&
>            key.equals(m.key) &&
>            isAnonymous == m.isAnonymous &&
>            parts.equals(m.parts) &&
>            placeholders.equals(m.placeholders) &&
>            (desc == null ? m.desc == null : desc.equals(m.desc)) &&
>            (sourceName == null
>                ? m.sourceName == null
>                : sourceName.equals(m.sourceName)) &&
>            hidden == m.hidden;
>   }
> 
>   @Override
>   public int hashCode() {
>     int hash = key.hashCode();
>     hash = 31 * hash + (isAnonymous ? 1 : 0);
>     hash = 31 * hash + id.hashCode();
>     hash = 31 * hash + parts.hashCode();
>     hash = 31 * hash + (desc != null ? desc.hashCode() : 0);
>     hash = 31 * hash + (hidden ? 1 : 0);
>     hash = 31 * hash + (sourceName != null ? sourceName.hashCode() : 0);
>     return hash;
>   }
> 
>   
>   public static class PlaceholderReference implements CharSequence {
> 
>     private final String name;
> 
>     PlaceholderReference(String name) {
>       this.name = name;
>     }
> 
>     @Override
>     public int length() {
>       return name.length();
>     }
> 
>     @Override
>     public char charAt(int index) {
>       return name.charAt(index);
>     }
> 
>     @Override
>     public CharSequence subSequence(int start, int end) {
>       return name.subSequence(start, end);
>     }
> 
>     public String getName() {
>       return name;
>     }
> 
>     @Override
>     public String toString() {
>       return String.format(MESSAGE_REPRESENTATION_FORMAT, name);
>     }
> 
>     @Override
>     public boolean equals(Object o) {
>       return o == this ||
>              o instanceof PlaceholderReference &&
>              name.equals(((PlaceholderReference) o).name);
>     }
> 
>     @Override
>     public int hashCode() {
>       return 31 * name.hashCode();
>     }
>   }
> 
>   
> 
> 
> 
> 
> 
> 
>   public static class Builder {
> 
>     private static final Pattern MSG_EXTERNAL_PATTERN =
>         Pattern.compile("MSG_EXTERNAL_(\\d+)");
> 
>     
> 
> 
> 
>     private static String getExternalMessageId(String identifier) {
>       Matcher m = MSG_EXTERNAL_PATTERN.matcher(identifier);
>       return m.matches() ? m.group(1) : null;
>     }
> 
>     private String key;
>     private String desc;
>     private boolean hidden;
> 
>     private List<CharSequence> parts = Lists.newLinkedList();
>     private Set<String> placeholders = Sets.newHashSet();
> 
>     private String sourceName;
> 
>     public Builder() {
>       this(null);
>     }
> 
>     
>     public Builder(String key) {
>       this.key = key;
>     }
> 
>     
>     public String getKey() {
>       return key;
>     }
> 
>     
> 
> 
> 
>     public Builder setKey(String key) {
>       this.key = key;
>       return this;
>     }
> 
>     
> 
> 
>     public Builder setSourceName(String sourceName) {
>       this.sourceName = sourceName;
>       return this;
>     }
> 
>     
> 
> 
>     public Builder appendPlaceholderReference(String name) {
>       Preconditions.checkNotNull(name, "Placeholder name could not be null");
>       parts.add(new PlaceholderReference(name));
>       placeholders.add(name);
>       return this;
>     }
> 
>     
>     public Builder appendStringPart(String part) {
>       Preconditions.checkNotNull(part,
>           "String part of the message could not be null");
>       parts.add(part);
>       return this;
>     }
> 
>     
>     public Set<String> getPlaceholders() {
>       return placeholders;
>     }
> 
>     
>     public Builder setDesc(String desc) {
>       this.desc = desc;
>       return this;
>     }
> 
>     
>     public Builder setIsHidden(boolean hidden) {
>       this.hidden = hidden;
>       return this;
>     }
> 
>     
>     public boolean hasParts() {
>       return !parts.isEmpty();
>     }
> 
>     public List<CharSequence> getParts() {
>       return parts;
>     }
> 
>     public JsMessage build() {
>       return build(null);
>     }
> 
>     public JsMessage build(IdGenerator idGenerator) {
>       boolean isAnonymous = false;
>       boolean isExternal = false;
>       String id = null;
> 
>       if (getKey() == null) {
>         
>         
>         key = JsMessageVisitor.MSG_PREFIX + fingerprint(getParts());
>         isAnonymous = true;
>       }
> 
>       if (!isAnonymous) {
>         String externalId = getExternalMessageId(key);
>         if (externalId != null) {
>           isExternal = true;
>           id = externalId;
>         }
>       }
> 
>       if (!isExternal) {
>         id = idGenerator == null ? key : idGenerator.generateId(key, parts);
>       }
> 
>       return new JsMessage(sourceName, key, isAnonymous, isExternal, id, parts,
>           placeholders, desc, hidden);
>     }
> 
>     
> 
> 
> 
>     private static String fingerprint(List<CharSequence> messageParts) {
>       StringBuilder sb = new StringBuilder();
>       for (CharSequence part : messageParts) {
>         if (part instanceof JsMessage.PlaceholderReference) {
>           sb.append(part.toString());
>         } else {
>           sb.append(part);
>         }
>       }
>       long nonnegativeHash = Long.MAX_VALUE & Hash.hash64(sb.toString());
>       return Long.toString(nonnegativeHash, 36).toUpperCase();
>     }
>   }
>   public interface IdGenerator {
> 
>     String generateId(String key, List<CharSequence> messageParts);
>   }
> }
