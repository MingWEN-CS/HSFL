















package com.google.javascript.jscomp;

import com.google.common.base.Predicate;
import com.google.javascript.jscomp.ControlFlowGraph.Branch;
import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;
import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import com.google.javascript.rhino.jstype.FunctionType;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;








class CheckMissingReturn implements ScopedCallback {

  static final DiagnosticType MISSING_RETURN_STATEMENT =
      DiagnosticType.warning(
          "JSC_MISSING_RETURN_STATEMENT",
          "missing return statement");

  private final AbstractCompiler compiler;
  private final CheckLevel level;

  private static final Predicate<Node> IS_RETURN = new Predicate<Node>() {
    public boolean apply(Node input) {
      
      
      return input != null && input.getType() == Token.RETURN;
    }
  };

  
  private static final Predicate<DiGraphEdge<Node, ControlFlowGraph.Branch>>
      GOES_THROUGH_TRUE_CONDITION_PREDICATE =
        new Predicate<DiGraphEdge<Node, ControlFlowGraph.Branch>>() {
    public boolean apply(DiGraphEdge<Node, ControlFlowGraph.Branch> input) {
      
      Branch branch = input.getValue();
      if (branch == Branch.ON_EX) {
        return false;
      } else if (branch.isConditional()) {
        Node condition = NodeUtil.getConditionExpression(
            input.getSource().getValue());
        
        
        
        
        if (condition != null && NodeUtil.isLiteralValue(condition) ) {
          return NodeUtil.getBooleanValue(condition) ==
            (Branch.ON_TRUE == branch);
        }
      }
      return true;
    }
  };

  



  CheckMissingReturn(AbstractCompiler compiler, CheckLevel level) {
    this.compiler = compiler;
    this.level = level;
  }

  @Override
  public void enterScope(NodeTraversal t) {
    if (!explicitReturnExpected(t.getScopeRoot())) {
      return;
    }

    if (fastAllPathsReturnCheck(t.getControlFlowGraph())) {
      return;
    }

    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test =
        new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(
            t.getControlFlowGraph(),
            t.getControlFlowGraph().getEntry(),
            t.getControlFlowGraph().getImplicitReturn(),
            IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);

    if (!test.allPathsSatisfyPredicate()) {
      compiler.report(
          JSError.make(t, t.getScopeRoot(), level, MISSING_RETURN_STATEMENT));
    }
  }

  





  private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg) {
    for (DiGraphEdge<Node, Branch> s : cfg.getImplicitReturn().getInEdges()) {
      if (s.getSource().getValue().getType() != Token.RETURN) {
        return false;
      }
    }
    return true;
  }

  @Override
  public void exitScope(NodeTraversal t) {
  }

  @Override
  public boolean shouldTraverse(
      NodeTraversal nodeTraversal, Node n, Node parent) {
    return true;
  }

  @Override
  public void visit(NodeTraversal t, Node n, Node parent) {
  }

  



  private boolean explicitReturnExpected(Node scope) {
    JSType scopeType = scope.getJSType();

    if (!(scopeType instanceof FunctionType)) {
      return false;
    }

    if (isEmptyFunction(scope)) {
      return false;
    }

    JSType returnType = ((FunctionType) scopeType).getReturnType();

    if (returnType == null) {
      return false;
    }

    return !isVoidOrUnknown(returnType);
  }


  



  private static boolean isEmptyFunction(Node function) {
    return function.getChildCount() == 3 &&
           !function.getFirstChild().getNext().getNext().hasChildren();
  }

  



  private boolean isVoidOrUnknown(JSType returnType) {
    final JSType voidType =
        compiler.getTypeRegistry().getNativeType(JSTypeNative.VOID_TYPE);
    return voidType.isSubtype(returnType);
  }
}
