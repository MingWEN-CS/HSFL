















package com.google.javascript.jscomp;

import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;

import java.util.List;
import java.util.Set;


































class CollapseVariableDeclarations implements CompilerPass {
  
  private final AbstractCompiler compiler;

  
  private static class Collapse {
    



    final Node firstVarNode;

    
    final Node parent;

    Collapse(Node firstVarNode, Node parent) {
      this.firstVarNode = firstVarNode;
      this.parent = parent;
    }
  }

  


  private final List<Collapse> collapses = Lists.newArrayList();

  




  private final Set<Node> nodesToCollapse = Sets.newHashSet();

  CollapseVariableDeclarations(AbstractCompiler compiler) {
    Preconditions.checkState(!compiler.getLifeCycleStage().isNormalized());
    this.compiler = compiler;
  }

  public void process(Node externs, Node root) {
    collapses.clear();
    nodesToCollapse.clear();

    NodeTraversal.traverse(compiler, root, new GatherCollapses());

    if (!collapses.isEmpty()) {
      applyCollapses();
      compiler.reportCodeChange();
    }
  }

  




  private class GatherCollapses extends AbstractPostOrderCallback {

    public void visit(NodeTraversal t, Node n, Node parent) {
      
      if (n.getType() != Token.VAR) return;

      
      if (nodesToCollapse.contains(n)) return;

      
      
      if (parent.getType() == Token.IF) return;

      Node varNode = n;

      
      n = n.getNext();

      boolean hasNodesToCollapse = false;
      while (n != null && n.getType() == Token.VAR) {
        nodesToCollapse.add(n);
        hasNodesToCollapse = true;

        n = n.getNext();
      }

      if (hasNodesToCollapse) {
        nodesToCollapse.add(varNode);
        collapses.add(new Collapse(varNode, parent));
      }

    }
  }

  private void applyCollapses() {
    for (Collapse collapse : collapses) {
      Node first = collapse.firstVarNode;
      while (first.getNext() != null &&
          first.getNext().getType() == Token.VAR) {
        Node next = collapse.parent.removeChildAfter(first);

        
        first.addChildrenToBack(next.removeChildren());
      }
    }
  }

}
