1a2,270
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> package com.google.javascript.jscomp;
> 
> import java.net.URI;
> import java.net.URISyntaxException;
> 
> import com.google.common.base.Preconditions;
> import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
> import com.google.javascript.rhino.IR;
> import com.google.javascript.rhino.Node;
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> class ProcessCommonJSModules implements CompilerPass {
> 
>   public static final String  DEFAULT_FILENAME_PREFIX = "./";
> 
>   private static final String MODULE_NAME_PREFIX = "module$";
> 
>   private final AbstractCompiler compiler;
>   private final String filenamePrefix;
>   private final boolean reportDependencies;
>   private JSModule module;
> 
>   ProcessCommonJSModules(AbstractCompiler compiler, String filenamePrefix) {
>     this.compiler = compiler;
>     this.filenamePrefix = filenamePrefix;
>     this.reportDependencies = true;
>   }
> 
>   ProcessCommonJSModules(AbstractCompiler compiler, String filenamePrefix,
>       boolean reportDependencies) {
>     this.compiler = compiler;
>     this.filenamePrefix = filenamePrefix;
>     this.reportDependencies = reportDependencies;
>   }
> 
>   @Override
>   public void process(Node externs, Node root) {
>     NodeTraversal
>         .traverse(compiler, root, new ProcessCommonJsModulesCallback());
>   }
> 
>   private String guessCJSModuleName(String filename) {
>     return toModuleName(normalizeSourceName(filename));
>   }
> 
>   
> 
> 
> 
>   JSModule getModule() {
>     return module;
>   }
> 
>   
> 
> 
> 
> 
>   public static String toModuleName(String filename) {
>     return MODULE_NAME_PREFIX +
>         filename.replaceAll("^\\./", "").replaceAll("/", "\\$")
>             .replaceAll("\\.js$", "").replaceAll("-", "_");
>   }
> 
>   
> 
> 
> 
>   public static String toModuleName(String requiredFilename,
>       String currentFilename) {
>     requiredFilename = requiredFilename.replaceAll("\\.js$", "");
>     currentFilename = currentFilename.replaceAll("\\.js$", "");
> 
>     if (requiredFilename.startsWith("./") ||
>         requiredFilename.startsWith("../")) {
>       try {
>         requiredFilename = (new URI(currentFilename)).resolve(new URI(requiredFilename))
>             .toString();
>       } catch (URISyntaxException e) {
>         throw new RuntimeException(e);
>       }
>     }
>     return toModuleName(requiredFilename);
>   }
> 
>   private String normalizeSourceName(String filename) {
>     if (filename.indexOf(filenamePrefix) == 0) {
>       filename = filename.substring(filenamePrefix.length());
>     }
>     return filename;
>   }
> 
>   
> 
> 
>   private class ProcessCommonJsModulesCallback extends
>       AbstractPostOrderCallback {
> 
>     private int scriptNodeCount = 0;
> 
>     @Override
>     public void visit(NodeTraversal t, Node n, Node parent) {
>       if (n.isCall() && n.getChildCount() == 2 &&
>           "require".equals(n.getFirstChild().getQualifiedName()) &&
>           n.getChildAtIndex(1).isString()) {
>         visitRequireCall(t, n, parent);
>       }
> 
>       if (n.isScript()) {
>         scriptNodeCount++;
>         visitScript(t, n);
>       }
> 
>       if (n.isGetProp() &&
>           "module.exports".equals(n.getQualifiedName())) {
>         visitModuleExports(n);
>       }
>     }
> 
>     
> 
> 
> 
>     private void visitRequireCall(NodeTraversal t, Node require, Node parent) {
>       String moduleName = toModuleName(require.getChildAtIndex(1).getString(),
>           normalizeSourceName(t.getSourceName()));
>       Node moduleRef = IR.name(moduleName).srcref(require);
>       parent.replaceChild(require, moduleRef);
>       Node script = getCurrentScriptNode(parent);
>       if (reportDependencies) {
>         t.getInput().addRequire(moduleName);
>       }
>       
>       script.addChildToFront(IR.exprResult(
>           IR.call(IR.getprop(IR.name("goog"), IR.string("require")),
>               IR.string(moduleName))).copyInformationFromForTree(require));
>       compiler.reportCodeChange();
>     }
> 
>     
> 
> 
> 
>     private void visitScript(NodeTraversal t, Node script) {
>       Preconditions.checkArgument(scriptNodeCount == 1,
>           "ProcessCommonJSModules supports only one invocation per " +
>           "CompilerInput / script node");
>       String moduleName = guessCJSModuleName(normalizeSourceName(script
>           .getSourceFileName()));
>       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())
>           .copyInformationFromForTree(script));
>       if (reportDependencies) {
>         CompilerInput ci = t.getInput();
>         ci.addProvide(moduleName);
>         JSModule m = new JSModule(moduleName);
>         m.addAndOverrideModule(ci);
>         module = m;
>       }
>       script.addChildToFront(IR.exprResult(
>           IR.call(IR.getprop(IR.name("goog"), IR.string("provide")),
>               IR.string(moduleName))).copyInformationFromForTree(script));
> 
>       emitOptionalModuleExportsOverride(script, moduleName);
> 
>       
>       NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(
>           moduleName));
> 
>       compiler.reportCodeChange();
>     }
> 
>     
> 
> 
> 
> 
>     private void emitOptionalModuleExportsOverride(Node script,
>         String moduleName) {
>       Node moduleExportsProp = IR.getprop(IR.name(moduleName),
>           IR.string("module$exports"));
>       script.addChildToBack(IR.ifNode(
>           moduleExportsProp,
>           IR.block(IR.exprResult(IR.assign(IR.name(moduleName),
>               moduleExportsProp.cloneTree())))).copyInformationFromForTree(
>           script));
>     }
> 
>     
> 
> 
>     private void visitModuleExports(Node prop) {
>       String moduleName = guessCJSModuleName(prop.getSourceFileName());
>       Node module = prop.getChildAtIndex(0);
>       module.putProp(Node.ORIGINALNAME_PROP, "module");
>       module.setString(moduleName);
>       Node exports = prop.getChildAtIndex(1);
>       exports.putProp(Node.ORIGINALNAME_PROP, "exports");
>       exports.setString("module$exports");
>     }
> 
>     
> 
> 
>     private Node getCurrentScriptNode(Node n) {
>       while (true) {
>         if (n.isScript()) {
>           return n;
>         }
>         n = n.getParent();
>       }
>     }
>   }
> 
>   
> 
> 
>   private class SuffixVarsCallback extends AbstractPostOrderCallback {
> 
>     private static final String EXPORTS = "exports";
> 
>     private final String suffix;
> 
>     public SuffixVarsCallback(String suffix) {
>       this.suffix = suffix;
>     }
> 
>     @Override
>     public void visit(NodeTraversal t, Node n, Node parent) {
>       if (n.isName()) {
>         String name = n.getString();
>         if (suffix.equals(name)) {
>           return;
>         }
>         if (EXPORTS.equals(name)) {
>           n.setString(suffix);
>           n.putProp(Node.ORIGINALNAME_PROP, EXPORTS);
>         } else {
>           Scope.Var var = t.getScope().getVar(name);
>           if (var != null && var.isGlobal()) {
>             n.setString(name + "$$" + suffix);
>             n.putProp(Node.ORIGINALNAME_PROP, name);
>           }
>         }
>       }
>     }
>   }
> }
