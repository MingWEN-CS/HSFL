















package com.google.javascript.jscomp;

import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import com.google.javascript.rhino.JSDocInfo;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import com.google.javascript.rhino.TokenStream;
import com.google.javascript.rhino.jstype.FunctionType;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.TernaryValue;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.Nullable;





public final class NodeUtil {

  final static String JSC_PROPERTY_NAME_FN = "JSCompiler_renameProperty";

  
  

  
  private static final Set<String> CONSTRUCTORS_WITHOUT_SIDE_EFFECTS =
      new HashSet<String>(Arrays.asList(
        "Array",
        "Date",
        "Error",
        "Object",
        "RegExp",
        "XMLHttpRequest"));

  
  private NodeUtil() {}

  





  static TernaryValue getExpressionBooleanValue(Node n) {
    switch (n.getType()) {
      case Token.ASSIGN:
      case Token.COMMA:
        
        return getExpressionBooleanValue(n.getLastChild());
      case Token.NOT:
        TernaryValue value = getExpressionBooleanValue(n.getLastChild());
        return value.not();
      case Token.AND: {
        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());
        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());
        return lhs.and(rhs);
      }
      case Token.OR:  {
        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());
        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());
        return lhs.or(rhs);
      }
      case Token.HOOK:  {
        TernaryValue trueValue = getExpressionBooleanValue(
            n.getFirstChild().getNext());
        TernaryValue falseValue = getExpressionBooleanValue(n.getLastChild());
        if (trueValue.equals(falseValue)) {
          return trueValue;
        } else {
          return TernaryValue.UNKNOWN;
        }
      }
      default:
        return getBooleanValue(n);
    }
  }

  



  static TernaryValue getBooleanValue(Node n) {
    switch (n.getType()) {
      case Token.STRING:
        return TernaryValue.forBoolean(n.getString().length() > 0);

      case Token.NUMBER:
        return TernaryValue.forBoolean(n.getDouble() != 0);

      case Token.NOT:
        return getBooleanValue(n.getLastChild()).not();

      case Token.NULL:
      case Token.FALSE:
      case Token.VOID:
        return TernaryValue.FALSE;

      case Token.NAME:
        String name = n.getString();
        if ("undefined".equals(name)
            || "NaN".equals(name)) {
          
          
          return TernaryValue.FALSE;
        } else if ("Infinity".equals(name)) {
          return TernaryValue.TRUE;
        }
        break;

      case Token.TRUE:
      case Token.ARRAYLIT:
      case Token.OBJECTLIT:
      case Token.REGEXP:
        return TernaryValue.TRUE;
    }

    return TernaryValue.UNKNOWN;
  }


  




  static String getStringValue(Node n) {
    
    switch (n.getType()) {
      case Token.STRING:
        return n.getString();

      case Token.NAME:
        String name = n.getString();
        if ("undefined".equals(name)
            || "Infinity".equals(name)
            || "NaN".equals(name)) {
          return name;
        }
        break;

      case Token.NUMBER:
        double value = n.getDouble();
        long longValue = (long) value;

        
        if (longValue == value) {
          return Long.toString(longValue);
        } else {
          return Double.toString(n.getDouble());
        }

      case Token.FALSE:
      case Token.TRUE:
      case Token.NULL:
        return Node.tokenToName(n.getType());

      case Token.VOID:
        return "undefined";

      case Token.NOT:
        TernaryValue child = getBooleanValue(n.getFirstChild());
        if (child != TernaryValue.UNKNOWN) {
          return child.toBoolean(true) ? "false" : "true"; 
        }
        break;

      case Token.ARRAYLIT:
        return arrayToString(n);

      case Token.OBJECTLIT:
        return "[object Object]";
    }
    return null;
  }

  







  static String getArrayElementStringValue(Node n) {
    return NodeUtil.isNullOrUndefined(n) ? "" : getStringValue(n);
  }

  static String arrayToString(Node literal) {
    Node first = literal.getFirstChild();
    int[] skipIndexes = (int[]) literal.getProp(Node.SKIP_INDEXES_PROP);
    StringBuilder result = new StringBuilder();
    int nextSlot = 0;
    int nextSkipSlot = 0;
    for (Node n = first; n != null; n = n.getNext()) {
      while (skipIndexes != null && nextSkipSlot < skipIndexes.length) {
        if (nextSlot == skipIndexes[nextSkipSlot]) {
          result.append(',');
          nextSlot++;
          nextSkipSlot++;
        } else {
          break;
        }
      }
      String childValue = getArrayElementStringValue(n);
      if (childValue == null) {
        return null;
      }
      if (n != first) {
        result.append(',');
      }
      result.append(childValue);

      nextSlot++;
    }
    return result.toString();
  }

  




  static Double getNumberValue(Node n) {
    switch (n.getType()) {
      case Token.TRUE:
        return 1.0;

      case Token.FALSE:
      case Token.NULL:
        return 0.0;

      case Token.NUMBER:
        return n.getDouble();

      case Token.VOID:
        if (mayHaveSideEffects(n.getFirstChild())) {
          return null;
        } else {
          return Double.NaN;
        }

      case Token.NAME:
        
        String name = n.getString();
        if (name.equals("undefined")) {
          return Double.NaN;
        }
        if (name.equals("NaN")) {
          return Double.NaN;
        }
        if (name.equals("Infinity")) {
          return Double.POSITIVE_INFINITY;
        }
        return null;

      case Token.NEG:
        if (n.getChildCount() == 1 && n.getFirstChild().getType() == Token.NAME
            && n.getFirstChild().getString().equals("Infinity")) {
          return Double.NEGATIVE_INFINITY;
        }
        return null;

      case Token.NOT:
        TernaryValue child = getBooleanValue(n.getFirstChild());
        if (child != TernaryValue.UNKNOWN) {
          return child.toBoolean(true) ? 0.0 : 1.0; 
        }
        break;

      case Token.STRING:
        return getStringNumberValue(n.getString());

      case Token.ARRAYLIT:
      case Token.OBJECTLIT:
        String value = getStringValue(n);
        return value != null ? getStringNumberValue(value) : null;
    }

    return null;
  }

  static Double getStringNumberValue(String rawJsString) {
    String s = trimJsWhiteSpace(rawJsString);
    
    if (s.length() == 0) {
      return 0.0;
    }

    if (s.length() > 2
        && s.charAt(0) == '0'
        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
      
      try {
        return Double.valueOf(Integer.parseInt(s.substring(2), 16));
      } catch (NumberFormatException e) {
        return Double.NaN;
      }
    }

    if (s.length() > 3
        && (s.charAt(0) == '-' || s.charAt(0) == '+')
        && s.charAt(1) == '0'
        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
      
      return null;
    }

    
    
    if (s.equals("infinity")
        || s.equals("-infinity")
        || s.equals("+infinity")) {
      return null;
    }

    try {
      return Double.parseDouble(s);
    } catch (NumberFormatException e) {
      return Double.NaN;
    }
  }

  static String trimJsWhiteSpace(String s) {
    int start = 0;
    int end = s.length();
    while (end > 0 && isStrWhiteSpaceChar(s.charAt(end-1))) {
      end--;
    }
    while (start < end && isStrWhiteSpaceChar(s.charAt(start))) {
      start++;
    }
    return s.substring(start, end);
  }

  


  static boolean isStrWhiteSpaceChar(int c) {
    switch (c) {
      case ' ': 
      case '\n': 
      case '\r': 
      case '\t': 
      case '\u00A0': 
      case '\u000C': 
      case '\u000B': 
      case '\u2028': 
      case '\u2029': 
      case '\uFEFF': 
        return true;
      default:
        return Character.getType(c) == Character.SPACE_SEPARATOR;
    }
  }

  














  static String getFunctionName(Node n) {
    Node parent = n.getParent();
    String name = n.getFirstChild().getString();
    switch (parent.getType()) {
      case Token.NAME:
        
        
        return parent.getString();

      case Token.ASSIGN:
        
        
        return parent.getFirstChild().getQualifiedName();

      default:
        
        return name != null && name.length() != 0 ? name : null;
    }
  }

  














  static String getNearestFunctionName(Node n) {
    String name = getFunctionName(n);
    if (name != null) {
      return name;
    }

    
    Node parent = n.getParent();
    switch (parent.getType()) {
      case Token.SET:
      case Token.GET:
      case Token.STRING:
        
        return parent.getString();
      case Token.NUMBER:
        return getStringValue(parent);
    }

    return null;
  }


  


  static boolean isImmutableValue(Node n) {
    switch (n.getType()) {
      case Token.STRING:
      case Token.NUMBER:
      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        return true;
      case Token.NOT:
        return isImmutableValue(n.getFirstChild());
      case Token.VOID:
      case Token.NEG:
        return isImmutableValue(n.getFirstChild());
      case Token.NAME:
        String name = n.getString();
        
        
        return "undefined".equals(name)
            || "Infinity".equals(name)
            || "NaN".equals(name);
    }

    return false;
  }

  





















  static boolean isLiteralValue(Node n, boolean includeFunctions) {
    switch (n.getType()) {
      case Token.ARRAYLIT:
      case Token.REGEXP:
        
        for (Node child = n.getFirstChild(); child != null;
             child = child.getNext()) {
          if (!isLiteralValue(child, includeFunctions)) {
            return false;
          }
        }
        return true;

      case Token.OBJECTLIT:
        
        for (Node child = n.getFirstChild(); child != null;
             child = child.getNext()) {
          if (!isLiteralValue(child.getFirstChild(), includeFunctions)) {
            return false;
          }
        }
        return true;

      case Token.FUNCTION:
        return includeFunctions && !NodeUtil.isFunctionDeclaration(n);

      default:
        return isImmutableValue(n);
    }
  }

  





  static boolean isValidDefineValue(Node val, Set<String> defines) {
    switch (val.getType()) {
      case Token.STRING:
      case Token.NUMBER:
      case Token.TRUE:
      case Token.FALSE:
        return true;

      
      case Token.ADD:
      case Token.BITAND:
      case Token.BITNOT:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.DIV:
      case Token.EQ:
      case Token.GE:
      case Token.GT:
      case Token.LE:
      case Token.LSH:
      case Token.LT:
      case Token.MOD:
      case Token.MUL:
      case Token.NE:
      case Token.RSH:
      case Token.SHEQ:
      case Token.SHNE:
      case Token.SUB:
      case Token.URSH:
        return isValidDefineValue(val.getFirstChild(), defines)
            && isValidDefineValue(val.getLastChild(), defines);

      
      case Token.NOT:
      case Token.NEG:
      case Token.POS:
        return isValidDefineValue(val.getFirstChild(), defines);

      
      case Token.NAME:
      case Token.GETPROP:
        if (val.isQualifiedName()) {
          return defines.contains(val.getQualifiedName());
        }
    }
    return false;
  }

  




  static boolean isEmptyBlock(Node block) {
    if (block.getType() != Token.BLOCK) {
      return false;
    }

    for (Node n = block.getFirstChild(); n != null; n = n.getNext()) {
      if (n.getType() != Token.EMPTY) {
        return false;
      }
    }
    return true;
  }

  static boolean isSimpleOperator(Node n) {
    return isSimpleOperatorType(n.getType());
  }

  




  static boolean isSimpleOperatorType(int type) {
    switch (type) {
      case Token.ADD:
      case Token.BITAND:
      case Token.BITNOT:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.COMMA:
      case Token.DIV:
      case Token.EQ:
      case Token.GE:
      case Token.GETELEM:
      case Token.GETPROP:
      case Token.GT:
      case Token.INSTANCEOF:
      case Token.LE:
      case Token.LSH:
      case Token.LT:
      case Token.MOD:
      case Token.MUL:
      case Token.NE:
      case Token.NOT:
      case Token.RSH:
      case Token.SHEQ:
      case Token.SHNE:
      case Token.SUB:
      case Token.TYPEOF:
      case Token.VOID:
      case Token.POS:
      case Token.NEG:
      case Token.URSH:
        return true;

      default:
        return false;
    }
  }

  





  public static Node newExpr(Node child) {
    Node expr = new Node(Token.EXPR_RESULT, child)
        .copyInformationFrom(child);
    return expr;
  }

  





  static boolean mayEffectMutableState(Node n) {
    return mayEffectMutableState(n, null);
  }

  static boolean mayEffectMutableState(Node n, AbstractCompiler compiler) {
    return checkForStateChangeHelper(n, true, compiler);
  }

  


  static boolean mayHaveSideEffects(Node n) {
    return mayHaveSideEffects(n, null);
  }

  static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler) {
    return checkForStateChangeHelper(n, false, compiler);
  }

  





  private static boolean checkForStateChangeHelper(
      Node n, boolean checkForNewObjects, AbstractCompiler compiler) {
    
    
    switch (n.getType()) {
      
      case Token.AND:
      case Token.BLOCK:
      case Token.EXPR_RESULT:
      case Token.HOOK:
      case Token.IF:
      case Token.IN:
      case Token.LP:
      case Token.NUMBER:
      case Token.OR:
      case Token.THIS:
      case Token.TRUE:
      case Token.FALSE:
      case Token.NULL:
      case Token.STRING:
      case Token.SWITCH:
      case Token.TRY:
      case Token.EMPTY:
        break;

      
      case Token.THROW:
        return true;

      case Token.OBJECTLIT:
        if (checkForNewObjects) {
          return true;
        }
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          if (checkForStateChangeHelper(
                  c.getFirstChild(), checkForNewObjects, compiler)) {
            return true;
          }
        }
        return false;

      case Token.ARRAYLIT:
      case Token.REGEXP:
        if (checkForNewObjects) {
          return true;
        }
        break;

      case Token.VAR:    
      case Token.NAME:   
        if (n.getFirstChild() != null) {
          return true;
        }
        break;

      case Token.FUNCTION:
        
        
        
        return checkForNewObjects || !isFunctionExpression(n);

      case Token.NEW:
        if (checkForNewObjects) {
          return true;
        }

        if (!constructorCallHasSideEffects(n)) {
          
          
          break;
        }
        return true;

      case Token.CALL:
        
        
        if (!functionCallHasSideEffects(n, compiler)) {
          
          
          break;
        }
        return true;

      default:
        if (isSimpleOperatorType(n.getType())) {
          break;
        }

        if (isAssignmentOp(n)) {
          Node assignTarget = n.getFirstChild();
          if (isName(assignTarget)) {
            return true;
          }

          
          
          
          
          if (checkForStateChangeHelper(
                  n.getFirstChild(), checkForNewObjects, compiler) ||
              checkForStateChangeHelper(
                  n.getLastChild(), checkForNewObjects, compiler)) {
            return true;
          }

          if (isGet(assignTarget)) {
            
            
            
            
            Node current = assignTarget.getFirstChild();
            if (evaluatesToLocalValue(current)) {
              return false;
            }

            
            
            
            
            
            while (isGet(current)) {
              current = current.getFirstChild();
            }

            return !isLiteralValue(current, true);
          } else {
            
            
            
            return !isLiteralValue(assignTarget, true);
          }
        }

        return true;
    }

    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
      if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {
        return true;
      }
    }

    return false;
  }

  




  static boolean constructorCallHasSideEffects(Node callNode) {
    return constructorCallHasSideEffects(callNode, null);
  }

  static boolean constructorCallHasSideEffects(
      Node callNode, AbstractCompiler compiler) {
    if (callNode.getType() != Token.NEW) {
      throw new IllegalStateException(
          "Expected NEW node, got " + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();
    if (nameNode.getType() == Token.NAME &&
        CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(nameNode.getString())) {
      return false;
    }

    return true;
  }

  
  
  
  private static final Set<String> BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS =
      ImmutableSet.of(
          "Object", "Array", "String", "Number", "Boolean", "RegExp", "Error");
  private static final Set<String> OBJECT_METHODS_WITHOUT_SIDEEFFECTS =
      ImmutableSet.of("toString", "valueOf");
  private static final Set<String> REGEXP_METHODS =
      ImmutableSet.of("test", "exec");
  private static final Set<String> STRING_REGEXP_METHODS =
      ImmutableSet.of("match", "replace", "search", "split");

  




  static boolean functionCallHasSideEffects(Node callNode) {
    return functionCallHasSideEffects(callNode, null);
  }

  






  static boolean functionCallHasSideEffects(
      Node callNode, @Nullable AbstractCompiler compiler) {
    if (callNode.getType() != Token.CALL) {
      throw new IllegalStateException(
          "Expected CALL node, got " + Token.name(callNode.getType()));
    }

    if (callNode.isNoSideEffectsCall()) {
      return false;
    }

    Node nameNode = callNode.getFirstChild();

    
    if (nameNode.getType() == Token.NAME) {
      String name = nameNode.getString();
      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
        return false;
      }
    } else if (nameNode.getType() == Token.GETPROP) {
      if (callNode.hasOneChild()
          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
                nameNode.getLastChild().getString())) {
        return false;
      }

      if (callNode.isOnlyModifiesThisCall()
          && evaluatesToLocalValue(nameNode.getFirstChild())) {
        return false;
      }

      
      if (nameNode.getFirstChild().getType() == Token.NAME) {
        String namespaceName = nameNode.getFirstChild().getString();
        if (namespaceName.equals("Math")) {
          return false;
        }
      }

      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
        if (nameNode.getFirstChild().getType() == Token.REGEXP
            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
          return false;
        } else if (nameNode.getFirstChild().getType() == Token.STRING
            && STRING_REGEXP_METHODS.contains(
                nameNode.getLastChild().getString())) {
          Node param = nameNode.getNext();
          if (param != null &&
              (param.getType() == Token.STRING
                  || param.getType() == Token.REGEXP))
          return false;
        }
      }
    }

    return true;
  }

  


  static boolean callHasLocalResult(Node n) {
    Preconditions.checkState(n.getType() == Token.CALL);
    return (n.getSideEffectFlags() & Node.FLAG_LOCAL_RESULTS) > 0;
  }

  


  static boolean newHasLocalResult(Node n) {
    Preconditions.checkState(n.getType() == Token.NEW);
    return n.isOnlyModifiesThisCall();
  }

  






  static boolean nodeTypeMayHaveSideEffects(Node n) {
    return nodeTypeMayHaveSideEffects(n, null);
  }

  static boolean nodeTypeMayHaveSideEffects(Node n, AbstractCompiler compiler) {
    if (isAssignmentOp(n)) {
      return true;
    }

    switch(n.getType()) {
      case Token.DELPROP:
      case Token.DEC:
      case Token.INC:
      case Token.THROW:
        return true;
      case Token.CALL:
        return NodeUtil.functionCallHasSideEffects(n, compiler);
      case Token.NEW:
        return NodeUtil.constructorCallHasSideEffects(n, compiler);
      case Token.NAME:
        
        return n.hasChildren();
      default:
        return false;
    }
  }

  



  static boolean canBeSideEffected(Node n) {
    Set<String> emptySet = Collections.emptySet();
    return canBeSideEffected(n, emptySet);
  }

  





  static boolean canBeSideEffected(Node n, Set<String> knownConstants) {
    switch (n.getType()) {
      case Token.CALL:
      case Token.NEW:
        
        
        
        return true;
      case Token.NAME:
        
        return !isConstantName(n)
            && !knownConstants.contains(n.getString());

      
      case Token.GETPROP:
      case Token.GETELEM:
        return true;

      case Token.FUNCTION:
        
        
        Preconditions.checkState(isFunctionExpression(n));
        return false;
    }

    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
      if (canBeSideEffected(c, knownConstants)) {
        return true;
      }
    }

    return false;
  }

  
















  static int precedence(int type) {
    switch (type) {
      case Token.COMMA:  return 0;
      case Token.ASSIGN_BITOR:
      case Token.ASSIGN_BITXOR:
      case Token.ASSIGN_BITAND:
      case Token.ASSIGN_LSH:
      case Token.ASSIGN_RSH:
      case Token.ASSIGN_URSH:
      case Token.ASSIGN_ADD:
      case Token.ASSIGN_SUB:
      case Token.ASSIGN_MUL:
      case Token.ASSIGN_DIV:
      case Token.ASSIGN_MOD:
      case Token.ASSIGN: return 1;
      case Token.HOOK:   return 2;  
      case Token.OR:     return 3;
      case Token.AND:    return 4;
      case Token.BITOR:  return 5;
      case Token.BITXOR: return 6;
      case Token.BITAND: return 7;
      case Token.EQ:
      case Token.NE:
      case Token.SHEQ:
      case Token.SHNE:   return 8;
      case Token.LT:
      case Token.GT:
      case Token.LE:
      case Token.GE:
      case Token.INSTANCEOF:
      case Token.IN:     return 9;
      case Token.LSH:
      case Token.RSH:
      case Token.URSH:   return 10;
      case Token.SUB:
      case Token.ADD:    return 11;
      case Token.MUL:
      case Token.MOD:
      case Token.DIV:    return 12;
      case Token.INC:
      case Token.DEC:
      case Token.NEW:
      case Token.DELPROP:
      case Token.TYPEOF:
      case Token.VOID:
      case Token.NOT:
      case Token.BITNOT:
      case Token.POS:
      case Token.NEG:    return 13;

      case Token.ARRAYLIT:
      case Token.CALL:
      case Token.EMPTY:
      case Token.FALSE:
      case Token.FUNCTION:
      case Token.GETELEM:
      case Token.GETPROP:
      case Token.GET_REF:
      case Token.IF:
      case Token.LP:
      case Token.NAME:
      case Token.NULL:
      case Token.NUMBER:
      case Token.OBJECTLIT:
      case Token.REGEXP:
      case Token.RETURN:
      case Token.STRING:
      case Token.THIS:
      case Token.TRUE:
        return 15;

      default: throw new Error("Unknown precedence for " +
                               Node.tokenToName(type) +
                               " (type " + type + ")");
    }
  }

  



  static boolean valueCheck(Node n, Predicate<Node> p) {
    switch (n.getType()) {
      case Token.ASSIGN:
      case Token.COMMA:
        return valueCheck(n.getLastChild(), p);
      case Token.AND:
      case Token.OR:
        return valueCheck(n.getFirstChild(), p)
            && valueCheck(n.getLastChild(), p);
      case Token.HOOK:
        return valueCheck(n.getFirstChild().getNext(), p)
            && valueCheck(n.getLastChild(), p);
      default:
        return p.apply(n);
    }
  }

  static class NumbericResultPredicate implements Predicate<Node> {
    public boolean apply(Node n) {
      return isNumericResultHelper(n);
    }
  }

  static final NumbericResultPredicate NUMBERIC_RESULT_PREDICATE =
      new NumbericResultPredicate();

  


  static boolean isNumericResult(Node n) {
    return valueCheck(n, NUMBERIC_RESULT_PREDICATE);
  }

  static boolean isNumericResultHelper(Node n) {
    switch (n.getType()) {
      case Token.ADD:
        return !mayBeString(n.getFirstChild())
            && !mayBeString(n.getLastChild());
      case Token.BITNOT:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
      case Token.LSH:
      case Token.RSH:
      case Token.URSH:
      case Token.SUB:
      case Token.MUL:
      case Token.MOD:
      case Token.DIV:
      case Token.INC:
      case Token.DEC:
      case Token.POS:
      case Token.NEG:
      case Token.NUMBER:
        return true;
      case Token.NAME:
        String name = n.getString();
        if (name.equals("NaN")) {
          return true;
        }
        if (name.equals("Infinity")) {
          return true;
        }
        return false;
      default:
        return false;
    }
  }

  static class BooleanResultPredicate implements Predicate<Node> {
    public boolean apply(Node n) {
      return isBooleanResultHelper(n);
    }
  }

  static final BooleanResultPredicate BOOLEAN_RESULT_PREDICATE =
      new BooleanResultPredicate();

  


  static boolean isBooleanResult(Node n) {
    return valueCheck(n, BOOLEAN_RESULT_PREDICATE);
  }

  static boolean isBooleanResultHelper(Node n) {
    switch (n.getType()) {
      
      case Token.TRUE:
      case Token.FALSE:
      
      case Token.EQ:
      case Token.NE:
      case Token.SHEQ:
      case Token.SHNE:
      case Token.LT:
      case Token.GT:
      case Token.LE:
      case Token.GE:
      
      case Token.IN:
      case Token.INSTANCEOF:
      
      case Token.NOT:
      
      case Token.DELPROP:
        return true;
      default:
        return false;
    }
  }

  static boolean isUndefined(Node n) {
    switch (n.getType()) {
      case Token.VOID:
        return true;
      case Token.NAME:
        return n.getString().equals("undefined");
    }
    return false;
  }

  static boolean isNull(Node n) {
    return n.getType() == Token.NULL;
  }

  static boolean isNullOrUndefined(Node n) {
    return isNull(n) || isUndefined(n);
  }

  static class MayBeStringResultPredicate implements Predicate<Node> {
    public boolean apply(Node n) {
      return mayBeStringHelper(n);
    }
  }

  static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE =
      new MayBeStringResultPredicate();

  


  static boolean mayBeString(Node n) {
    return mayBeString(n, true);
  }

  static boolean mayBeString(Node n, boolean recurse) {
    if (recurse) {
      return valueCheck(n, MAY_BE_STRING_PREDICATE);
    } else {
      return mayBeStringHelper(n);
    }
  }

  static boolean mayBeStringHelper(Node n) {
    return !isNumericResult(n) && !isBooleanResult(n)
        && !isUndefined(n) && !isNull(n);
  }

  





  static boolean isAssociative(int type) {
    switch (type) {
      case Token.MUL:
      case Token.AND:
      case Token.OR:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
        return true;
      default:
        return false;
    }
  }

  






  static boolean isCommutative(int type) {
    switch (type) {
      case Token.MUL:
      case Token.BITOR:
      case Token.BITXOR:
      case Token.BITAND:
        return true;
      default:
        return false;
    }
  }

  static boolean isAssignmentOp(Node n) {
    switch (n.getType()){
      case Token.ASSIGN:
      case Token.ASSIGN_BITOR:
      case Token.ASSIGN_BITXOR:
      case Token.ASSIGN_BITAND:
      case Token.ASSIGN_LSH:
      case Token.ASSIGN_RSH:
      case Token.ASSIGN_URSH:
      case Token.ASSIGN_ADD:
      case Token.ASSIGN_SUB:
      case Token.ASSIGN_MUL:
      case Token.ASSIGN_DIV:
      case Token.ASSIGN_MOD:
        return true;
    }
    return false;
  }

  static int getOpFromAssignmentOp(Node n) {
    switch (n.getType()){
      case Token.ASSIGN_BITOR:
        return Token.BITOR;
      case Token.ASSIGN_BITXOR:
        return Token.BITXOR;
      case Token.ASSIGN_BITAND:
        return Token.BITAND;
      case Token.ASSIGN_LSH:
        return Token.LSH;
      case Token.ASSIGN_RSH:
        return Token.RSH;
      case Token.ASSIGN_URSH:
        return Token.URSH;
      case Token.ASSIGN_ADD:
        return Token.ADD;
      case Token.ASSIGN_SUB:
        return Token.SUB;
      case Token.ASSIGN_MUL:
        return Token.MUL;
      case Token.ASSIGN_DIV:
        return Token.DIV;
      case Token.ASSIGN_MOD:
        return Token.MOD;
    }
    throw new IllegalArgumentException("Not an assiment op");
  }

  static boolean isExpressionNode(Node n) {
    return n.getType() == Token.EXPR_RESULT;
  }

  



  static boolean containsFunction(Node n) {
    return containsType(n, Token.FUNCTION);
  }

  


  static boolean referencesThis(Node n) {
    return containsType(n, Token.THIS, new MatchNotFunction());
  }

  


  static boolean isGet(Node n) {
    return n.getType() == Token.GETPROP
        || n.getType() == Token.GETELEM;
  }

  


  static boolean isGetProp(Node n) {
    return n.getType() == Token.GETPROP;
  }

  


  static boolean isName(Node n) {
    return n.getType() == Token.NAME;
  }

  


  static boolean isNew(Node n) {
    return n.getType() == Token.NEW;
  }

  


  static boolean isVar(Node n) {
    return n.getType() == Token.VAR;
  }

  





  static boolean isVarDeclaration(Node n) {
    
    
    return n.getType() == Token.NAME && n.getParent().getType() == Token.VAR;
  }

  



  static Node getAssignedValue(Node n) {
    Preconditions.checkState(isName(n));
    Node parent = n.getParent();
    if (isVar(parent)) {
      return n.getFirstChild();
    } else if (isAssign(parent) && parent.getFirstChild() == n) {
      return n.getNext();
    } else {
      return null;
    }
  }

  


  static boolean isString(Node n) {
    return n.getType() == Token.STRING;
  }

  






  static boolean isExprAssign(Node n) {
    return n.getType() == Token.EXPR_RESULT
        && n.getFirstChild().getType() == Token.ASSIGN;
  }

  


  static boolean isAssign(Node n) {
    return n.getType() == Token.ASSIGN;
  }

  






  static boolean isExprCall(Node n) {
    return n.getType() == Token.EXPR_RESULT
        && n.getFirstChild().getType() == Token.CALL;
  }

  


  static boolean isForIn(Node n) {
    return n.getType() == Token.FOR
        && n.getChildCount() == 3;
  }

  


  static boolean isLoopStructure(Node n) {
    switch (n.getType()) {
      case Token.FOR:
      case Token.DO:
      case Token.WHILE:
        return true;
      default:
        return false;
    }
  }

  




  static Node getLoopCodeBlock(Node n) {
    switch (n.getType()) {
      case Token.FOR:
      case Token.WHILE:
        return n.getLastChild();
      case Token.DO:
        return n.getFirstChild();
      default:
        return null;
    }
  }

  



  static boolean isWithinLoop(Node n) {
    for (Node parent : n.getAncestors()) {
      if (NodeUtil.isLoopStructure(parent)) {
        return true;
      }

      if (NodeUtil.isFunction(parent)) {
        break;
      }
    }
    return false;
  }

  


  static boolean isControlStructure(Node n) {
    switch (n.getType()) {
      case Token.FOR:
      case Token.DO:
      case Token.WHILE:
      case Token.WITH:
      case Token.IF:
      case Token.LABEL:
      case Token.TRY:
      case Token.CATCH:
      case Token.SWITCH:
      case Token.CASE:
      case Token.DEFAULT:
        return true;
      default:
        return false;
    }
  }

  



  static boolean isControlStructureCodeBlock(Node parent, Node n) {
    switch (parent.getType()) {
      case Token.FOR:
      case Token.WHILE:
      case Token.LABEL:
      case Token.WITH:
        return parent.getLastChild() == n;
      case Token.DO:
        return parent.getFirstChild() == n;
      case Token.IF:
        return parent.getFirstChild() != n;
      case Token.TRY:
        return parent.getFirstChild() == n || parent.getLastChild() == n;
      case Token.CATCH:
        return parent.getLastChild() == n;
      case Token.SWITCH:
      case Token.CASE:
        return parent.getFirstChild() != n;
      case Token.DEFAULT:
        return true;
      default:
        Preconditions.checkState(isControlStructure(parent));
        return false;
    }
  }

  




  static Node getConditionExpression(Node n) {
    switch (n.getType()) {
      case Token.IF:
      case Token.WHILE:
        return n.getFirstChild();
      case Token.DO:
        return n.getLastChild();
      case Token.FOR:
        switch (n.getChildCount()) {
          case 3:
            return null;
          case 4:
            return n.getFirstChild().getNext();
        }
        throw new IllegalArgumentException("malformed 'for' statement " + n);
      case Token.CASE:
        return null;
    }
    throw new IllegalArgumentException(n + " does not have a condition.");
  }

  


  static boolean isStatementBlock(Node n) {
    return n.getType() == Token.SCRIPT || n.getType() == Token.BLOCK;
  }

  


  static boolean isStatement(Node n) {
    Node parent = n.getParent();
    
    
    
    Preconditions.checkState(parent != null);
    switch (parent.getType()) {
      case Token.SCRIPT:
      case Token.BLOCK:
      case Token.LABEL:
        return true;
      default:
        return false;
    }
  }

  
  static boolean isSwitchCase(Node n) {
    return n.getType() == Token.CASE || n.getType() == Token.DEFAULT;
  }

  



  static boolean isReferenceName(Node n) {
    return isName(n) && !n.getString().isEmpty();
  }

  
  static boolean isLabelName(Node n) {
    return (n != null && n.getType() == Token.LABEL_NAME);
  }

  
  static boolean isTryFinallyNode(Node parent, Node child) {
    return parent.getType() == Token.TRY && parent.getChildCount() == 3
        && child == parent.getLastChild();
  }

  
  static boolean isTryCatchNodeContainer(Node n) {
    Node parent = n.getParent();
    return parent.getType() == Token.TRY
        && parent.getFirstChild().getNext() == n;
  }

  
  static void removeChild(Node parent, Node node) {
    if (isTryFinallyNode(parent, node)) {
      if (NodeUtil.hasCatchHandler(getCatchBlock(parent))) {
        
        parent.removeChild(node);
      } else {
        
        node.detachChildren();
      }
    } else if (node.getType() == Token.CATCH) {
      
      Node tryNode = node.getParent().getParent();
      Preconditions.checkState(NodeUtil.hasFinally(tryNode));
      node.detachFromParent();
    } else if (isTryCatchNodeContainer(node)) {
      
      
      Node tryNode = node.getParent();
      Preconditions.checkState(NodeUtil.hasFinally(tryNode));
      node.detachChildren();
    } else if (node.getType() == Token.BLOCK) {
      
      
      node.detachChildren();
    } else if (isStatementBlock(parent)
        || isSwitchCase(node)) {
      
      parent.removeChild(node);
    } else if (parent.getType() == Token.VAR) {
      if (parent.hasMoreThanOneChild()) {
        parent.removeChild(node);
      } else {
        
        parent.removeChild(node);
        
        removeChild(parent.getParent(), parent);
      }
    } else if (parent.getType() == Token.LABEL
        && node == parent.getLastChild()) {
      
      parent.removeChild(node);
      
      removeChild(parent.getParent(), parent);
    } else if (parent.getType() == Token.FOR
        && parent.getChildCount() == 4) {
      
      
      
      parent.replaceChild(node, new Node(Token.EMPTY));
    } else {
      throw new IllegalStateException("Invalid attempt to remove node: " +
          node.toString() + " of "+ parent.toString());
    }
  }

  


  static void maybeAddFinally(Node tryNode) {
    Preconditions.checkState(tryNode.getType() == Token.TRY);
    if (!NodeUtil.hasFinally(tryNode)) {
      tryNode.addChildrenToBack(new Node(Token.BLOCK)
          .copyInformationFrom(tryNode));
    }
  }

  



  static boolean tryMergeBlock(Node block) {
    Preconditions.checkState(block.getType() == Token.BLOCK);
    Node parent = block.getParent();
    
    
    if (isStatementBlock(parent)) {
      Node previous = block;
      while (block.hasChildren()) {
        Node child = block.removeFirstChild();
        parent.addChildAfter(child, previous);
        previous = child;
      }
      parent.removeChild(block);
      return true;
    } else {
      return false;
    }
  }

  


  static boolean isCall(Node n) {
    return n.getType() == Token.CALL;
  }

  



  static boolean isCallOrNew(Node node) {
    return NodeUtil.isCall(node) || NodeUtil.isNew(node);
  }

  


  static boolean isFunction(Node n) {
    return n.getType() == Token.FUNCTION;
  }

  


  static Node getFunctionBody(Node fn) {
    Preconditions.checkArgument(isFunction(fn));
    return fn.getLastChild();
  }

  


  static boolean isThis(Node node) {
    return node.getType() == Token.THIS;
  }


  


  static boolean isArrayLiteral(Node node) {
    return node.getType() == Token.ARRAYLIT;
  }

  


  static boolean isSparseArray(Node node) {
    Preconditions.checkArgument(isArrayLiteral(node));
    int[] skipList = (int[]) node.getProp(Node.SKIP_INDEXES_PROP);
    return skipList != null && skipList.length > 0;
  }

  


  static boolean containsCall(Node n) {
    return containsType(n, Token.CALL);
  }

  




  static boolean isFunctionDeclaration(Node n) {
    return n.getType() == Token.FUNCTION && isStatement(n);
  }

  




  static boolean isHoistedFunctionDeclaration(Node n) {
    return isFunctionDeclaration(n)
        && (n.getParent().getType() == Token.SCRIPT
            || n.getParent().getParent().getType() == Token.FUNCTION);
  }

  






















  static boolean isFunctionExpression(Node n) {
    return n.getType() == Token.FUNCTION && !isStatement(n);
  }

  





  static boolean isEmptyFunctionExpression(Node node) {
    return isFunctionExpression(node) && isEmptyBlock(node.getLastChild());
  }

  



  static boolean isVarArgsFunction(Node function) {
    Preconditions.checkArgument(isFunction(function));
    return isNameReferenced(
        function.getLastChild(),
        "arguments",
        new MatchNotFunction());
  }

  




  static boolean isObjectCallMethod(Node callNode, String methodName) {
    if (callNode.getType() == Token.CALL) {
      Node functionIndentifyingExpression = callNode.getFirstChild();
      if (isGet(functionIndentifyingExpression)) {
        Node last = functionIndentifyingExpression.getLastChild();
        if (last != null && last.getType() == Token.STRING) {
          String propName = last.getString();
          return (propName.equals(methodName));
        }
      }
    }
    return false;
  }


  




  static boolean isFunctionObjectCall(Node callNode) {
    return isObjectCallMethod(callNode, "call");
  }

  




  static boolean isFunctionObjectApply(Node callNode) {
    return isObjectCallMethod(callNode, "apply");
  }

  







  static boolean isFunctionObjectCallOrApply(Node callNode) {
    return isFunctionObjectCall(callNode) || isFunctionObjectApply(callNode);
  }

  





  static boolean isSimpleFunctionObjectCall(Node callNode) {
    if (isFunctionObjectCall(callNode)) {
      if (callNode.getFirstChild().getFirstChild().getType() == Token.NAME) {
        return true;
      }
    }

    return false;
  }

  








  static boolean isLhs(Node n, Node parent) {
    return (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) ||
           parent.getType() == Token.VAR;
  }

  






  static boolean isObjectLitKey(Node node, Node parent) {
    switch (node.getType()) {
      case Token.NUMBER:
      case Token.STRING:
        return parent.getType() == Token.OBJECTLIT;
      case Token.GET:
      case Token.SET:
        return true;
    }
    return false;
  }

  




  static String getObjectLitKeyName(Node key) {
    switch (key.getType()) {
      case Token.NUMBER:
        return NodeUtil.getStringValue(key);
      case Token.STRING:
      case Token.GET:
      case Token.SET:
        return key.getString();
    }
    throw new IllegalStateException("Unexpected node type: " + key);
  }

  



  static JSType getObjectLitKeyTypeFromValueType(Node key, JSType valueType) {
    if (valueType != null) {
      switch (key.getType()) {
        case Token.GET:
          
          if (valueType.isFunctionType()) {
            FunctionType fntype = ((FunctionType) valueType);
            valueType = fntype.getReturnType();
          } else {
            return null;
          }
          break;
        case Token.SET:
          if (valueType.isFunctionType()) {
            
            FunctionType fntype = ((FunctionType) valueType);
            Node param = fntype.getParametersNode().getFirstChild();
            
            valueType = param.getJSType();
          } else {
            return null;
          }
          break;
      }
    }
    return valueType;
  }

  





  static boolean isGetOrSetKey(Node node) {
    switch (node.getType()) {
      case Token.GET:
      case Token.SET:
        return true;
    }
    return false;
  }

  







  static String opToStr(int operator) {
    switch (operator) {
      case Token.BITOR: return "|";
      case Token.OR: return "||";
      case Token.BITXOR: return "^";
      case Token.AND: return "&&";
      case Token.BITAND: return "&";
      case Token.SHEQ: return "===";
      case Token.EQ: return "==";
      case Token.NOT: return "!";
      case Token.NE: return "!=";
      case Token.SHNE: return "!==";
      case Token.LSH: return "<<";
      case Token.IN: return "in";
      case Token.LE: return "<=";
      case Token.LT: return "<";
      case Token.URSH: return ">>>";
      case Token.RSH: return ">>";
      case Token.GE: return ">=";
      case Token.GT: return ">";
      case Token.MUL: return "*";
      case Token.DIV: return "/";
      case Token.MOD: return "%";
      case Token.BITNOT: return "~";
      case Token.ADD: return "+";
      case Token.SUB: return "-";
      case Token.POS: return "+";
      case Token.NEG: return "-";
      case Token.ASSIGN: return "=";
      case Token.ASSIGN_BITOR: return "|=";
      case Token.ASSIGN_BITXOR: return "^=";
      case Token.ASSIGN_BITAND: return "&=";
      case Token.ASSIGN_LSH: return "<<=";
      case Token.ASSIGN_RSH: return ">>=";
      case Token.ASSIGN_URSH: return ">>>=";
      case Token.ASSIGN_ADD: return "+=";
      case Token.ASSIGN_SUB: return "-=";
      case Token.ASSIGN_MUL: return "*=";
      case Token.ASSIGN_DIV: return "/=";
      case Token.ASSIGN_MOD: return "%=";
      case Token.VOID: return "void";
      case Token.TYPEOF: return "typeof";
      case Token.INSTANCEOF: return "instanceof";
      default: return null;
    }
  }

  







  static String opToStrNoFail(int operator) {
    String res = opToStr(operator);
    if (res == null) {
      throw new Error("Unknown op " + operator + ": " +
                      Token.name(operator));
    }
    return res;
  }

  


  static boolean containsType(Node node,
                              int type,
                              Predicate<Node> traverseChildrenPred) {
    return has(node, new MatchNodeType(type), traverseChildrenPred);
  }

  


  static boolean containsType(Node node, int type) {
    return containsType(node, type, Predicates.<Node>alwaysTrue());
  }


  




  static void redeclareVarsInsideBranch(Node branch) {
    Collection<Node> vars = getVarsDeclaredInBranch(branch);
    if (vars.isEmpty()) {
      return;
    }

    Node parent = getAddingRoot(branch);
    for (Node nameNode : vars) {
      Node var = new Node(
          Token.VAR,
          Node.newString(Token.NAME, nameNode.getString())
              .copyInformationFrom(nameNode))
          .copyInformationFrom(nameNode);
      copyNameAnnotations(nameNode, var.getFirstChild());
      parent.addChildToFront(var);
    }
  }

  




  static void copyNameAnnotations(Node source, Node destination) {
    if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) {
      destination.putBooleanProp(Node.IS_CONSTANT_NAME, true);
    }
  }

  



  private static Node getAddingRoot(Node n) {
    Node addingRoot = null;
    Node ancestor = n;
    while (null != (ancestor = ancestor.getParent())) {
      int type = ancestor.getType();
      if (type == Token.SCRIPT) {
        addingRoot = ancestor;
        break;
      } else if (type == Token.FUNCTION) {
        addingRoot = ancestor.getLastChild();
        break;
      }
    }

    
    Preconditions.checkState(addingRoot.getType() == Token.BLOCK ||
        addingRoot.getType() == Token.SCRIPT);
    Preconditions.checkState(addingRoot.getFirstChild() == null ||
        addingRoot.getFirstChild().getType() != Token.SCRIPT);
    return addingRoot;
  }

  
  public static Node newFunctionNode(String name, List<Node> params,
      Node body, int lineno, int charno) {
    Node parameterParen = new Node(Token.LP, lineno, charno);
    for (Node param : params) {
      parameterParen.addChildToBack(param);
    }
    Node function = new Node(Token.FUNCTION, lineno, charno);
    function.addChildrenToBack(
        Node.newString(Token.NAME, name, lineno, charno));
    function.addChildToBack(parameterParen);
    function.addChildToBack(body);
    return function;
  }

  







  public static Node newQualifiedNameNode(
      CodingConvention convention, String name, int lineno, int charno) {
    int endPos = name.indexOf('.');
    if (endPos == -1) {
      return newName(convention, name, lineno, charno);
    }
    Node node = newName(
        convention, name.substring(0, endPos), lineno, charno);
    int startPos;
    do {
      startPos = endPos + 1;
      endPos = name.indexOf('.', startPos);
      String part = (endPos == -1
                     ? name.substring(startPos)
                     : name.substring(startPos, endPos));
      Node propNode = Node.newString(Token.STRING, part, lineno, charno);
      if (convention.isConstantKey(part)) {
        propNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
      }
      node = new Node(Token.GETPROP, node, propNode, lineno, charno);
    } while (endPos != -1);

    return node;
  }

  












  static Node newQualifiedNameNode(
      CodingConvention convention, String name, Node basisNode,
      String originalName) {
    Node node = newQualifiedNameNode(convention, name, -1, -1);
    setDebugInformation(node, basisNode, originalName);
    return node;
  }

  


  static Node getRootOfQualifiedName(Node qName) {
    for (Node current = qName; true;
         current = current.getFirstChild()) {
      int type = current.getType();
      if (type == Token.NAME || type == Token.THIS) {
        return current;
      }
      Preconditions.checkState(type == Token.GETPROP);
    }
  }

  







  static void setDebugInformation(Node node, Node basisNode,
                                  String originalName) {
    node.copyInformationFromForTree(basisNode);
    node.putProp(Node.ORIGINALNAME_PROP, originalName);
  }

  private static Node newName(
      CodingConvention convention, String name, int lineno, int charno) {
    Node nameNode = Node.newString(Token.NAME, name, lineno, charno);
    if (convention.isConstant(name)) {
      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
    }
    return nameNode;
  }

  









  static Node newName(
      CodingConvention convention, String name, Node basisNode) {
    Node nameNode = Node.newString(Token.NAME, name);
    if (convention.isConstantKey(name)) {
      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
    }
    nameNode.copyInformationFrom(basisNode);
    return nameNode;
  }

  












  static Node newName(
      CodingConvention convention, String name,
      Node basisNode, String originalName) {
    Node nameNode = newName(convention, name, basisNode);
    nameNode.putProp(Node.ORIGINALNAME_PROP, originalName);
    return nameNode;
  }

  













  static boolean isLatin(String s) {
    char LARGEST_BASIC_LATIN = 0x7f;
    int len = s.length();
    for (int index = 0; index < len; index++) {
      char c = s.charAt(index);
      if (c > LARGEST_BASIC_LATIN) {
        return false;
      }
    }
    return true;
  }

  



  static boolean isValidPropertyName(String name) {
    return TokenStream.isJSIdentifier(name) &&
        !TokenStream.isKeyword(name) &&
        
        
        
        
        
        
        isLatin(name);
  }

  private static class VarCollector implements Visitor {
    final Map<String, Node> vars = Maps.newLinkedHashMap();

    public void visit(Node n) {
      if (n.getType() == Token.NAME) {
        Node parent = n.getParent();
        if (parent != null && parent.getType() == Token.VAR) {
          String name = n.getString();
          if (!vars.containsKey(name)) {
            vars.put(name, n);
          }
        }
      }
    }
  }

  


  public static Collection<Node> getVarsDeclaredInBranch(Node root) {
    VarCollector collector = new VarCollector();
    visitPreOrder(
        root,
        collector,
        new MatchNotFunction());
    return collector.vars.values();
  }

  



  static boolean isPrototypePropertyDeclaration(Node n) {
    if (!isExprAssign(n)) {
      return false;
    }
    return isPrototypeProperty(n.getFirstChild().getFirstChild());
  }

  static boolean isPrototypeProperty(Node n) {
    String lhsString = n.getQualifiedName();
    if (lhsString == null) {
      return false;
    }
    int prototypeIdx = lhsString.indexOf(".prototype.");
    return prototypeIdx != -1;
  }

  


  static Node getPrototypeClassName(Node qName) {
    Node cur = qName;
    while (isGetProp(cur)) {
      if (cur.getLastChild().getString().equals("prototype")) {
        return cur.getFirstChild();
      } else {
        cur = cur.getFirstChild();
      }
    }
    return null;
  }

  


  static String getPrototypePropertyName(Node qName) {
    String qNameStr = qName.getQualifiedName();
    int prototypeIdx = qNameStr.lastIndexOf(".prototype.");
    int memberIndex = prototypeIdx + ".prototype".length() + 1;
    return qNameStr.substring(memberIndex);
  }

  



  static Node newUndefinedNode(Node srcReferenceNode) {
    Node node = new Node(Token.VOID, Node.newNumber(0));
    if (srcReferenceNode != null) {
        node.copyInformationFromForTree(srcReferenceNode);
    }
    return node;
  }

  


  static Node newVarNode(String name, Node value) {
    Node nodeName = Node.newString(Token.NAME, name);
    if (value != null) {
      Preconditions.checkState(value.getNext() == null);
      nodeName.addChildToBack(value);
      nodeName.copyInformationFrom(value);
    }
    Node var = new Node(Token.VAR, nodeName)
        .copyInformationFrom(nodeName);

    return var;
  }

  


  private static class MatchNameNode implements Predicate<Node>{
    final String name;

    MatchNameNode(String name){
      this.name = name;
    }

    public boolean apply(Node n) {
      return n.getType() == Token.NAME
          && n.getString().equals(name);
    }
  }

  


  static class MatchNodeType implements Predicate<Node>{
    final int type;

    MatchNodeType(int type){
      this.type = type;
    }

    public boolean apply(Node n) {
      return n.getType() == type;
    }
  }


  


  static class MatchDeclaration implements Predicate<Node> {
    public boolean apply(Node n) {
      return isFunctionDeclaration(n) || n.getType() == Token.VAR;
    }
  }

  


  static class MatchNotFunction implements Predicate<Node>{
    public boolean apply(Node n) {
      return !isFunction(n);
    }
  }

  


  static class MatchShallowStatement implements Predicate<Node>{
    public boolean apply(Node n) {
      Node parent = n.getParent();
      return n.getType() == Token.BLOCK
          || (!isFunction(n) && (parent == null
              || isControlStructure(parent)
              || isStatementBlock(parent)));
    }
  }

  


  static int getNodeTypeReferenceCount(
      Node node, int type, Predicate<Node> traverseChildrenPred) {
    return getCount(node, new MatchNodeType(type), traverseChildrenPred);
  }

  


  static boolean isNameReferenced(Node node,
                                  String name,
                                  Predicate<Node> traverseChildrenPred) {
    return has(node, new MatchNameNode(name), traverseChildrenPred);
  }

  


  static boolean isNameReferenced(Node node, String name) {
    return isNameReferenced(node, name, Predicates.<Node>alwaysTrue());
  }

  


  static int getNameReferenceCount(Node node, String name) {
    return getCount(
        node, new MatchNameNode(name), Predicates.<Node>alwaysTrue());
  }

  


  static boolean has(Node node,
                     Predicate<Node> pred,
                     Predicate<Node> traverseChildrenPred) {
    if (pred.apply(node)) {
      return true;
    }

    if (!traverseChildrenPred.apply(node)) {
      return false;
    }

    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {
      if (has(c, pred, traverseChildrenPred)) {
        return true;
      }
    }

    return false;
  }

  



  static int getCount(
      Node n, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) {
    int total = 0;

    if (pred.apply(n)) {
      total++;
    }

    if (traverseChildrenPred.apply(n)) {
      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        total += getCount(c, pred, traverseChildrenPred);
      }
    }

    return total;
  }

  



  static interface Visitor {
    void visit(Node node);
  }

  



  static void visitPreOrder(Node node,
                     Visitor vistor,
                     Predicate<Node> traverseChildrenPred) {
    vistor.visit(node);

    if (traverseChildrenPred.apply(node)) {
      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {
        visitPreOrder(c, vistor, traverseChildrenPred);
      }
    }
  }

  



  static void visitPostOrder(Node node,
                     Visitor vistor,
                     Predicate<Node> traverseChildrenPred) {
    if (traverseChildrenPred.apply(node)) {
      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {
        visitPostOrder(c, vistor, traverseChildrenPred);
      }
    }

    vistor.visit(node);
  }

  


  static boolean hasFinally(Node n) {
    Preconditions.checkArgument(n.getType() == Token.TRY);
    return n.getChildCount() == 3;
  }

  



  static Node getCatchBlock(Node n) {
    Preconditions.checkArgument(n.getType() == Token.TRY);
    return n.getFirstChild().getNext();
  }

  



  static boolean hasCatchHandler(Node n) {
    Preconditions.checkArgument(n.getType() == Token.BLOCK);
    return n.hasChildren() && n.getFirstChild().getType() == Token.CATCH;
  }

  



  static Node getFnParameters(Node fnNode) {
    
    Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION);
    return fnNode.getFirstChild().getNext();
  }

  
















  static boolean isConstantName(Node node) {
    return node.getBooleanProp(Node.IS_CONSTANT_NAME);
  }

  
  static boolean isConstantByConvention(
      CodingConvention convention, Node node, Node parent) {
    String name = node.getString();
    if (parent.getType() == Token.GETPROP &&
        node == parent.getLastChild()) {
      return convention.isConstantKey(name);
    } else if (isObjectLitKey(node, parent)) {
      return convention.isConstantKey(name);
    } else {
      return convention.isConstant(name);
    }
  }

  



  static JSDocInfo getInfoForNameNode(Node nameNode) {
    JSDocInfo info = null;
    Node parent = null;
    if (nameNode != null) {
      info = nameNode.getJSDocInfo();
      parent = nameNode.getParent();
    }

    if (info == null && parent != null &&
        ((parent.getType() == Token.VAR && parent.hasOneChild()) ||
          parent.getType() == Token.FUNCTION)) {
      info = parent.getJSDocInfo();
    }
    return info;
  }

  


  static JSDocInfo getFunctionInfo(Node n) {
    Preconditions.checkState(n.getType() == Token.FUNCTION);
    JSDocInfo fnInfo = n.getJSDocInfo();
    if (fnInfo == null && NodeUtil.isFunctionExpression(n)) {
      
      Node parent = n.getParent();
      if (parent.getType() == Token.ASSIGN) {
        
        fnInfo = parent.getJSDocInfo();
      } else if (parent.getType() == Token.NAME) {
        
        fnInfo = parent.getParent().getJSDocInfo();
      }
    }
    return fnInfo;
  }

  



  static String getSourceName(Node n) {
    String sourceName = null;
    while (sourceName == null && n != null) {
      sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
      n = n.getParent();
    }
    return sourceName;
  }

  


  static Node newCallNode(Node callTarget, Node... parameters) {
    boolean isFreeCall = isName(callTarget);
    Node call = new Node(Token.CALL, callTarget);
    call.putBooleanProp(Node.FREE_CALL, isFreeCall);
    for (Node parameter : parameters) {
      call.addChildToBack(parameter);
    }
    return call;
  }

  



  static boolean evaluatesToLocalValue(Node value) {
    return evaluatesToLocalValue(value, Predicates.<Node>alwaysFalse());
  }

  




  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
      case Token.ASSIGN:
        
        
        
        return NodeUtil.isImmutableValue(value.getLastChild())
            || (locals.apply(value)
                && evaluatesToLocalValue(value.getLastChild(), locals));
      case Token.COMMA:
        return evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.AND:
      case Token.OR:
        return evaluatesToLocalValue(value.getFirstChild(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.HOOK:
        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.INC:
      case Token.DEC:
        if (value.getBooleanProp(Node.INCRDECR_PROP)) {
          return evaluatesToLocalValue(value.getFirstChild(), locals);
        } else {
          return true;
        }
      case Token.THIS:
        return locals.apply(value);
      case Token.NAME:
        return isImmutableValue(value) || locals.apply(value);
      case Token.GETELEM:
      case Token.GETPROP:
        
        return locals.apply(value);
      case Token.CALL:
        return callHasLocalResult(value)
            || isToStringMethodCall(value)
            || locals.apply(value);
      case Token.NEW:
        return newHasLocalResult(value)
               || locals.apply(value);
      case Token.FUNCTION:
      case Token.REGEXP:
      case Token.ARRAYLIT:
      case Token.OBJECTLIT:
        
        return true;
      case Token.DELPROP:
      case Token.IN:
        
        return true;
      default:
        
        
        
        if (isAssignmentOp(value)
            || isSimpleOperator(value)
            || isImmutableValue(value)) {
          return true;
        }

        throw new IllegalStateException(
            "Unexpected expression node" + value +
            "\n parent:" + value.getParent());
    }
  }

  




  private static Node getNthSibling(Node first, int index) {
    Node sibling = first;
    while (index != 0 && sibling != null) {
      sibling = sibling.getNext();
      index--;
    }
    return sibling;
  }

  



  static Node getArgumentForFunction(Node function, int index) {
    Preconditions.checkState(isFunction(function));
    return getNthSibling(
        function.getFirstChild().getNext().getFirstChild(), index);
  }

  



  static Node getArgumentForCallOrNew(Node call, int index) {
    Preconditions.checkState(isCallOrNew(call));
    return getNthSibling(
      call.getFirstChild().getNext(), index);
  }

  private static boolean isToStringMethodCall(Node call) {
    Node getNode = call.getFirstChild();
    if (isGet(getNode)) {
      Node propNode = getNode.getLastChild();
      return isString(propNode) && "toString".equals(propNode.getString());
    }
    return false;
  }
}
