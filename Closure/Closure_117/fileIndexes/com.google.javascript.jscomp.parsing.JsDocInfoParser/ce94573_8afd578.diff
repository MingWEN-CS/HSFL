192d191
<   @SuppressWarnings("incomplete-switch")
194,199d192
<     int lineno;
<     int charno;
< 
<     
<     JSTypeExpression type;
< 
224c217
<     retry: for (;;) {
---
>     while (true) {
229,230c222,286
<             lineno = stream.getLineno();
<             charno = stream.getCharno();
---
>             token = parseAnnotation(token, extendedTypes);
>           } else {
>             token = next();
>           }
>           break;
> 
>         case EOC:
>           if (hasParsedFileOverviewDocInfo()) {
>             fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
>           }
>           checkExtendedTypes(extendedTypes);
>           return true;
> 
>         case EOF:
>           
>           jsdocBuilder.build(null);
>           parser.addParserWarning("msg.unexpected.eof",
>               stream.getLineno(), stream.getCharno());
>           checkExtendedTypes(extendedTypes);
>           return false;
> 
>         case EOL:
>           if (state == State.SEARCHING_NEWLINE) {
>             state = State.SEARCHING_ANNOTATION;
>           }
>           token = next();
>           break;
> 
>         default:
>           if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
>             token = next();
>           } else {
>             state = State.SEARCHING_NEWLINE;
>             token = eatTokensUntilEOL();
>           }
>           break;
>       }
>     }
>   }
> 
>   private JsDocToken parseAnnotation(JsDocToken token,
>       List<ExtendedTypeInfo> extendedTypes) {
>     
>     JSTypeExpression type;
>     int lineno = stream.getLineno();
>     int charno = stream.getCharno();
> 
>     String annotationName = stream.getString();
>     Annotation annotation = annotationNames.get(annotationName);
>     if (annotation == null) {
>       parser.addParserWarning("msg.bad.jsdoc.tag", annotationName,
>           stream.getLineno(), stream.getCharno());
>     } else {
>       
>       jsdocBuilder.markAnnotation(annotationName, lineno, charno);
> 
>       switch (annotation) {
>         case NG_INJECT:
>           if (jsdocBuilder.isNgInjectRecorded()) {
>             parser.addParserWarning("msg.jsdoc.nginject.extra",
>               stream.getLineno(), stream.getCharno());
>           } else {
>             jsdocBuilder.recordNgInject(true);
>           }
>           return eatTokensUntilEOL();
232,235c288,294
<             String annotationName = stream.getString();
<             Annotation annotation = annotationNames.get(annotationName);
<             if (annotation == null) {
<               parser.addParserWarning("msg.bad.jsdoc.tag", annotationName,
---
>         case AUTHOR:
>           if (jsdocBuilder.shouldParseDocumentation()) {
>             ExtractionInfo authorInfo = extractSingleLineBlock();
>             String author = authorInfo.string;
> 
>             if (author.length() == 0) {
>               parser.addParserWarning("msg.jsdoc.authormissing",
238,239c297,303
<               
<               jsdocBuilder.markAnnotation(annotationName, lineno, charno);
---
>               jsdocBuilder.addAuthor(author);
>             }
>             token = authorInfo.token;
>           } else {
>             token = eatTokensUntilEOL(token);
>           }
>           return token;
241,250c305,310
<               switch (annotation) {
<                 case NG_INJECT:
<                   if (jsdocBuilder.isNgInjectRecorded()) {
<                     parser.addParserWarning("msg.jsdoc.nginject.extra",
<                       stream.getLineno(), stream.getCharno());
<                   } else {
<                     jsdocBuilder.recordNgInject(true);
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>         case CONSISTENTIDGENERATOR:
>           if (!jsdocBuilder.recordConsistentIdGenerator()) {
>             parser.addParserWarning("msg.jsdoc.consistidgen",
>               stream.getLineno(), stream.getCharno());
>           }
>           return eatTokensUntilEOL();
252,267c312,318
<                 case AUTHOR:
<                   if (jsdocBuilder.shouldParseDocumentation()) {
<                     ExtractionInfo authorInfo = extractSingleLineBlock();
<                     String author = authorInfo.string;
< 
<                     if (author.length() == 0) {
<                       parser.addParserWarning("msg.jsdoc.authormissing",
<                           stream.getLineno(), stream.getCharno());
<                     } else {
<                       jsdocBuilder.addAuthor(author);
<                     }
<                     token = authorInfo.token;
<                   } else {
<                     token = eatTokensUntilEOL(token);
<                   }
<                   continue retry;
---
>         case STRUCT:
>           if (!jsdocBuilder.recordStruct()) {
>             parser.addTypeWarning("msg.jsdoc.incompat.type",
>                                   stream.getLineno(),
>                                   stream.getCharno());
>           }
>           return eatTokensUntilEOL();
269,275c320,326
<                 case CONSISTENTIDGENERATOR:
<                   if (!jsdocBuilder.recordConsistentIdGenerator()) {
<                     parser.addParserWarning("msg.jsdoc.consistidgen",
<                       stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>         case DICT:
>           if (!jsdocBuilder.recordDict()) {
>             parser.addTypeWarning("msg.jsdoc.incompat.type",
>                                   stream.getLineno(),
>                                   stream.getCharno());
>           }
>           return eatTokensUntilEOL();
277,284c328,338
<                 case STRUCT:
<                   if (!jsdocBuilder.recordStruct()) {
<                     parser.addTypeWarning("msg.jsdoc.incompat.type",
<                                           stream.getLineno(),
<                                           stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>         case CONSTRUCTOR:
>           if (!jsdocBuilder.recordConstructor()) {
>             if (jsdocBuilder.isInterfaceRecorded()) {
>               parser.addTypeWarning("msg.jsdoc.interface.constructor",
>                   stream.getLineno(), stream.getCharno());
>             } else {
>               parser.addTypeWarning("msg.jsdoc.incompat.type",
>                   stream.getLineno(), stream.getCharno());
>             }
>           }
>           return eatTokensUntilEOL();
286,293c340,344
<                 case DICT:
<                   if (!jsdocBuilder.recordDict()) {
<                     parser.addTypeWarning("msg.jsdoc.incompat.type",
<                                           stream.getLineno(),
<                                           stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>         case DEPRECATED:
>           if (!jsdocBuilder.recordDeprecated()) {
>             parser.addParserWarning("msg.jsdoc.deprecated",
>                 stream.getLineno(), stream.getCharno());
>           }
295,306c346,348
<                 case CONSTRUCTOR:
<                   if (!jsdocBuilder.recordConstructor()) {
<                     if (jsdocBuilder.isInterfaceRecorded()) {
<                       parser.addTypeWarning("msg.jsdoc.interface.constructor",
<                           stream.getLineno(), stream.getCharno());
<                     } else {
<                       parser.addTypeWarning("msg.jsdoc.incompat.type",
<                           stream.getLineno(), stream.getCharno());
<                     }
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>           
>           ExtractionInfo reasonInfo =
>               extractMultilineTextualBlock(token);
308,312c350
<                 case DEPRECATED:
<                   if (!jsdocBuilder.recordDeprecated()) {
<                     parser.addParserWarning("msg.jsdoc.deprecated",
<                         stream.getLineno(), stream.getCharno());
<                   }
---
>           String reason = reasonInfo.string;
314,316c352,354
<                   
<                   ExtractionInfo reasonInfo =
<                       extractMultilineTextualBlock(token);
---
>           if (reason.length() > 0) {
>             jsdocBuilder.recordDeprecationReason(reason);
>           }
318c356,357
<                   String reason = reasonInfo.string;
---
>           token = reasonInfo.token;
>           return token;
320,322c359,369
<                   if (reason.length() > 0) {
<                     jsdocBuilder.recordDeprecationReason(reason);
<                   }
---
>         case INTERFACE:
>           if (!jsdocBuilder.recordInterface()) {
>             if (jsdocBuilder.isConstructorRecorded()) {
>               parser.addTypeWarning("msg.jsdoc.interface.constructor",
>                   stream.getLineno(), stream.getCharno());
>             } else {
>               parser.addTypeWarning("msg.jsdoc.incompat.type",
>                   stream.getLineno(), stream.getCharno());
>             }
>           }
>           return eatTokensUntilEOL();
324,325c371,378
<                   token = reasonInfo.token;
<                   continue retry;
---
>         case DESC:
>           if (jsdocBuilder.isDescriptionRecorded()) {
>             parser.addParserWarning("msg.jsdoc.desc.extra",
>                 stream.getLineno(), stream.getCharno());
>             return eatTokensUntilEOL();
>           } else {
>             ExtractionInfo descriptionInfo =
>                 extractMultilineTextualBlock(token);
327,338c380
<                 case INTERFACE:
<                   if (!jsdocBuilder.recordInterface()) {
<                     if (jsdocBuilder.isConstructorRecorded()) {
<                       parser.addTypeWarning("msg.jsdoc.interface.constructor",
<                           stream.getLineno(), stream.getCharno());
<                     } else {
<                       parser.addTypeWarning("msg.jsdoc.incompat.type",
<                           stream.getLineno(), stream.getCharno());
<                     }
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>             String description = descriptionInfo.string;
340,355c382,385
<                 case DESC:
<                   if (jsdocBuilder.isDescriptionRecorded()) {
<                     parser.addParserWarning("msg.jsdoc.desc.extra",
<                         stream.getLineno(), stream.getCharno());
<                     token = eatTokensUntilEOL();
<                     continue retry;
<                   } else {
<                     ExtractionInfo descriptionInfo =
<                         extractMultilineTextualBlock(token);
< 
<                     String description = descriptionInfo.string;
< 
<                     jsdocBuilder.recordDescription(description);
<                     token = descriptionInfo.token;
<                     continue retry;
<                   }
---
>             jsdocBuilder.recordDescription(description);
>             token = descriptionInfo.token;
>             return token;
>           }
357,369c387,392
<                 case FILE_OVERVIEW:
<                   String fileOverview = "";
<                   if (jsdocBuilder.shouldParseDocumentation()) {
<                     ExtractionInfo fileOverviewInfo =
<                         extractMultilineTextualBlock(token,
<                             WhitespaceOption.TRIM);
< 
<                     fileOverview = fileOverviewInfo.string;
< 
<                     token = fileOverviewInfo.token;
<                   } else {
<                     token = eatTokensUntilEOL(token);
<                   }
---
>         case FILE_OVERVIEW:
>           String fileOverview = "";
>           if (jsdocBuilder.shouldParseDocumentation()) {
>             ExtractionInfo fileOverviewInfo =
>                 extractMultilineTextualBlock(token,
>                     WhitespaceOption.TRIM);
371,375c394
<                   if (!jsdocBuilder.recordFileOverview(fileOverview)) {
<                     parser.addParserWarning("msg.jsdoc.fileoverview.extra",
<                         stream.getLineno(), stream.getCharno());
<                   }
<                   continue retry;
---
>             fileOverview = fileOverviewInfo.string;
377,389c396,399
<                 case LICENSE:
<                 case PRESERVE:
<                   ExtractionInfo preserveInfo =
<                       extractMultilineTextualBlock(token,
<                                                    WhitespaceOption.PRESERVE);
< 
<                   String preserve = preserveInfo.string;
< 
<                   if (preserve.length() > 0) {
<                     if (fileLevelJsDocBuilder != null) {
<                       fileLevelJsDocBuilder.append(preserve);
<                     }
<                   }
---
>             token = fileOverviewInfo.token;
>           } else {
>             token = eatTokensUntilEOL(token);
>           }
391,392c401,405
<                   token = preserveInfo.token;
<                   continue retry;
---
>           if (!jsdocBuilder.recordFileOverview(fileOverview)) {
>             parser.addParserWarning("msg.jsdoc.fileoverview.extra",
>                 stream.getLineno(), stream.getCharno());
>           }
>           return token;
394,397c407,419
<                 case ENUM:
<                   token = next();
<                   lineno = stream.getLineno();
<                   charno = stream.getCharno();
---
>         case LICENSE:
>         case PRESERVE:
>           ExtractionInfo preserveInfo =
>               extractMultilineTextualBlock(token,
>                                            WhitespaceOption.PRESERVE);
> 
>           String preserve = preserveInfo.string;
> 
>           if (preserve.length() > 0) {
>             if (fileLevelJsDocBuilder != null) {
>               fileLevelJsDocBuilder.append(preserve);
>             }
>           }
399,403c421,422
<                   type = null;
<                   if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
<                     type = createJSTypeExpression(
<                         parseAndRecordTypeNode(token));
<                   }
---
>           token = preserveInfo.token;
>           return token;
405,413c424,427
<                   if (type == null) {
<                     type = createJSTypeExpression(newStringNode("number"));
<                   }
<                   if (!jsdocBuilder.recordEnumParameterType(type)) {
<                     parser.addTypeWarning(
<                         "msg.jsdoc.incompat.type", lineno, charno);
<                   }
<                   token = eatTokensUntilEOL(token);
<                   continue retry;
---
>         case ENUM:
>           token = next();
>           lineno = stream.getLineno();
>           charno = stream.getCharno();
415,421c429,433
<                 case EXPORT:
<                   if (!jsdocBuilder.recordExport()) {
<                     parser.addParserWarning("msg.jsdoc.export",
<                         stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>           type = null;
>           if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
>             type = createJSTypeExpression(
>                 parseAndRecordTypeNode(token));
>           }
423,429c435,443
<                 case EXPOSE:
<                   if (!jsdocBuilder.recordExpose()) {
<                     parser.addParserWarning("msg.jsdoc.expose",
<                         stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>           if (type == null) {
>             type = createJSTypeExpression(newStringNode("number"));
>           }
>           if (!jsdocBuilder.recordEnumParameterType(type)) {
>             parser.addTypeWarning(
>                 "msg.jsdoc.incompat.type", lineno, charno);
>           }
>           token = eatTokensUntilEOL(token);
>           return token;
431,437c445,450
<                 case EXTERNS:
<                   if (!jsdocBuilder.recordExterns()) {
<                     parser.addParserWarning("msg.jsdoc.externs",
<                         stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>         case EXPORT:
>           if (!jsdocBuilder.recordExport()) {
>             parser.addParserWarning("msg.jsdoc.export",
>                 stream.getLineno(), stream.getCharno());
>           }
>           return eatTokensUntilEOL();
439,445c452,457
<                 case JAVA_DISPATCH:
<                   if (!jsdocBuilder.recordJavaDispatch()) {
<                     parser.addParserWarning("msg.jsdoc.javadispatch",
<                         stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>         case EXPOSE:
>           if (!jsdocBuilder.recordExpose()) {
>             parser.addParserWarning("msg.jsdoc.expose",
>                 stream.getLineno(), stream.getCharno());
>           }
>           return eatTokensUntilEOL();
447,458c459,464
<                 case EXTENDS:
<                 case IMPLEMENTS:
<                   skipEOLs();
<                   token = next();
<                   lineno = stream.getLineno();
<                   charno = stream.getCharno();
<                   boolean matchingRc = false;
< 
<                   if (token == JsDocToken.LC) {
<                     token = next();
<                     matchingRc = true;
<                   }
---
>         case EXTERNS:
>           if (!jsdocBuilder.recordExterns()) {
>             parser.addParserWarning("msg.jsdoc.externs",
>                 stream.getLineno(), stream.getCharno());
>           }
>           return eatTokensUntilEOL();
460,497c466,471
<                   if (token == JsDocToken.STRING) {
<                     Node typeNode = parseAndRecordTypeNameNode(
<                         token, lineno, charno, matchingRc);
< 
<                     lineno = stream.getLineno();
<                     charno = stream.getCharno();
< 
<                     typeNode = wrapNode(Token.BANG, typeNode);
<                     type = createJSTypeExpression(typeNode);
< 
<                     if (annotation == Annotation.EXTENDS) {
<                       
<                       extendedTypes.add(new ExtendedTypeInfo(
<                           type, stream.getLineno(), stream.getCharno()));
<                     } else {
<                       Preconditions.checkState(
<                           annotation == Annotation.IMPLEMENTS);
<                       if (!jsdocBuilder.recordImplementedInterface(type)) {
<                         parser.addTypeWarning("msg.jsdoc.implements.duplicate",
<                             lineno, charno);
<                       }
<                     }
<                     token = next();
<                     if (matchingRc) {
<                       if (token != JsDocToken.RC) {
<                         parser.addTypeWarning("msg.jsdoc.missing.rc",
<                             stream.getLineno(), stream.getCharno());
<                       }
<                     } else if (token != JsDocToken.EOL &&
<                         token != JsDocToken.EOF && token != JsDocToken.EOC) {
<                       parser.addTypeWarning("msg.end.annotation.expected",
<                           stream.getLineno(), stream.getCharno());
<                     }
<                   } else {
<                     parser.addTypeWarning("msg.no.type.name", lineno, charno);
<                   }
<                   token = eatTokensUntilEOL(token);
<                   continue retry;
---
>         case JAVA_DISPATCH:
>           if (!jsdocBuilder.recordJavaDispatch()) {
>             parser.addParserWarning("msg.jsdoc.javadispatch",
>                 stream.getLineno(), stream.getCharno());
>           }
>           return eatTokensUntilEOL();
499,505c473,479
<                 case HIDDEN:
<                   if (!jsdocBuilder.recordHiddenness()) {
<                     parser.addParserWarning("msg.jsdoc.hidden",
<                         stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>         case EXTENDS:
>         case IMPLEMENTS:
>           skipEOLs();
>           token = next();
>           lineno = stream.getLineno();
>           charno = stream.getCharno();
>           boolean matchingRc = false;
507,508c481,484
<                 case LENDS:
<                   skipEOLs();
---
>           if (token == JsDocToken.LC) {
>             token = next();
>             matchingRc = true;
>           }
510,514c486,488
<                   matchingRc = false;
<                   if (match(JsDocToken.LC)) {
<                     token = next();
<                     matchingRc = true;
<                   }
---
>           if (token == JsDocToken.STRING) {
>             Node typeNode = parseAndRecordTypeNameNode(
>                 token, lineno, charno, matchingRc);
516,525c490,491
<                   if (match(JsDocToken.STRING)) {
<                     token = next();
<                     if (!jsdocBuilder.recordLends(stream.getString())) {
<                       parser.addTypeWarning("msg.jsdoc.lends.incompatible",
<                           stream.getLineno(), stream.getCharno());
<                     }
<                   } else {
<                     parser.addTypeWarning("msg.jsdoc.lends.missing",
<                         stream.getLineno(), stream.getCharno());
<                   }
---
>             lineno = stream.getLineno();
>             charno = stream.getCharno();
527,532c493,494
<                   if (matchingRc && !match(JsDocToken.RC)) {
<                     parser.addTypeWarning("msg.jsdoc.missing.rc",
<                         stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>             typeNode = wrapNode(Token.BANG, typeNode);
>             type = createJSTypeExpression(typeNode);
534,543c496,523
<                 case MEANING:
<                   ExtractionInfo meaningInfo =
<                       extractMultilineTextualBlock(token);
<                   String meaning = meaningInfo.string;
<                   token = meaningInfo.token;
<                   if (!jsdocBuilder.recordMeaning(meaning)) {
<                     parser.addParserWarning("msg.jsdoc.meaning.extra",
<                         stream.getLineno(), stream.getCharno());
<                   }
<                   continue retry;
---
>             if (annotation == Annotation.EXTENDS) {
>               
>               extendedTypes.add(new ExtendedTypeInfo(
>                   type, stream.getLineno(), stream.getCharno()));
>             } else {
>               Preconditions.checkState(
>                   annotation == Annotation.IMPLEMENTS);
>               if (!jsdocBuilder.recordImplementedInterface(type)) {
>                 parser.addTypeWarning("msg.jsdoc.implements.duplicate",
>                     lineno, charno);
>               }
>             }
>             token = next();
>             if (matchingRc) {
>               if (token != JsDocToken.RC) {
>                 parser.addTypeWarning("msg.jsdoc.missing.rc",
>                     stream.getLineno(), stream.getCharno());
>               }
>             } else if (token != JsDocToken.EOL &&
>                 token != JsDocToken.EOF && token != JsDocToken.EOC) {
>               parser.addTypeWarning("msg.end.annotation.expected",
>                   stream.getLineno(), stream.getCharno());
>             }
>           } else {
>             parser.addTypeWarning("msg.no.type.name", lineno, charno);
>           }
>           token = eatTokensUntilEOL(token);
>           return token;
545,551c525,530
<                 case NO_ALIAS:
<                   if (!jsdocBuilder.recordNoAlias()) {
<                     parser.addParserWarning("msg.jsdoc.noalias",
<                         stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>         case HIDDEN:
>           if (!jsdocBuilder.recordHiddenness()) {
>             parser.addParserWarning("msg.jsdoc.hidden",
>                 stream.getLineno(), stream.getCharno());
>           }
>           return eatTokensUntilEOL();
553,559c532,533
<                 case NO_COMPILE:
<                   if (!jsdocBuilder.recordNoCompile()) {
<                     parser.addParserWarning("msg.jsdoc.nocompile",
<                         stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>         case LENDS:
>           skipEOLs();
561,567c535,539
<                 case NO_TYPE_CHECK:
<                   if (!jsdocBuilder.recordNoTypeCheck()) {
<                     parser.addParserWarning("msg.jsdoc.nocheck",
<                         stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>           matchingRc = false;
>           if (match(JsDocToken.LC)) {
>             token = next();
>             matchingRc = true;
>           }
569,580c541,550
<                 case NOT_IMPLEMENTED:
<                   token = eatTokensUntilEOL();
<                   continue retry;
< 
<                 case INHERIT_DOC:
<                 case OVERRIDE:
<                   if (!jsdocBuilder.recordOverride()) {
<                     parser.addTypeWarning("msg.jsdoc.override",
<                         stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>           if (match(JsDocToken.STRING)) {
>             token = next();
>             if (!jsdocBuilder.recordLends(stream.getString())) {
>               parser.addTypeWarning("msg.jsdoc.lends.incompatible",
>                   stream.getLineno(), stream.getCharno());
>             }
>           } else {
>             parser.addTypeWarning("msg.jsdoc.lends.missing",
>                 stream.getLineno(), stream.getCharno());
>           }
582,599c552,556
<                 case THROWS:
<                   skipEOLs();
<                   token = next();
<                   lineno = stream.getLineno();
<                   charno = stream.getCharno();
<                   type = null;
< 
<                   if (token == JsDocToken.LC) {
<                     type = createJSTypeExpression(
<                         parseAndRecordTypeNode(token));
< 
<                     if (type == null) {
<                       
<                       
<                       token = eatTokensUntilEOL();
<                       continue retry;
<                     }
<                   }
---
>           if (matchingRc && !match(JsDocToken.RC)) {
>             parser.addTypeWarning("msg.jsdoc.missing.rc",
>                 stream.getLineno(), stream.getCharno());
>           }
>           return eatTokensUntilEOL();
601,602c558,567
<                   
<                   token = current();
---
>         case MEANING:
>           ExtractionInfo meaningInfo =
>               extractMultilineTextualBlock(token);
>           String meaning = meaningInfo.string;
>           token = meaningInfo.token;
>           if (!jsdocBuilder.recordMeaning(meaning)) {
>             parser.addParserWarning("msg.jsdoc.meaning.extra",
>                 stream.getLineno(), stream.getCharno());
>           }
>           return token;
604,605c569,574
<                   
<                   jsdocBuilder.recordThrowType(type);
---
>         case NO_ALIAS:
>           if (!jsdocBuilder.recordNoAlias()) {
>             parser.addParserWarning("msg.jsdoc.noalias",
>                 stream.getLineno(), stream.getCharno());
>           }
>           return eatTokensUntilEOL();
607,622c576,581
<                   
<                   if (jsdocBuilder.shouldParseDocumentation()) {
<                     ExtractionInfo descriptionInfo =
<                         extractMultilineTextualBlock(token);
< 
<                     String description = descriptionInfo.string;
< 
<                     if (description.length() > 0) {
<                       jsdocBuilder.recordThrowDescription(type, description);
<                     }
< 
<                     token = descriptionInfo.token;
<                   } else {
<                     token = eatTokensUntilEOL(token);
<                   }
<                   continue retry;
---
>         case NO_COMPILE:
>           if (!jsdocBuilder.recordNoCompile()) {
>             parser.addParserWarning("msg.jsdoc.nocompile",
>                 stream.getLineno(), stream.getCharno());
>           }
>           return eatTokensUntilEOL();
624,645c583,588
<                 case PARAM:
<                   skipEOLs();
<                   token = next();
<                   lineno = stream.getLineno();
<                   charno = stream.getCharno();
<                   type = null;
< 
<                   if (token == JsDocToken.LC) {
<                     type = createJSTypeExpression(
<                         parseAndRecordParamTypeNode(token));
< 
<                     if (type == null) {
<                       
<                       
<                       token = eatTokensUntilEOL();
<                       continue retry;
<                     }
<                     skipEOLs();
<                     token = next();
<                     lineno = stream.getLineno();
<                     charno = stream.getCharno();
<                   }
---
>         case NO_TYPE_CHECK:
>           if (!jsdocBuilder.recordNoTypeCheck()) {
>             parser.addParserWarning("msg.jsdoc.nocheck",
>                 stream.getLineno(), stream.getCharno());
>           }
>           return eatTokensUntilEOL();
647,651c590,591
<                   String name = null;
<                   boolean isBracketedParam = JsDocToken.LB == token;
<                   if (isBracketedParam) {
<                     token = next();
<                   }
---
>         case NOT_IMPLEMENTED:
>           return eatTokensUntilEOL();
653,695c593,599
<                   if (JsDocToken.STRING != token) {
<                     parser.addTypeWarning("msg.missing.variable.name",
<                         lineno, charno);
<                   } else {
<                     name = stream.getString();
< 
<                     if (isBracketedParam) {
<                       token = next();
< 
<                       
<                       
<                       
<                       if (JsDocToken.EQUALS == token) {
<                         token = next();
<                         if (JsDocToken.STRING == token) {
<                           token = next();
<                         }
<                       }
< 
<                       if (JsDocToken.RB != token) {
<                         reportTypeSyntaxWarning("msg.jsdoc.missing.rb");
<                       } else if (type != null) {
<                         
<                         
<                         type = JSTypeExpression.makeOptionalArg(type);
<                       }
<                     }
< 
<                     
<                     
<                     
<                     if (name.indexOf('.') > -1) {
<                       name = null;
<                     } else if (!jsdocBuilder.recordParameter(name, type)) {
<                       if (jsdocBuilder.hasParameter(name)) {
<                         parser.addTypeWarning("msg.dup.variable.name", name,
<                             lineno, charno);
<                       } else {
<                         parser.addTypeWarning("msg.jsdoc.incompat.type", name,
<                             lineno, charno);
<                       }
<                     }
<                   }
---
>         case INHERIT_DOC:
>         case OVERRIDE:
>           if (!jsdocBuilder.recordOverride()) {
>             parser.addTypeWarning("msg.jsdoc.override",
>                 stream.getLineno(), stream.getCharno());
>           }
>           return eatTokensUntilEOL();
697,700c601,610
<                   if (name == null) {
<                     token = eatTokensUntilEOL(token);
<                     continue retry;
<                   }
---
>         case THROWS:
>           skipEOLs();
>           token = next();
>           lineno = stream.getLineno();
>           charno = stream.getCharno();
>           type = null;
> 
>           if (token == JsDocToken.LC) {
>             type = createJSTypeExpression(
>                 parseAndRecordTypeNode(token));
702c612,617
<                   jsdocBuilder.markName(name, sourceFile, lineno, charno);
---
>             if (type == null) {
>               
>               
>               return eatTokensUntilEOL();
>             }
>           }
704,720c619,620
<                   
<                   if (jsdocBuilder.shouldParseDocumentation()) {
<                     ExtractionInfo paramDescriptionInfo =
<                         extractMultilineTextualBlock(token);
< 
<                     String paramDescription = paramDescriptionInfo.string;
< 
<                     if (paramDescription.length() > 0) {
<                       jsdocBuilder.recordParameterDescription(name,
<                           paramDescription);
<                     }
< 
<                     token = paramDescriptionInfo.token;
<                   } else {
<                     token = eatTokensUntilEOL(token);
<                   }
<                   continue retry;
---
>           
>           token = current();
722,728c622,623
<                 case PRESERVE_TRY:
<                   if (!jsdocBuilder.recordPreserveTry()) {
<                     parser.addParserWarning("msg.jsdoc.preservertry",
<                         stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>           
>           jsdocBuilder.recordThrowType(type);
730,736c625,628
<                 case NO_SHADOW:
<                   if (!jsdocBuilder.recordNoShadow()) {
<                     parser.addParserWarning("msg.jsdoc.noshadow",
<                         stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>           
>           if (jsdocBuilder.shouldParseDocumentation()) {
>             ExtractionInfo descriptionInfo =
>                 extractMultilineTextualBlock(token);
738,744c630
<                 case NO_SIDE_EFFECTS:
<                   if (!jsdocBuilder.recordNoSideEffects()) {
<                     parser.addParserWarning("msg.jsdoc.nosideeffects",
<                         stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>             String description = descriptionInfo.string;
746,756c632,634
<                 case MODIFIES:
<                   token = parseModifiesTag(next());
<                   continue retry;
< 
<                 case IMPLICIT_CAST:
<                   if (!jsdocBuilder.recordImplicitCast()) {
<                     parser.addTypeWarning("msg.jsdoc.implicitcast",
<                         stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>             if (description.length() > 0) {
>               jsdocBuilder.recordThrowDescription(type, description);
>             }
758,774c636,640
<                 case SEE:
<                   if (jsdocBuilder.shouldParseDocumentation()) {
<                     ExtractionInfo referenceInfo = extractSingleLineBlock();
<                     String reference = referenceInfo.string;
< 
<                     if (reference.length() == 0) {
<                       parser.addParserWarning("msg.jsdoc.seemissing",
<                           stream.getLineno(), stream.getCharno());
<                     } else {
<                       jsdocBuilder.addReference(reference);
<                     }
< 
<                     token = referenceInfo.token;
<                   } else {
<                     token = eatTokensUntilEOL(token);
<                   }
<                   continue retry;
---
>             token = descriptionInfo.token;
>           } else {
>             token = eatTokensUntilEOL(token);
>           }
>           return token;
776,782c642,651
<                 case STABLEIDGENERATOR:
<                   if (!jsdocBuilder.recordStableIdGenerator()) {
<                     parser.addParserWarning("msg.jsdoc.stableidgen",
<                       stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>         case PARAM:
>           skipEOLs();
>           token = next();
>           lineno = stream.getLineno();
>           charno = stream.getCharno();
>           type = null;
> 
>           if (token == JsDocToken.LC) {
>             type = createJSTypeExpression(
>                 parseAndRecordParamTypeNode(token));
784,801c653,662
<                 case SUPPRESS:
<                   token = parseSuppressTag(next());
<                   continue retry;
< 
<                 case TEMPLATE: {
<                   ExtractionInfo templateInfo = extractSingleLineBlock();
<                   List<String> names = Lists.newArrayList(
<                       Splitter.on(',')
<                           .trimResults()
<                           .split(templateInfo.string));
< 
<                   if (names.size() == 0 || names.get(0).length() == 0) {
<                     parser.addTypeWarning("msg.jsdoc.templatemissing",
<                           stream.getLineno(), stream.getCharno());
<                   } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
<                     parser.addTypeWarning("msg.jsdoc.template.at.most.once",
<                         stream.getLineno(), stream.getCharno());
<                   }
---
>             if (type == null) {
>               
>               
>               return eatTokensUntilEOL();
>             }
>             skipEOLs();
>             token = next();
>             lineno = stream.getLineno();
>             charno = stream.getCharno();
>           }
803,805c664,668
<                   token = templateInfo.token;
<                   continue retry;
<                 }
---
>           String name = null;
>           boolean isBracketedParam = JsDocToken.LB == token;
>           if (isBracketedParam) {
>             token = next();
>           }
807,822c670,674
<                 case CLASS_TEMPLATE: {
<                   ExtractionInfo classTemplateInfo = extractSingleLineBlock();
<                   List<String> names = Lists.newArrayList(
<                       Splitter.on(',')
<                           .trimResults()
<                           .split(classTemplateInfo.string));
< 
<                   if (names.size() == 0 || names.get(0).length() == 0) {
<                     parser.addTypeWarning(
<                         "msg.jsdoc.classtemplate.missing.type.name",
<                         stream.getLineno(), stream.getCharno());
<                   } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
<                     parser.addTypeWarning(
<                         "msg.jsdoc.classtemplate.at.most.once",
<                         stream.getLineno(), stream.getCharno());
<                   }
---
>           if (JsDocToken.STRING != token) {
>             parser.addTypeWarning("msg.missing.variable.name",
>                 lineno, charno);
>           } else {
>             name = stream.getString();
824,825c676,685
<                   token = classTemplateInfo.token;
<                   continue retry;
---
>             if (isBracketedParam) {
>               token = next();
> 
>               
>               
>               
>               if (JsDocToken.EQUALS == token) {
>                 token = next();
>                 if (JsDocToken.STRING == token) {
>                   token = next();
826a687
>               }
828,834c689,696
<                 case IDGENERATOR:
<                   if (!jsdocBuilder.recordIdGenerator()) {
<                     parser.addParserWarning("msg.jsdoc.idgen",
<                       stream.getLineno(), stream.getCharno());
<                   }
<                   token = eatTokensUntilEOL();
<                   continue retry;
---
>               if (JsDocToken.RB != token) {
>                 reportTypeSyntaxWarning("msg.jsdoc.missing.rb");
>               } else if (type != null) {
>                 
>                 
>                 type = JSTypeExpression.makeOptionalArg(type);
>               }
>             }
836,848c698,712
<                 case VERSION:
<                   ExtractionInfo versionInfo = extractSingleLineBlock();
<                   String version = versionInfo.string;
< 
<                   if (version.length() == 0) {
<                     parser.addParserWarning("msg.jsdoc.versionmissing",
<                           stream.getLineno(), stream.getCharno());
<                   } else {
<                     if (!jsdocBuilder.recordVersion(version)) {
<                        parser.addParserWarning("msg.jsdoc.extraversion",
<                           stream.getLineno(), stream.getCharno());
<                     }
<                   }
---
>             
>             
>             
>             if (name.indexOf('.') > -1) {
>               name = null;
>             } else if (!jsdocBuilder.recordParameter(name, type)) {
>               if (jsdocBuilder.hasParameter(name)) {
>                 parser.addTypeWarning("msg.dup.variable.name", name,
>                     lineno, charno);
>               } else {
>                 parser.addTypeWarning("msg.jsdoc.incompat.type", name,
>                     lineno, charno);
>               }
>             }
>           }
850,851c714,717
<                   token = versionInfo.token;
<                   continue retry;
---
>           if (name == null) {
>             token = eatTokensUntilEOL(token);
>             return token;
>           }
853,885c719
<                 case CONSTANT:
<                 case DEFINE:
<                 case RETURN:
<                 case PRIVATE:
<                 case PROTECTED:
<                 case PUBLIC:
<                 case THIS:
<                 case TYPE:
<                 case TYPEDEF:
<                   lineno = stream.getLineno();
<                   charno = stream.getCharno();
< 
<                   Node typeNode = null;
<                   boolean hasType = lookAheadForTypeAnnotation();
<                   boolean isAlternateTypeAnnotation =
<                       (annotation == Annotation.PRIVATE ||
<                        annotation == Annotation.PROTECTED ||
<                        annotation == Annotation.PUBLIC ||
<                        annotation == Annotation.CONSTANT);
<                   boolean canSkipTypeAnnotation =
<                       (isAlternateTypeAnnotation ||
<                        annotation == Annotation.RETURN);
<                   type = null;
<                   if (hasType || !canSkipTypeAnnotation) {
<                     skipEOLs();
<                     token = next();
<                     typeNode = parseAndRecordTypeNode(token);
< 
<                     if (annotation == Annotation.THIS) {
<                       typeNode = wrapNode(Token.BANG, typeNode);
<                     }
<                     type = createJSTypeExpression(typeNode);
<                   }
---
>           jsdocBuilder.markName(name, sourceFile, lineno, charno);
887,989c721,731
<                   
<                   
<                   boolean hasError = type == null && !canSkipTypeAnnotation;
<                   if (!hasError) {
<                     
<                     
<                     
<                     
<                     
<                     
<                     
<                     if ((type != null && isAlternateTypeAnnotation)
<                         || annotation == Annotation.TYPE) {
<                       if (!jsdocBuilder.recordType(type)) {
<                         parser.addTypeWarning(
<                             "msg.jsdoc.incompat.type", lineno, charno);
<                       }
<                     }
< 
<                     switch (annotation) {
<                       case CONSTANT:
<                         if (!jsdocBuilder.recordConstancy()) {
<                           parser.addParserWarning("msg.jsdoc.const",
<                               stream.getLineno(), stream.getCharno());
<                         }
<                         break;
< 
<                       case DEFINE:
<                         if (!jsdocBuilder.recordDefineType(type)) {
<                           parser.addParserWarning("msg.jsdoc.define",
<                               lineno, charno);
<                         }
<                         break;
< 
<                       case PRIVATE:
<                         if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
<                           parser.addParserWarning(
<                               "msg.jsdoc.visibility.private",
<                               lineno, charno);
<                         }
<                         break;
< 
<                       case PROTECTED:
<                         if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
<                           parser.addParserWarning(
<                               "msg.jsdoc.visibility.protected",
<                               lineno, charno);
<                         }
<                         break;
< 
<                       case PUBLIC:
<                         if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
<                           parser.addParserWarning(
<                               "msg.jsdoc.visibility.public",
<                               lineno, charno);
<                         }
<                         break;
< 
<                       case RETURN:
<                         if (type == null) {
<                           type = createJSTypeExpression(newNode(Token.QMARK));
<                         }
< 
<                         if (!jsdocBuilder.recordReturnType(type)) {
<                           parser.addTypeWarning(
<                               "msg.jsdoc.incompat.type", lineno, charno);
<                           break;
<                         }
< 
<                         
<                         if (jsdocBuilder.shouldParseDocumentation()) {
<                           ExtractionInfo returnDescriptionInfo =
<                               extractMultilineTextualBlock(token);
< 
<                           String returnDescription =
<                               returnDescriptionInfo.string;
< 
<                           if (returnDescription.length() > 0) {
<                             jsdocBuilder.recordReturnDescription(
<                                 returnDescription);
<                           }
< 
<                           token = returnDescriptionInfo.token;
<                         } else {
<                           token = eatTokensUntilEOL(token);
<                         }
<                         continue retry;
< 
<                       case THIS:
<                         if (!jsdocBuilder.recordThisType(type)) {
<                           parser.addTypeWarning(
<                               "msg.jsdoc.incompat.type", lineno, charno);
<                         }
<                         break;
< 
<                       case TYPEDEF:
<                         if (!jsdocBuilder.recordTypedef(type)) {
<                           parser.addTypeWarning(
<                               "msg.jsdoc.incompat.type", lineno, charno);
<                         }
<                         break;
<                     }
<                   }
---
>           
>           if (jsdocBuilder.shouldParseDocumentation()) {
>             ExtractionInfo paramDescriptionInfo =
>                 extractMultilineTextualBlock(token);
> 
>             String paramDescription = paramDescriptionInfo.string;
> 
>             if (paramDescription.length() > 0) {
>               jsdocBuilder.recordParameterDescription(name,
>                   paramDescription);
>             }
991,993c733,780
<                   token = eatTokensUntilEOL();
<                   continue retry;
<               }
---
>             token = paramDescriptionInfo.token;
>           } else {
>             token = eatTokensUntilEOL(token);
>           }
>           return token;
> 
>         case PRESERVE_TRY:
>           if (!jsdocBuilder.recordPreserveTry()) {
>             parser.addParserWarning("msg.jsdoc.preservertry",
>                 stream.getLineno(), stream.getCharno());
>           }
>           return eatTokensUntilEOL();
> 
>         case NO_SHADOW:
>           if (!jsdocBuilder.recordNoShadow()) {
>             parser.addParserWarning("msg.jsdoc.noshadow",
>                 stream.getLineno(), stream.getCharno());
>           }
>           return eatTokensUntilEOL();
> 
>         case NO_SIDE_EFFECTS:
>           if (!jsdocBuilder.recordNoSideEffects()) {
>             parser.addParserWarning("msg.jsdoc.nosideeffects",
>                 stream.getLineno(), stream.getCharno());
>           }
>           return eatTokensUntilEOL();
> 
>         case MODIFIES:
>           token = parseModifiesTag(next());
>           return token;
> 
>         case IMPLICIT_CAST:
>           if (!jsdocBuilder.recordImplicitCast()) {
>             parser.addTypeWarning("msg.jsdoc.implicitcast",
>                 stream.getLineno(), stream.getCharno());
>           }
>           return eatTokensUntilEOL();
> 
>         case SEE:
>           if (jsdocBuilder.shouldParseDocumentation()) {
>             ExtractionInfo referenceInfo = extractSingleLineBlock();
>             String reference = referenceInfo.string;
> 
>             if (reference.length() == 0) {
>               parser.addParserWarning("msg.jsdoc.seemissing",
>                   stream.getLineno(), stream.getCharno());
>             } else {
>               jsdocBuilder.addReference(reference);
994a782,785
> 
>             token = referenceInfo.token;
>           } else {
>             token = eatTokensUntilEOL(token);
996c787
<           break;
---
>           return token;
998,1000c789,792
<         case EOC:
<           if (hasParsedFileOverviewDocInfo()) {
<             fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
---
>         case STABLEIDGENERATOR:
>           if (!jsdocBuilder.recordStableIdGenerator()) {
>             parser.addParserWarning("msg.jsdoc.stableidgen",
>               stream.getLineno(), stream.getCharno());
1002,1003c794
<           checkExtendedTypes(extendedTypes);
<           return true;
---
>           return eatTokensUntilEOL();
1005,1008c796,842
<         case EOF:
<           
<           jsdocBuilder.build(null);
<           parser.addParserWarning("msg.unexpected.eof",
---
>         case SUPPRESS:
>           token = parseSuppressTag(next());
>           return token;
> 
>         case TEMPLATE: {
>           ExtractionInfo templateInfo = extractSingleLineBlock();
>           List<String> names = Lists.newArrayList(
>               Splitter.on(',')
>                   .trimResults()
>                   .split(templateInfo.string));
> 
>           if (names.size() == 0 || names.get(0).length() == 0) {
>             parser.addTypeWarning("msg.jsdoc.templatemissing",
>                   stream.getLineno(), stream.getCharno());
>           } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
>             parser.addTypeWarning("msg.jsdoc.template.at.most.once",
>                 stream.getLineno(), stream.getCharno());
>           }
> 
>           token = templateInfo.token;
>           return token;
>         }
> 
>         case CLASS_TEMPLATE: {
>           ExtractionInfo classTemplateInfo = extractSingleLineBlock();
>           List<String> names = Lists.newArrayList(
>               Splitter.on(',')
>                   .trimResults()
>                   .split(classTemplateInfo.string));
> 
>           if (names.size() == 0 || names.get(0).length() == 0) {
>             parser.addTypeWarning(
>                 "msg.jsdoc.classtemplate.missing.type.name",
>                 stream.getLineno(), stream.getCharno());
>           } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
>             parser.addTypeWarning(
>                 "msg.jsdoc.classtemplate.at.most.once",
>                 stream.getLineno(), stream.getCharno());
>           }
> 
>           token = classTemplateInfo.token;
>           return token;
>         }
> 
>         case IDGENERATOR:
>           if (!jsdocBuilder.recordIdGenerator()) {
>             parser.addParserWarning("msg.jsdoc.idgen",
1010,1011c844,845
<           checkExtendedTypes(extendedTypes);
<           return false;
---
>           }
>           return eatTokensUntilEOL();
1013,1015c847,858
<         case EOL:
<           if (state == State.SEARCHING_NEWLINE) {
<             state = State.SEARCHING_ANNOTATION;
---
>         case VERSION:
>           ExtractionInfo versionInfo = extractSingleLineBlock();
>           String version = versionInfo.string;
> 
>           if (version.length() == 0) {
>             parser.addParserWarning("msg.jsdoc.versionmissing",
>                   stream.getLineno(), stream.getCharno());
>           } else {
>             if (!jsdocBuilder.recordVersion(version)) {
>                parser.addParserWarning("msg.jsdoc.extraversion",
>                   stream.getLineno(), stream.getCharno());
>             }
1017,1018d859
<           token = next();
<           continue retry;
1020,1021c861,888
<         default:
<           if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
---
>           token = versionInfo.token;
>           return token;
> 
>         case CONSTANT:
>         case DEFINE:
>         case RETURN:
>         case PRIVATE:
>         case PROTECTED:
>         case PUBLIC:
>         case THIS:
>         case TYPE:
>         case TYPEDEF:
>           lineno = stream.getLineno();
>           charno = stream.getCharno();
> 
>           Node typeNode = null;
>           boolean hasType = lookAheadForTypeAnnotation();
>           boolean isAlternateTypeAnnotation =
>               (annotation == Annotation.PRIVATE ||
>                annotation == Annotation.PROTECTED ||
>                annotation == Annotation.PUBLIC ||
>                annotation == Annotation.CONSTANT);
>           boolean canSkipTypeAnnotation =
>               (isAlternateTypeAnnotation ||
>                annotation == Annotation.RETURN);
>           type = null;
>           if (hasType || !canSkipTypeAnnotation) {
>             skipEOLs();
1023,1027c890,895
<             continue retry;
<           } else {
<             state = State.SEARCHING_NEWLINE;
<             token = eatTokensUntilEOL();
<             continue retry;
---
>             typeNode = parseAndRecordTypeNode(token);
> 
>             if (annotation == Annotation.THIS) {
>               typeNode = wrapNode(Token.BANG, typeNode);
>             }
>             type = createJSTypeExpression(typeNode);
1029d896
<       }
1031,1032c898,1003
<       
<       token = next();
---
>           
>           
>           boolean hasError = type == null && !canSkipTypeAnnotation;
>           if (!hasError) {
>             
>             
>             
>             
>             
>             
>             
>             if ((type != null && isAlternateTypeAnnotation)
>                 || annotation == Annotation.TYPE) {
>               if (!jsdocBuilder.recordType(type)) {
>                 parser.addTypeWarning(
>                     "msg.jsdoc.incompat.type", lineno, charno);
>               }
>             }
> 
>             switch (annotation) {
>               case CONSTANT:
>                 if (!jsdocBuilder.recordConstancy()) {
>                   parser.addParserWarning("msg.jsdoc.const",
>                       stream.getLineno(), stream.getCharno());
>                 }
>                 break;
> 
>               case DEFINE:
>                 if (!jsdocBuilder.recordDefineType(type)) {
>                   parser.addParserWarning("msg.jsdoc.define",
>                       lineno, charno);
>                 }
>                 break;
> 
>               case PRIVATE:
>                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
>                   parser.addParserWarning(
>                       "msg.jsdoc.visibility.private",
>                       lineno, charno);
>                 }
>                 break;
> 
>               case PROTECTED:
>                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
>                   parser.addParserWarning(
>                       "msg.jsdoc.visibility.protected",
>                       lineno, charno);
>                 }
>                 break;
> 
>               case PUBLIC:
>                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
>                   parser.addParserWarning(
>                       "msg.jsdoc.visibility.public",
>                       lineno, charno);
>                 }
>                 break;
> 
>               case RETURN:
>                 if (type == null) {
>                   type = createJSTypeExpression(newNode(Token.QMARK));
>                 }
> 
>                 if (!jsdocBuilder.recordReturnType(type)) {
>                   parser.addTypeWarning(
>                       "msg.jsdoc.incompat.type", lineno, charno);
>                   break;
>                 }
> 
>                 
>                 if (jsdocBuilder.shouldParseDocumentation()) {
>                   ExtractionInfo returnDescriptionInfo =
>                       extractMultilineTextualBlock(token);
> 
>                   String returnDescription =
>                       returnDescriptionInfo.string;
> 
>                   if (returnDescription.length() > 0) {
>                     jsdocBuilder.recordReturnDescription(
>                         returnDescription);
>                   }
> 
>                   token = returnDescriptionInfo.token;
>                 } else {
>                   token = eatTokensUntilEOL(token);
>                 }
>                 return token;
> 
>               case THIS:
>                 if (!jsdocBuilder.recordThisType(type)) {
>                   parser.addTypeWarning(
>                       "msg.jsdoc.incompat.type", lineno, charno);
>                 }
>                 break;
> 
>               case TYPEDEF:
>                 if (!jsdocBuilder.recordTypedef(type)) {
>                   parser.addTypeWarning(
>                       "msg.jsdoc.incompat.type", lineno, charno);
>                 }
>                 break;
>             }
>           }
> 
>           return eatTokensUntilEOL();
>       }
1034c1005,1006
<   }
---
>     return next();
>   };
