1a2,576
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> package com.google.javascript.jscomp;
> 
> import static com.google.javascript.jscomp.TypeCheck.BAD_IMPLEMENTED_TYPE;
> import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE;
> import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;
> 
> import javax.annotation.Nullable;
> import com.google.common.base.Preconditions;
> import com.google.common.collect.ImmutableList;
> import com.google.common.collect.Lists;
> import com.google.common.collect.Sets;
> import com.google.javascript.rhino.JSDocInfo;
> import com.google.javascript.rhino.JSTypeExpression;
> import com.google.javascript.rhino.Node;
> import com.google.javascript.rhino.jstype.FunctionParamBuilder;
> import com.google.javascript.rhino.jstype.FunctionType;
> import com.google.javascript.rhino.jstype.InstanceObjectType;
> import com.google.javascript.rhino.jstype.JSType;
> import com.google.javascript.rhino.jstype.JSTypeRegistry;
> import com.google.javascript.rhino.jstype.ObjectType;
> 
> import java.util.Iterator;
> import java.util.List;
> import java.util.Set;
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> final class FunctionTypeBuilder {
> 
>   private final String fnName;
>   private final AbstractCompiler compiler;
>   private final CodingConvention codingConvention;
>   private final JSTypeRegistry typeRegistry;
>   private final Node errorRoot;
>   private final String sourceName;
>   private final Scope scope;
> 
>   private JSType returnType = null;
>   private List<ObjectType> implementedInterfaces = null;
>   private ObjectType baseType = null;
>   private ObjectType thisType = null;
>   private boolean isConstructor = false;
>   private boolean isInterface = false;
>   private Node parametersNode = null;
>   private Node sourceNode = null;
>   private String templateTypeName = null;
> 
>   static final DiagnosticType EXTENDS_WITHOUT_TYPEDEF = DiagnosticType.warning(
>       "JSC_EXTENDS_WITHOUT_TYPEDEF",
>       "@extends used without @constructor or @interface for {0}");
> 
>   static final DiagnosticType EXTENDS_NON_OBJECT = DiagnosticType.warning(
>       "JSC_EXTENDS_NON_OBJECT",
>       "{0} @extends non-object type {1}");
> 
>   static final DiagnosticType IMPLEMENTS_WITHOUT_CONSTRUCTOR =
>       DiagnosticType.warning(
>           "JSC_IMPLEMENTS_WITHOUT_CONSTRUCTOR",
>           "@implements used without @constructor or @interface for {0}");
> 
>   static final DiagnosticType VAR_ARGS_MUST_BE_LAST = DiagnosticType.warning(
>       "JSC_VAR_ARGS_MUST_BE_LAST",
>       "variable length argument must be last");
> 
>   static final DiagnosticType OPTIONAL_ARG_AT_END = DiagnosticType.warning(
>       "JSC_OPTIONAL_ARG_AT_END",
>       "optional arguments must be at the end");
> 
>   static final DiagnosticType INEXISTANT_PARAM = DiagnosticType.warning(
>       "JSC_INEXISTANT_PARAM",
>       "parameter {0} does not appear in {1}''s parameter list");
> 
>   static final DiagnosticType TYPE_REDEFINITION = DiagnosticType.warning(
>       "JSC_TYPE_REDEFINITION",
>       "attempted re-definition of type {0}\n"
>       + "found   : {1}\n"
>       + "expected: {2}");
> 
>   static final DiagnosticType TEMPLATE_TYPE_DUPLICATED = DiagnosticType.error(
>       "JSC_TEMPLATE_TYPE_DUPLICATED",
>       "Only one parameter type must be the template type");
> 
>   static final DiagnosticType TEMPLATE_TYPE_EXPECTED = DiagnosticType.error(
>       "JSC_TEMPLATE_TYPE_EXPECTED",
>       "The template type must be a parameter type");
> 
>   
> 
> 
> 
> 
> 
> 
> 
> 
>   FunctionTypeBuilder(String fnName, AbstractCompiler compiler,
>       Node errorRoot, String sourceName, Scope scope) {
>     Preconditions.checkNotNull(errorRoot);
> 
>     this.fnName = fnName == null ? "" : fnName;
>     this.codingConvention = compiler.getCodingConvention();
>     this.typeRegistry = compiler.getTypeRegistry();
>     this.errorRoot = errorRoot;
>     this.sourceName = sourceName;
>     this.compiler = compiler;
>     this.scope = scope;
>   }
> 
>   
> 
> 
>   FunctionTypeBuilder setSourceNode(@Nullable Node sourceNode) {
>     this.sourceNode = sourceNode;
>     return this;
>   }
> 
>   
> 
> 
> 
> 
> 
> 
> 
> 
>   FunctionTypeBuilder inferFromOverriddenFunction(
>       FunctionType oldType, @Nullable Node paramsParent) {
>     returnType = oldType.getReturnType();
>     if (paramsParent == null) {
>       
>       parametersNode = oldType.getParametersNode();
>       if (parametersNode == null) {
>         parametersNode = new FunctionParamBuilder(typeRegistry).build();
>       }
>     } else {
>       
>       
>       FunctionParamBuilder paramBuilder =
>           new FunctionParamBuilder(typeRegistry);
>       Iterator<Node> oldParams = oldType.getParameters().iterator();
>       boolean warnedAboutArgList = false;
>       for (Node currentParam = paramsParent.getFirstChild();
>            currentParam != null; currentParam = currentParam.getNext()) {
>         if (oldParams.hasNext()) {
>           paramBuilder.newParameterFromNode(oldParams.next());
>         } else {
>           String name = currentParam.getString();
>           warnedAboutArgList |= addParameter(
>               paramBuilder,
>               typeRegistry.getNativeType(UNKNOWN_TYPE),
>               warnedAboutArgList,
>               codingConvention.isOptionalParameter(name),
>               codingConvention.isVarArgsParameter(currentParam, name));
>         }
>       }
>       parametersNode = paramBuilder.build();
>     }
>     return this;
>   }
> 
>   
> 
> 
>   FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {
>     returnType = info != null && info.hasReturnType() ?
>         info.getReturnType().evaluate(scope) :
>         typeRegistry.getNativeType(UNKNOWN_TYPE);
>     if (templateTypeName != null &&
>         returnType.restrictByNotNullOrUndefined().isTemplateType()) {
>       reportError(TEMPLATE_TYPE_EXPECTED, fnName);
>     }
>     return this;
>   }
> 
>   
> 
> 
> 
>   FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {
>     if (info != null) {
>       isConstructor = info.isConstructor();
>       isInterface = info.isInterface();
> 
>       
>       if (info.hasBaseType()) {
>         if (isConstructor || isInterface) {
>           JSType maybeBaseType = info.getBaseType().evaluate(scope);
>           if (maybeBaseType instanceof ObjectType) {
>             baseType = (ObjectType) maybeBaseType;
>           } else {
>             reportWarning(EXTENDS_NON_OBJECT,
>                 fnName, maybeBaseType.toString());
>           }
>         } else {
>           reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);
>         }
>       }
> 
>       
>       if (isConstructor || isInterface) {
>         implementedInterfaces = Lists.newArrayList();
>         for (JSTypeExpression t : info.getImplementedInterfaces()) {
>           JSType interType = t.evaluate(scope);
>           if (interType instanceof ObjectType) {
>             implementedInterfaces.add((ObjectType) interType);
>           } else {
>             reportError(BAD_IMPLEMENTED_TYPE, fnName);
>           }
>         }
>         if (baseType != null) {
>           JSType maybeFunctionType = baseType.getConstructor();
>           if (maybeFunctionType instanceof FunctionType) {
>             FunctionType functionType = baseType.getConstructor();
>             implementedInterfaces.addAll(
>                 functionType.getImplementedInterfaces());
>           }
>         }
>       } else if (info.getImplementedInterfaceCount() > 0) {
>         reportWarning(IMPLEMENTS_WITHOUT_CONSTRUCTOR, fnName);
>       }
>     }
> 
>     return this;
>   }
> 
>   
> 
> 
> 
>   FunctionTypeBuilder inferThisType(JSDocInfo info, JSType type) {
>     if (type instanceof ObjectType &&
>         (info == null || !info.hasType())) {
>       thisType = (ObjectType) type;
>     }
>     return this;
>   }
> 
>   
> 
> 
> 
> 
> 
> 
>   FunctionTypeBuilder inferThisType(JSDocInfo info,
>       @Nullable Node owner) {
>     JSType maybeThisType = null;
>     if (info != null && info.hasThisType()) {
>       maybeThisType = info.getThisType().evaluate(scope);
>     }
>     if (maybeThisType != null && maybeThisType instanceof ObjectType) {
>       
>       
>       
>       
>       
>       
>       thisType = (ObjectType) maybeThisType;
>     } else if (owner != null &&
>                (info == null || !info.hasType())) {
>       
>       
>       
>       
>       
>       
>       String ownerTypeName = owner.getQualifiedName();
>       JSType ownerType = typeRegistry.getType(
>           scope, ownerTypeName, sourceName,
>           owner.getLineno(), owner.getCharno());
>       if (ownerType instanceof ObjectType) {
>         thisType = (ObjectType) ownerType;
>       }
>     }
> 
>     return this;
>   }
> 
>   
> 
> 
>   FunctionTypeBuilder inferParameterTypes(Node argsParent,
>       @Nullable JSDocInfo info) {
>     if (argsParent == null) {
>       return inferParameterTypes(info);
>     }
> 
>     List<String> argsList = ImmutableList.of();
>     if (argsParent.getFirstChild() != null) {
>       argsList = Lists.newArrayList();
>       for (Node n : argsParent.children()) {
>         argsList.add(n.getString());
>       }
>     }
> 
>     return inferParameterTypes(argsList, info);
>   }
> 
>   
> 
> 
>   FunctionTypeBuilder inferParameterTypes(JSDocInfo info) {
>     return inferParameterTypes(info.getParameterNames(), info);
>   }
> 
>   
> 
> 
> 
>   private FunctionTypeBuilder inferParameterTypes(Iterable<String> argList,
>       @Nullable JSDocInfo info) {
>     
>     FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);
>     boolean warnedAboutArgList = false;
>     Set<String> allJsDocParams = (info == null) ?
>         Sets.<String>newHashSet() :
>         Sets.newHashSet(info.getParameterNames());
>     boolean foundTemplateType = false;
>     for (String argumentName : argList) {
>       allJsDocParams.remove(argumentName);
> 
>       
>       JSType parameterType =
>           info != null && info.hasParameterType(argumentName) ?
>           info.getParameterType(argumentName).evaluate(scope) :
>           typeRegistry.getNativeType(UNKNOWN_TYPE);
>       if (templateTypeName != null &&
>           parameterType.restrictByNotNullOrUndefined().isTemplateType()) {
>         if (foundTemplateType) {
>           reportError(TEMPLATE_TYPE_DUPLICATED, fnName);
>         }
>         foundTemplateType = true;
>       }
>       warnedAboutArgList |= addParameter(
>           builder, parameterType, warnedAboutArgList,
>           isOptionalParameter(argumentName, info),
>           isVarArgsParameter(argumentName, info));
>     }
> 
>     if (templateTypeName != null && !foundTemplateType) {
>       reportError(TEMPLATE_TYPE_EXPECTED, fnName);
>     }
> 
>     for (String inexistentName : allJsDocParams) {
>       if (!isVarArgsParameter(inexistentName, info)) {
>         reportWarning(INEXISTANT_PARAM, inexistentName, fnName);
>       }
>     }
> 
>     parametersNode = builder.build();
>     return this;
>   }
> 
>   
> 
> 
>   private boolean isOptionalParameter(
>       String paramName, @Nullable JSDocInfo info) {
>     if (codingConvention.isOptionalParameter(paramName)) {
>       return true;
>     }
> 
>     return info != null && info.hasParameterType(paramName) &&
>         info.getParameterType(paramName).isOptionalArg();
>   }
> 
>   
> 
> 
> 
> 
> 
>   private boolean isVarArgsParameter(
>       String paramName, @Nullable JSDocInfo info) {
>     if (codingConvention.isVarArgsParameter(null, paramName)) {
>       return true;
>     }
> 
>     return info != null && info.hasParameterType(paramName) &&
>         info.getParameterType(paramName).isVarArgs();
>   }
> 
>   
> 
> 
>   FunctionTypeBuilder inferTemplateTypeName(@Nullable JSDocInfo info) {
>     if (info != null) {
>       templateTypeName = info.getTemplateTypeName();
>       typeRegistry.setTemplateTypeName(templateTypeName);
>     }
>     return this;
>   }
> 
>   
> 
> 
> 
> 
> 
> 
> 
> 
> 
>   private boolean addParameter(FunctionParamBuilder builder,
>       JSType paramType, boolean warnedAboutArgList,
>       boolean isOptional, boolean isVarArgs) {
>     boolean emittedWarning = false;
>     if (isOptional) {
>       
>       
>       
>       if (!builder.addOptionalParams(paramType) && !warnedAboutArgList) {
>         reportWarning(VAR_ARGS_MUST_BE_LAST);
>         emittedWarning = true;
>       }
>     } else if (isVarArgs) {
>       if (!builder.addVarArgs(paramType) && !warnedAboutArgList) {
>         reportWarning(VAR_ARGS_MUST_BE_LAST);
>         emittedWarning = true;
>       }
>     } else {
>       if (!builder.addRequiredParams(paramType) && !warnedAboutArgList) {
>         
>         
>         if (builder.hasVarArgs()) {
>           reportWarning(VAR_ARGS_MUST_BE_LAST);
>         } else {
>           reportWarning(OPTIONAL_ARG_AT_END);
>         }
>         emittedWarning = true;
>       }
>     }
>     return emittedWarning;
>   }
> 
>   
> 
> 
>   FunctionType buildAndRegister() {
>     if (returnType == null || parametersNode == null) {
>       throw new IllegalStateException(
>           "All Function types must have params and a return type");
>     }
> 
>     FunctionType fnType;
>     if (isConstructor) {
>       fnType = getOrCreateConstructor();
>     } else if (isInterface) {
>       fnType = typeRegistry.createInterfaceType(fnName, sourceNode);
>       if (scope.isGlobal() && !fnName.isEmpty()) {
>         typeRegistry.declareType(fnName, fnType.getInstanceType());
>       }
>       maybeSetBaseType(fnType);
>     } else {
>       fnType = new FunctionType(typeRegistry, fnName, sourceNode,
>           parametersNode, returnType, thisType, templateTypeName);
>       maybeSetBaseType(fnType);
>     }
> 
>     if (implementedInterfaces != null) {
>       fnType.setImplementedInterfaces(implementedInterfaces);
>     }
> 
>     typeRegistry.clearTemplateTypeName();
> 
>     return fnType;
>   }
> 
>   private void maybeSetBaseType(FunctionType fnType) {
>     if (baseType != null) {
>       fnType.setPrototypeBasedOn(baseType);
>     }
>   }
> 
>   
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>   private FunctionType getOrCreateConstructor() {
>     FunctionType fnType = typeRegistry.createConstructorType(
>         fnName, sourceNode, parametersNode, returnType);
>     JSType existingType = typeRegistry.getType(fnName);
> 
>     if (existingType != null) {
>       boolean isInstanceObject = existingType instanceof InstanceObjectType;
>       if (isInstanceObject || fnName.equals("Function")) {
>         FunctionType existingFn =
>             isInstanceObject ?
>             ((InstanceObjectType) existingType).getConstructor() :
>             typeRegistry.getNativeFunctionType(FUNCTION_FUNCTION_TYPE);
> 
>         if (existingFn.getSource() == null) {
>           existingFn.setSource(sourceNode);
>         }
> 
>         if (!existingFn.hasEqualCallType(fnType)) {
>           reportWarning(TYPE_REDEFINITION, fnName,
>               fnType.toString(), existingFn.toString());
>         }
> 
>         return existingFn;
>       } else {
>         
>         
>         
>       }
>     }
> 
>     maybeSetBaseType(fnType);
> 
>     if (scope.isGlobal() && !fnName.isEmpty()) {
>       typeRegistry.declareType(fnName, fnType.getInstanceType());
>     }
>     return fnType;
>   }
> 
>   private void reportWarning(DiagnosticType warning, String ... args) {
>     compiler.report(JSError.make(sourceName, errorRoot, warning, args));
>   }
> 
>   private void reportError(DiagnosticType error, String ... args) {
>     compiler.report(JSError.make(sourceName, errorRoot, error, args));
>   }
> 
>   
> 
> 
>   static boolean isFunctionTypeDeclaration(JSDocInfo info) {
>     return info.getParameterCount() > 0 ||
>         info.hasReturnType() ||
>         info.hasThisType() ||
>         info.isConstructor() ||
>         info.isInterface();
>   }
> }
