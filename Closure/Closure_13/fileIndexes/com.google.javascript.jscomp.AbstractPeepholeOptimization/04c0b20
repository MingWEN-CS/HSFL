















package com.google.javascript.jscomp;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.javascript.rhino.Node;







abstract class AbstractPeepholeOptimization {

  private AbstractCompiler compiler;

  








  abstract Node optimizeSubtree(Node subtree);

  






  protected void error(DiagnosticType diagnostic, Node n) {
    JSError error =
        JSError.make(NodeUtil.getSourceName(n), n, diagnostic, n.toString());
    compiler.report(error);
  }

  



  protected void reportCodeChange() {
    Preconditions.checkNotNull(compiler);
    compiler.reportCodeChange();
  }

  



  protected boolean areNodesEqualForInlining(Node n1, Node n2) {
    


    Preconditions.checkNotNull(compiler);
    return compiler.areNodesEqualForInlining(n1, n2);
  }

  



  protected boolean isASTNormalized() {
    Preconditions.checkNotNull(compiler);

    return compiler.getLifeCycleStage().isNormalized();
  }

  


  void beginTraversal(AbstractCompiler compiler) {
    this.compiler = compiler;
  }

  


  void endTraversal(AbstractCompiler compiler) {
    this.compiler = null;
  }

  
  

  



  boolean mayEffectMutableState(Node n) {
    return NodeUtil.mayEffectMutableState(n, compiler);
  }

  


  boolean mayHaveSideEffects(Node n) {
    return NodeUtil.mayHaveSideEffects(n, compiler);
  }

  




  boolean isEcmaScript5OrGreater() {
    return compiler != null
        && compiler.acceptEcmaScript5();
  }

  


  CodingConvention getCodingConvention() {
    
    return compiler.getCodingConvention();
  }

  


  @VisibleForTesting
  static Node validateResult(Node n) {
    done: {
      if (n != null && !n.isScript()
          && (!n.isBlock() || !n.isSyntheticBlock())) {
        for (Node parent : n.getAncestors()) {
          if (parent.isScript()) {
            break done;
          }
        }
        Preconditions.checkState(false);
      }
    }
    return n;
  }
}
