














package com.google.javascript.jscomp;

import com.google.common.base.Preconditions;
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;


















class CollapseAnonymousFunctions implements CompilerPass {
  private final AbstractCompiler compiler;

  public CollapseAnonymousFunctions(AbstractCompiler compiler) {
    Preconditions.checkArgument(compiler.isNormalized());
    this.compiler = compiler;
  }

  @Override
  public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, root, new Callback());
  }

  private class Callback extends AbstractPostOrderCallback {
    @Override
    public void visit(NodeTraversal t, Node n, Node parent) {
      if (n.getType() != Token.VAR) {
        return;
      }

      
      
      
      
      

      Node grandparent = parent.getParent();
      if (!(parent.getType() == Token.SCRIPT ||
            grandparent != null &&
            grandparent.getType() == Token.FUNCTION &&
            parent.getType() == Token.BLOCK)) {
        return;
      }

      
      
      Preconditions.checkState(n.hasOneChild());
      Node name = n.getFirstChild();
      Node value = name.getFirstChild();
      if (value != null &&
          value.getType() == Token.FUNCTION &&
          !isRecursiveFunction(value)) {
        Node fnName = value.getFirstChild();
        fnName.setString(name.getString());
        NodeUtil.copyNameAnnotations(name, fnName);
        name.removeChild(value);
        parent.replaceChild(n, value);
        compiler.reportCodeChange();
      }
    }

    private boolean isRecursiveFunction(Node function) {
      Node name = function.getFirstChild();
      if (name.getString().isEmpty()) {
        return false;
      }
      Node args = name.getNext();
      Node body = args.getNext();
      return containsName(body, name.getString());
    }

    private boolean containsName(Node n, String name) {
      if (n.getType() == Token.NAME && n.getString().equals(name)) {
        return true;
      }

      for (Node child : n.children()) {
        if (containsName(child, name)) {
          return true;
        }
      }
      return false;
    }
  }
}
