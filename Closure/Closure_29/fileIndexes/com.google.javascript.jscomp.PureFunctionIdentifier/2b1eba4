















package com.google.javascript.jscomp;

import com.google.common.base.Charsets;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.google.common.io.Files;
import com.google.javascript.jscomp.DefinitionsRemover.Definition;
import com.google.javascript.jscomp.FunctionSideEffectData.CallValueEntry;
import com.google.javascript.jscomp.FunctionSideEffectData.KeywordValueEntry;
import com.google.javascript.jscomp.FunctionSideEffectData.ValueEntry;
import com.google.javascript.jscomp.FunctionSideEffectData.NameValueEntry;
import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;
import com.google.javascript.jscomp.Scope.Var;
import com.google.javascript.jscomp.graph.DiGraph;
import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;
import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;
import com.google.javascript.jscomp.graph.LinkedDirectedGraph;
import com.google.javascript.rhino.JSDocInfo;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;
import com.google.javascript.rhino.jstype.FunctionType;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;

import java.io.File;
import java.io.IOException;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
















class PureFunctionIdentifier implements CompilerPass {
  static final DiagnosticType INVALID_NO_SIDE_EFFECT_ANNOTATION =
      DiagnosticType.error(
          "JSC_INVALID_NO_SIDE_EFFECT_ANNOTATION",
          "@nosideeffects may only appear in externs files.");

  static final DiagnosticType INVALID_MODIFIES_ANNOTATION =
    DiagnosticType.error(
        "JSC_INVALID_MODIFIES_ANNOTATION",
        "@modifies may only appear in externs files.");

  private final AbstractCompiler compiler;
  private final DefinitionProvider definitionProvider;

  
  private final Map<Node, FunctionSideEffectData> functionSideEffectMap;

  
  private final List<Node> allFunctionCalls;

  
  
  private Node externs;
  private Node root;

  public PureFunctionIdentifier(AbstractCompiler compiler,
                                DefinitionProvider definitionProvider) {
    this.compiler = compiler;
    this.definitionProvider = definitionProvider;
    this.functionSideEffectMap = Maps.newHashMap();
    this.allFunctionCalls = Lists.newArrayList();
    this.externs = null;
    this.root = null;
  }

  @Override
  public void process(Node externsAst, Node srcAst) {
    if (externs != null || root != null) {
      throw new IllegalStateException(
          "It is illegal to call PureFunctionIdentifier.process " +
          "twice the same instance.  Please use a new " +
          "PureFunctionIdentifier instance each time.");
    }

    externs = externsAst;
    root = srcAst;

    NodeTraversal.traverse(compiler, externs, new FunctionAnalyzer(true));
    NodeTraversal.traverse(compiler, root, new FunctionAnalyzer(false));

    propagateSideEffects();

    markPureFunctionCalls();
  }

  




  String getDebugReport() {
    Preconditions.checkNotNull(externs);
    Preconditions.checkNotNull(root);

    StringBuilder sb = new StringBuilder();

    FunctionNames functionNames = new FunctionNames(compiler);
    functionNames.process(null, externs);
    functionNames.process(null, root);

    sb.append("Pure functions:\n");
    for (Map.Entry<Node, FunctionSideEffectData> entry :
             functionSideEffectMap.entrySet()) {
      Node function = entry.getKey();
      FunctionSideEffectData functionInfo = entry.getValue();

      boolean isPure =
          functionInfo.mayBePure() && !functionInfo.mayHaveSideEffects();
      if (isPure) {
        sb.append("  " + functionNames.getFunctionName(function) + "\n");
      }
    }
    sb.append("\n");

    for (Map.Entry<Node, FunctionSideEffectData> entry :
             functionSideEffectMap.entrySet()) {
      Node function = entry.getKey();
      FunctionSideEffectData functionInfo = entry.getValue();

      Set<String> depFunctionNames = Sets.newHashSet();
      for (Node callSite : functionInfo.getCallsInFunctionBody()) {
        Collection<Definition> defs =
            getCallableDefinitions(definitionProvider,
                                   callSite.getFirstChild());

        if (defs == null) {
          depFunctionNames.add("<null def list>");
          continue;
        }

        for (Definition def : defs) {
          depFunctionNames.add(
              functionNames.getFunctionName(def.getRValue()));
        }
      }

      sb.append(functionNames.getFunctionName(function) + " " +
                functionInfo.toString() +
                " Calls: " + depFunctionNames + "\n");
    }

    return sb.toString();
  }

  










  private static Collection<Definition> getCallableDefinitions(
      DefinitionProvider definitionProvider, Node name) {
    if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {
      List<Definition> result = Lists.newArrayList();

      Collection<Definition> decls =
          definitionProvider.getDefinitionsReferencedAt(name);
      if (decls == null) {
        return null;
      }

      for (Definition current : decls) {
        Node rValue = current.getRValue();
        if ((rValue != null) && NodeUtil.isFunction(rValue)) {
          result.add(current);
        } else {
          return null;
        }
      }

      return result;
    } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {
      Node firstVal;
      if (name.getType() == Token.HOOK) {
        firstVal = name.getFirstChild().getNext();
      } else {
        firstVal = name.getFirstChild();
      }

      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,
                                                            firstVal);
      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,
                                                            firstVal.getNext());
      if (defs1 != null && defs2 != null) {
        defs1.addAll(defs2);
        return defs1;
      } else {
        return null;
      }
    } else if (NodeUtil.isFunctionExpression(name)) {
      
      
      

      
      
      
      
      
      return Lists.newArrayList(
          (Definition)
              new DefinitionsRemover.FunctionExpressionDefinition(name, false));
    } else {
      return null;
    }
  }

  





  private void propagateSideEffects() {
    
    DiGraph<FunctionSideEffectData, Node> sideEffectGraph =
        new LinkedDirectedGraph<FunctionSideEffectData, Node>();

    
    for (FunctionSideEffectData functionInfo : functionSideEffectMap.values()) {
      sideEffectGraph.createNode(functionInfo);
    }

    
    for (FunctionSideEffectData functionInfo : functionSideEffectMap.values()) {
      if (!functionInfo.mayHaveSideEffects()) {
        continue;
      }

      for (Node callSite : functionInfo.getCallsInFunctionBody()) {
        Node callee = callSite.getFirstChild();
        Collection<Definition> defs =
            getCallableDefinitions(definitionProvider, callee);
        if (defs == null) {
          
          
          
          
          
          
          functionInfo.setTaintsUnknown();
          break;
        }

        for (Definition def : defs) {
          Node defValue = def.getRValue();
          FunctionSideEffectData dep = functionSideEffectMap.get(defValue);
          Preconditions.checkNotNull(dep);
          sideEffectGraph.connect(dep, callSite, functionInfo);
        }
      }
    }

    
    FixedPointGraphTraversal.newTraversal(new SideEffectPropagationCallback())
        .computeFixedPoint(sideEffectGraph);

    
    for (FunctionSideEffectData functionInfo : functionSideEffectMap.values()) {
      if (functionInfo.mayBePure()) {
        functionInfo.setIsPure();
      }
    }
  }

  


  private void markPureFunctionCalls() {
    for (Node callNode : allFunctionCalls) {
      Node name = callNode.getFirstChild();
      Collection<Definition> defs =
          getCallableDefinitions(definitionProvider, name);
      
      Node.SideEffectFlags flags = new Node.SideEffectFlags();
      if (defs == null) {
        flags.setMutatesGlobalState();
        flags.setThrows();
        flags.setReturnsTainted();
      } else {
        flags.clearAllFlags();
        for (Definition def : defs) {
          FunctionSideEffectData functionInfo =
              functionSideEffectMap.get(def.getRValue());
          Preconditions.checkNotNull(functionInfo);
          
          
          if (functionInfo.mutatesGlobalState()) {
            flags.setMutatesGlobalState();
          }

          if (functionInfo.functionThrows()) {
            flags.setThrows();
          }

          if (!NodeUtil.isNew(callNode)) {
            if (functionInfo.mutatesThis()) {
              flags.setMutatesThis();
            }
          }

          if (functionInfo.hasNonLocalReturnValue()) {
            flags.setReturnsTainted();
          }

          if (flags.areAllFlagsSet()) {
            break;
          }
        }
      }

      
      if (NodeUtil.isCall(callNode)) {
        Preconditions.checkState(compiler != null);
        if (!NodeUtil.functionCallHasSideEffects(callNode, compiler)) {
          flags.clearSideEffectFlags();
        }
      } else if (NodeUtil.isNew(callNode)) {
        
        if (!NodeUtil.constructorCallHasSideEffects(callNode)) {
          flags.clearSideEffectFlags();
        }
      }

      callNode.setSideEffectFlags(flags.valueOf());
    }
  }

  




  private class FunctionAnalyzer implements ScopedCallback {
    private final boolean inExterns;

    FunctionAnalyzer(boolean inExterns) {
      this.inExterns = inExterns;
    }

    @Override
    public boolean shouldTraverse(NodeTraversal traversal,
                                  Node node,
                                  Node parent) {



      return true;
    }

    @Override
    public void visit(NodeTraversal traversal, Node node, Node parent) {

      if (inExterns) {
        return;
      }

      if (!NodeUtil.nodeTypeMayHaveSideEffects(node)
          && node.getType() != Token.RETURN) {
        return;
      }

      if (NodeUtil.isCall(node) || NodeUtil.isNew(node)) {
        allFunctionCalls.add(node);
      }

      Node enclosingFunction = traversal.getEnclosingFunction();
      if (enclosingFunction != null) {
        FunctionSideEffectData sideEffectInfo =
            functionSideEffectMap.get(enclosingFunction);
        Preconditions.checkNotNull(sideEffectInfo);

        if (NodeUtil.isAssignmentOp(node)) {
          visitAssignmentOrUnaryOperator(
              sideEffectInfo, traversal.getScope(),
              node, node.getFirstChild(), node.getLastChild());
        } else {
          switch(node.getType()) {
            case Token.CALL:
            case Token.NEW:
              visitCall(sideEffectInfo, node);
              break;
            case Token.DELPROP:
            case Token.DEC:
            case Token.INC:
              visitAssignmentOrUnaryOperator(
                  sideEffectInfo, traversal.getScope(),
                  node, node.getFirstChild(), null);
              break;
            case Token.NAME:
              
              
              
              Preconditions.checkArgument(
                  NodeUtil.isVarDeclaration(node));
              Node value = node.getFirstChild();
              
              
              
              if (value != null && !analyzeSet(
                      new NameValueEntry(node), value, sideEffectInfo)) {
                Scope scope = traversal.getScope();
                Var var = scope.getVar(node.getString());
                sideEffectInfo.addNonLocalValue(var);
              }
              break;
            case Token.THROW:
              visitThrow(sideEffectInfo);
              break;
            case Token.RETURN:
              if (node.hasChildren() && !analyzeSet(
                      KeywordValueEntry.RETURN, node.getFirstChild(),
                      sideEffectInfo)) {
                sideEffectInfo.setTaintsReturn();
              }
              break;
            default:
              throw new IllegalArgumentException(
                  "Unhandled side effect node type " +
                  Token.name(node.getType()));
          }
        }
      }
    }

    @Override
    public void enterScope(NodeTraversal traversal) {
      Node enclosingFunction = traversal.getEnclosingFunction();
      if (enclosingFunction != null) {
        
        
        
        
        visitFunction(traversal, enclosingFunction);
      }
    }

    @Override
    public void exitScope(NodeTraversal t) {
      if (t.inGlobalScope() || inExterns) {
        return;
      }

      FunctionSideEffectData sideEffectInfo =
          functionSideEffectMap.get(t.getScopeRoot());

      sideEffectInfo.normalizeValueMaps();
    }

    









    private void visitAssignmentOrUnaryOperator(
        FunctionSideEffectData sideEffectInfo,
        Scope scope, Node op, Node lhs, Node rhs) {
      if (NodeUtil.isName(lhs)) {
        Var var = scope.getVar(lhs.getString());
        if (var == null || var.scope != scope) {
          sideEffectInfo.setTaintsGlobalState();
        } else {
          
          
          

          
          
          Preconditions.checkState(
              NodeUtil.isAssignmentOp(op)
              || isIncDec(op) || op.getType() == Token.DELPROP);
          if (rhs != null
              && NodeUtil.isAssign(op)
              && !analyzeSet(
                new NameValueEntry(lhs), rhs, sideEffectInfo)) {
            sideEffectInfo.addNonLocalValue(var);
          }
        }
      } else if (NodeUtil.isGet(lhs)) {
        if (NodeUtil.isThis(lhs.getFirstChild())) {
          sideEffectInfo.setTaintsThis();
        } else {
          Var var = null;
          Node objectNode = lhs.getFirstChild();
          if (NodeUtil.isName(objectNode)) {
            var = scope.getVar(objectNode.getString());
          }
          if (var == null || var.scope != scope) {
            sideEffectInfo.setTaintsUnknown();
          } else {
            
            
            
            sideEffectInfo.addModified(var);
          }
        }
      } else {
        
        

        
        
        
        
        sideEffectInfo.setTaintsUnknown();
      }
    }

    


    private void visitCall(FunctionSideEffectData sideEffectInfo, Node node) {
      
      if (NodeUtil.isCall(node)
          && !NodeUtil.functionCallHasSideEffects(node, compiler)) {
        return;
      }

      
      if (NodeUtil.isNew(node)
          && !NodeUtil.constructorCallHasSideEffects(node)) {
        return;
      }

      sideEffectInfo.appendCall(node);
    }

    


    private void visitFunction(NodeTraversal traversal, Node node) {
      Preconditions.checkArgument(!functionSideEffectMap.containsKey(node));

      FunctionSideEffectData sideEffectInfo = new FunctionSideEffectData(
          inExterns, traversal.getScope());
      functionSideEffectMap.put(node, sideEffectInfo);

      if (!inExterns) {
        Scope localScope = traversal.getScope();

        
        
        
        Iterator<Var> i = localScope.getVars();
        while (i.hasNext()) {
          Var v = i.next();
          Node parent = v.getParentNode();
          if (parent.getType() == Token.LP
              || parent.getType() == Token.CATCH) {
            
            sideEffectInfo.addNonLocalValue(v);
          }
        }
      }

      processFunctionAnnotations(sideEffectInfo, traversal, node);
    }

    



    private void processFunctionAnnotations(
        FunctionSideEffectData sideEffectInfo,
        NodeTraversal traversal, Node function) {
      
      if (inExterns) {
        JSType jstype = function.getJSType();
        boolean knownLocalResult = false;
        if (jstype != null && jstype.isFunctionType()) {
          FunctionType functionType = (FunctionType) jstype;
          JSType jstypeReturn = functionType.getReturnType();
          if (isLocalValueType(jstypeReturn, true)) {
            knownLocalResult = true;
          }
        }
        if (!knownLocalResult) {
          sideEffectInfo.setTaintsReturn();
        }
      }

      JSDocInfo info = getJSDocInfoForFunction(function);
      if (info != null) {
        boolean hasSpecificSideEffects = false;
        if (hasSideEffectsThisAnnotation(info)) {
          if (inExterns) {
            hasSpecificSideEffects = true;
            sideEffectInfo.setTaintsThis();
          } else {
            traversal.report(function, INVALID_MODIFIES_ANNOTATION);
          }
        }

        if (hasSideEffectsArgumentsAnnotation(info)) {
          if (inExterns) {
            hasSpecificSideEffects = true;
            sideEffectInfo.setTaintsArguments();
          } else {
            traversal.report(function, INVALID_MODIFIES_ANNOTATION);
          }
        }

        if (!hasSpecificSideEffects) {
          if (hasNoSideEffectsAnnotation(info)) {
            if (inExterns) {
              sideEffectInfo.setIsPure();
            } else {
              traversal.report(function, INVALID_NO_SIDE_EFFECT_ANNOTATION);
            }
          } else if (inExterns) {
            sideEffectInfo.setTaintsGlobalState();
          }
        }
      } else {
        if (inExterns) {
          sideEffectInfo.setTaintsGlobalState();
        }
      }
    }

    


    private boolean isLocalValueType(JSType jstype, boolean recurse) {
      Preconditions.checkNotNull(jstype);
      JSType subtype =  jstype.getGreatestSubtype(
          compiler.getTypeRegistry().getNativeType(JSTypeNative.OBJECT_TYPE));
      
      
      return subtype.isNoType();
    }

    


    private void visitThrow(FunctionSideEffectData sideEffectInfo) {
      sideEffectInfo.setFunctionThrows();
    }

    


    private JSDocInfo getJSDocInfoForFunction(Node node) {
      Node parent = node.getParent();
      JSDocInfo info = node.getJSDocInfo();
      if (info != null) {
        return info;
      } else if (NodeUtil.isName(parent)) {
        Node gramp = parent.getParent();
        return gramp.hasOneChild() ? gramp.getJSDocInfo() : null;
      } else if (NodeUtil.isAssign(parent)) {
        return parent.getJSDocInfo();
      } else {
        return null;
      }
    }

    



    private boolean hasNoSideEffectsAnnotation(JSDocInfo docInfo) {
      Preconditions.checkNotNull(docInfo);
      return docInfo.isNoSideEffects();
    }

    



    private boolean hasSideEffectsThisAnnotation(JSDocInfo docInfo) {
      Preconditions.checkNotNull(docInfo);
      return (docInfo.getModifies().contains("this"));
    }

    



    private boolean hasSideEffectsArgumentsAnnotation(JSDocInfo docInfo) {
      Preconditions.checkNotNull(docInfo);
      Set<String> modifies = docInfo.getModifies();
      
      
      return (modifies.size() > 1
          || (modifies.size() == 1 && !modifies.contains("this")));
    }
  }

  private static boolean isIncDec(Node n) {
    int type = n.getType();
    return (type == Token.INC || type == Token.DEC);
  }

  






  private static boolean analyzeSet(
      final ValueEntry lValue,
      Node rValue,
      final FunctionSideEffectData info) {

    final boolean isReturnResult = lValue.equals(KeywordValueEntry.RETURN);

    
    final Predicate<Node> taintingPredicate = new Predicate<Node>() {
      @Override
      public boolean apply(Node value) {
        switch (value.getType()) {
          case Token.ASSIGN:
            
            
            

            
            
            Preconditions.checkState(
                !NodeUtil.isImmutableValue(value.getLastChild()));
            Node lhs = value.getFirstChild();
            if (NodeUtil.isName(lhs)
                && info.getScope().isDeclared(lhs.getString(), false)) {
              addValue(lhs);
              return true;
            }
            
            return false;
          case Token.THIS:
            
            
            addValue(KeywordValueEntry.THIS);
            return true;
          case Token.NAME:
            
            
            if (info.getScope().isDeclared(value.getString(), false)) {
              addValue(value);
              return true;
            }
            return false;
          case Token.CALL:
            
            addCall(value);
            return true;
          case Token.GETELEM:
          case Token.GETPROP:
            
            return false;
          default:
            throw new IllegalStateException("unexpected");
        }
      }

      private void addCall(Node callNode) {
        Preconditions.checkState(callNode.getType() == Token.CALL);
        info.addInfluence(new CallValueEntry(callNode), lValue);
      }

      private void addValue(Node name) {
        ValueEntry value = new NameValueEntry(name);
        addValue(value);
      }

      private void addValue(ValueEntry value) {
        
        info.addInfluence(value, lValue);
        if (!isReturnResult) {
          info.addInfluence(lValue, value);
        }
      }
    };

    
    return NodeUtil.evaluatesToLocalValue(rValue, taintingPredicate);
  }

  private static Predicate<Node> getLocalPredicate(
      final FunctionSideEffectData caller) {
    return new Predicate<Node>() {
      @Override
      public boolean apply(Node value) {
        return caller.isLocalValue(value);
      }
    };
  }

  


  private static class SideEffectPropagationCallback
      implements EdgeCallback<FunctionSideEffectData, Node> {
    public boolean traverseEdge(final FunctionSideEffectData callee,
                                final Node callSite,
                                final FunctionSideEffectData caller) {
      Preconditions.checkArgument(callSite.getType() == Token.CALL ||
                                  callSite.getType() == Token.NEW);

      boolean changed = false;
      if (caller.isInformationStable()) {
        
        return false;
      }

      if (!caller.mutatesGlobalState() && callee.mutatesGlobalState()) {
        caller.setTaintsGlobalState();
        changed = true;
      }

      if (!caller.functionThrows() && callee.functionThrows()) {
        caller.setFunctionThrows();
        changed = true;
      }

      Predicate<Node> locals = getLocalPredicate(caller);
      if (callee.hasNonLocalReturnValue()) {
        if (caller.maybePropagateNonLocal(new CallValueEntry(callSite))) {
          changed = true;
        }
      }

      if (callee.mutatesThis()) {
        
        
        if (callSite.getType() != Token.NEW) {
          Node objectNode = getCallThisObject(callSite);
          if (objectNode != null && NodeUtil.isThis(objectNode)) {
            if (!caller.mutatesThis()) {
              caller.setTaintsThis();
              changed = true;
            }
          } else if (objectNode != null && !isCallOrApply(callSite)) {
            
            
            
            
            
            

            
            
            if (!NodeUtil.evaluatesToLocalValue(objectNode, locals)) {
              if (!caller.mutatesGlobalState()) {
                caller.setTaintsGlobalState();
                changed = true;
              }
            }
          } else if (!caller.mutatesGlobalState()) {
            caller.setTaintsGlobalState();
            changed = true;
          }
        }
      }

      if (caller.isInformationStable()) {
        
        
        caller.clearLocalityState();
      }

      return changed;
    }
  }

  








  private static Node getCallThisObject(Node callSite) {
    Node callTarget = callSite.getFirstChild();
    if (!NodeUtil.isGet(callTarget)) {

      
      return null;
    }

    String propString = callTarget.getLastChild().getString();
    if (propString.equals("call") || propString.equals("apply")) {
      return callTarget.getNext();
    } else {
      return callTarget.getFirstChild();
    }
  }

  private static boolean isCallOrApply(Node callSite) {
    Node callTarget = callSite.getFirstChild();
    if (NodeUtil.isGet(callTarget)) {
      String propString = callTarget.getLastChild().getString();
      if (propString.equals("call") || propString.equals("apply")) {
        return true;
      }
    }
    return false;
  }

  



  static class Driver implements CompilerPass {
    private final AbstractCompiler compiler;
    private final String reportPath;
    private final boolean useNameReferenceGraph;

    Driver(AbstractCompiler compiler, String reportPath,
        boolean useNameReferenceGraph) {
      this.compiler = compiler;
      this.reportPath = reportPath;
      this.useNameReferenceGraph = useNameReferenceGraph;
    }

    @Override
    public void process(Node externs, Node root) {
      DefinitionProvider definitionProvider = null;
      if (useNameReferenceGraph) {
        NameReferenceGraphConstruction graphBuilder =
            new NameReferenceGraphConstruction(compiler);
        graphBuilder.process(externs, root);
        definitionProvider = graphBuilder.getNameReferenceGraph();
      } else {
        SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);
        defFinder.process(externs, root);
        definitionProvider = defFinder;
      }

      PureFunctionIdentifier pureFunctionIdentifier =
          new PureFunctionIdentifier(compiler, definitionProvider);
      pureFunctionIdentifier.process(externs, root);

      if (reportPath != null) {
        try {
          Files.write(pureFunctionIdentifier.getDebugReport(),
              new File(reportPath),
              Charsets.UTF_8);
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      }
    }
  }
}
