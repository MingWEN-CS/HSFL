1a2,200
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> package com.google.javascript.jscomp.deps;
> 
> import com.google.common.collect.Lists;
> import com.google.javascript.jscomp.CheckLevel;
> import com.google.javascript.jscomp.DiagnosticType;
> import com.google.javascript.jscomp.ErrorManager;
> import com.google.javascript.jscomp.JSError;
> 
> import java.util.List;
> import java.util.regex.Matcher;
> import java.util.regex.Pattern;
> 
> 
> 
> 
> 
> 
> 
> public abstract class JsFileLineParser {
> 
>   static final DiagnosticType PARSE_WARNING = DiagnosticType.warning(
>       "DEPS_PARSE_WARNING", "{0}\n{1}");
>   static final DiagnosticType PARSE_ERROR = DiagnosticType.error(
>       "DEPS_PARSE_ERROR", "{0}\n{1}");
> 
>   
> 
> 
>   protected static class ParseException extends Exception {
>     public static final long serialVersionUID = 1L;
>     private boolean fatal;
> 
>     
> 
> 
> 
> 
> 
>     public ParseException(String message, boolean fatal) {
>       super(message);
>       this.fatal = fatal;
>     }
> 
>     public boolean isFatal() {
>       return fatal;
>     }
>   }
> 
>   
>   private static final Pattern STRIP_COMMENTS_PATTERN =
>       Pattern.compile("/\\*.*?\\*/" + 
>           "|
>           , Pattern.DOTALL | Pattern.MULTILINE);
> 
>   
>   private static final Pattern STRING_LITERAL_PATTERN = Pattern.compile(
>       "\\s*(?:'((?:\\\\'|[^'])*?)'|\"((?:\\\\\"|[^\"])*?)\")\\s*");
> 
>   
>   private Matcher stripCommentsMatcher = STRIP_COMMENTS_PATTERN.matcher("");
>   
>   private Matcher valueMatcher = STRING_LITERAL_PATTERN.matcher("");
> 
>   
>   protected String filePath;
>   
>   protected int lineNum;
>   
>   protected ErrorManager errorManager;
>   
>   protected boolean parseSucceeded;
> 
>   
> 
> 
> 
> 
>   public JsFileLineParser(ErrorManager errorManager) {
>     this.errorManager = errorManager;
>   }
> 
>   public boolean didParseSucceed() {
>     return parseSucceeded;
>   }
> 
>   
> 
> 
> 
> 
> 
> 
> 
> 
>   protected void doParse(String filePath, String fileContents) {
>     this.filePath = filePath;
>     parseSucceeded = true;
> 
>     
>     stripCommentsMatcher.reset(fileContents);
>     
>     
>     fileContents = stripCommentsMatcher.replaceAll("");
>     lineNum = 0;
>     
>     for (String line : fileContents.split("\n")) {
>       ++lineNum;
>       try {
>         parseLine(line);
>       } catch (ParseException e) {
>         
>         errorManager.report(
>             e.isFatal() ? CheckLevel.ERROR : CheckLevel.WARNING,
>             JSError.make(filePath, lineNum, 0 ,
>                 e.isFatal() ? PARSE_ERROR : PARSE_WARNING,
>                 e.getMessage(), line));
>         parseSucceeded = parseSucceeded && !e.isFatal();
>       }
>     }
>   }
> 
>   
> 
> 
> 
> 
> 
>   protected abstract void parseLine(String line) throws ParseException;
> 
>   
> 
> 
> 
> 
> 
> 
>   protected String parseJsString(String jsStringLiteral) throws ParseException {
>     valueMatcher.reset(jsStringLiteral);
>     if (!valueMatcher.matches()) {
>       throw new ParseException("Syntax error in JS String literal", true );
>     }
>     return valueMatcher.group(1) != null ? valueMatcher.group(1) : valueMatcher.group(2);
>   }
> 
>   
> 
> 
> 
> 
> 
>   List<String> parseJsStringArray(String input)
>       throws ParseException {
>     List<String> results = Lists.newArrayList();
>     int indexStart = input.indexOf('[');
>     int indexEnd = input.lastIndexOf(']');
>     if ((indexStart == -1) || (indexEnd == -1)) {
>       throw new ParseException("Syntax error when parsing JS array", true );
>     }
>     String innerValues = input.substring(indexStart + 1, indexEnd);
> 
>     if (!innerValues.trim().isEmpty()) {
>       valueMatcher.reset(innerValues);
>       for (;;) {
>         
>         if (!valueMatcher.lookingAt()) {
>           throw new ParseException("Syntax error in JS String literal", true );
>         }
>         
>         results.add(valueMatcher.group(1) != null ?
>             valueMatcher.group(1) : valueMatcher.group(2));
>         if (valueMatcher.hitEnd()) {
>           break;
>         }
>         
>         if (innerValues.charAt(valueMatcher.end()) != ',') {
>           throw new ParseException("Missing comma in string array", true );
>         }
>         
>         valueMatcher.region(valueMatcher.end() + 1, valueMatcher.regionEnd());
>       }
>     }
>     return results;
>   }
> }
