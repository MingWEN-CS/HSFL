















package com.google.javascript.jscomp;

import com.google.common.collect.Lists;
import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;

import java.util.LinkedList;
import java.util.List;



















































class ExtractPrototypeMemberDeclarations implements CompilerPass {

  private static final int GLOBAL_VAR_DECL_OVERHEAD = "var t;".length();

  
  
  private static final int PER_EXTRACTION_INSTANCE_OVERHEAD =
      "t=y.prototype;".length();

  
  private static final int PER_PROTOTYPE_MEMBER_DELTA =
      "t.y=".length() - "x[p].y=".length();

  
  
  private String prototypeAlias = "JSCompiler_prototypeAlias";

  private final AbstractCompiler compiler;

  public ExtractPrototypeMemberDeclarations(AbstractCompiler compiler) {
    this.compiler = compiler;
  }

  @Override
  public void process(Node externs, Node root) {
    GatherExtractionInfo extractionInfo = new GatherExtractionInfo();
    NodeTraversal.traverse(compiler, root, extractionInfo);
    if (extractionInfo.shouldExtract()) {
      doExtraction(extractionInfo);
      compiler.reportCodeChange();
    }
  }

  



  private void doExtraction(GatherExtractionInfo info) {
    
    Node injectionPoint = compiler.getNodeForCodeInsertion(null);

    Node var = NodeUtil.newVarNode(prototypeAlias, null)
        .copyInformationFromForTree(injectionPoint);

    injectionPoint.addChildrenToFront(var);

    
    for (ExtractionInstance instance : info.instances) {
      extractInstance(instance);
    }
  }

  




  private void extractInstance(ExtractionInstance instance) {
    
    PrototypeMemberDeclaration first = instance.declarations.getFirst();
    String className = first.qualifiedClassName;
    Node stmt = new Node(first.node.getType(),
        new Node(Token.ASSIGN,
            Node.newString(Token.NAME, prototypeAlias),
            NodeUtil.newQualifiedNameNode(className + ".prototype",
                instance.parent, className + ".prototype")))
        .copyInformationFromForTree(first.node);

    instance.parent.addChildBefore(stmt, first.node);

    
    
    for (PrototypeMemberDeclaration declar : instance.declarations) {
      replacePrototypeMemberDeclaration(declar);
    }
  }

  



  private void replacePrototypeMemberDeclaration(
      PrototypeMemberDeclaration declar) {
    
    Node assignment = declar.node.getFirstChild();
    Node lhs = assignment.getFirstChild();
    Node name = NodeUtil.newQualifiedNameNode(
        prototypeAlias + "." + declar.memberName, declar.node,
        declar.memberName);

    
    
    
    
    Node accessNode = declar.lhs.getFirstChild().getFirstChild();
    Object originalName = accessNode.getProp(Node.ORIGINALNAME_PROP);

    String className = "?";

    if (originalName != null) {
      className = originalName.toString();
    }

    NodeUtil.setDebugInformation(name.getFirstChild(), lhs,
                                 className + ".prototype");

    assignment.replaceChild(lhs, name);
  }

  


  private class GatherExtractionInfo extends AbstractShallowCallback {

    private List<ExtractionInstance> instances = Lists.newLinkedList();
    private int totalDelta = GLOBAL_VAR_DECL_OVERHEAD;

    @Override
    public void visit(NodeTraversal t, Node n, Node parent) {

      if (n.getType() != Token.SCRIPT && n.getType() != Token.BLOCK) {
        return;
      }

      for (Node cur = n.getFirstChild(); cur != null; cur = cur.getNext()) {
        PrototypeMemberDeclaration prototypeMember =
            PrototypeMemberDeclaration.extractDeclaration(cur);
        if (prototypeMember == null) {
          continue;
        }

        
        
        ExtractionInstance instance =
            new ExtractionInstance(prototypeMember, n);
        cur = instance.declarations.getLast().node;

        
        
        if (instance.isFavorable()) {
          instances.add(instance);
          totalDelta += instance.delta;
        }
      }
    }

    



    private boolean shouldExtract() {
      return totalDelta < 0;
    }
  }

  private static class ExtractionInstance {
    LinkedList<PrototypeMemberDeclaration> declarations = Lists.newLinkedList();
    private int delta = 0;
    private final Node parent;

    private ExtractionInstance(PrototypeMemberDeclaration head, Node parent) {
      this.parent = parent;
      declarations.add(head);
      delta = PER_EXTRACTION_INSTANCE_OVERHEAD + PER_PROTOTYPE_MEMBER_DELTA;

      for (Node cur = head.node.getNext(); cur != null; cur = cur.getNext()) {

        
        
        
        
        if (NodeUtil.isFunction(cur)) {
          continue;
        }

        PrototypeMemberDeclaration prototypeMember =
            PrototypeMemberDeclaration.extractDeclaration(cur);
        if (prototypeMember == null || !head.isSameClass(prototypeMember)) {
          break;
        }
        declarations.add(prototypeMember);
        delta += PER_PROTOTYPE_MEMBER_DELTA;
      }
    }

    



    boolean isFavorable() {
      return delta <= 0;
    }
  }

  




  private static class PrototypeMemberDeclaration {
    final String memberName;
    final Node node;
    final String qualifiedClassName;
    final Node lhs;

    private PrototypeMemberDeclaration(Node lhs, Node node) {
      this.lhs = lhs;
      this.memberName = NodeUtil.getPrototypePropertyName(lhs);
      this.node = node;
      this.qualifiedClassName =
          NodeUtil.getPrototypeClassName(lhs).getQualifiedName();
    }

    private boolean isSameClass(PrototypeMemberDeclaration other) {
      return qualifiedClassName.equals(other.qualifiedClassName);
    }

    



    private static PrototypeMemberDeclaration extractDeclaration(Node n) {
      if (!NodeUtil.isPrototypePropertyDeclaration(n)) {
        return null;
      }
      Node lhs = n.getFirstChild().getFirstChild();
      return new PrototypeMemberDeclaration(lhs, n);
    }
  }
}
