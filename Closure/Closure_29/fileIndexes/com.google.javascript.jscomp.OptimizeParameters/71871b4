















package com.google.javascript.jscomp;

import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.javascript.jscomp.DefinitionsRemover.Definition;
import com.google.javascript.jscomp.NameReferenceGraph.Name;
import com.google.javascript.jscomp.NameReferenceGraph.Reference;
import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;
import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;

import java.util.List;














class OptimizeParameters implements CompilerPass {

  private final AbstractCompiler compiler;
  private NameReferenceGraph nameGraph;

  OptimizeParameters(AbstractCompiler compiler, NameReferenceGraph nameGraph) {
    this.compiler = compiler;
    this.nameGraph = nameGraph;
  }

  OptimizeParameters(AbstractCompiler compiler) {
    this(compiler, null);
  }

  @Override
  public void process(Node externs, Node root) {
    if (nameGraph == null) {
      NameReferenceGraphConstruction c =
          new NameReferenceGraphConstruction(compiler);
      c.process(externs, root);
      nameGraph = c.getNameReferenceGraph();
    }

    for (DiGraphNode<Name, Reference> node :
        nameGraph.getDirectedGraphNodes()) {
      Name name = node.getValue();
      if (name.canChangeSignature()) {
        List<DiGraphEdge<Name, Reference>> edges = node.getInEdges();
        tryEliminateConstantArgs(name, edges);
        tryEliminateOptionalArgs(name, edges);
      }
    }
  }

  




  private void tryEliminateOptionalArgs(Name name,
      List<DiGraphEdge<Name, Reference>> edges) {

    
    
    int maxArgs = -1;

    for (DiGraphEdge<Name, Reference> refEdge : edges) {
      Reference ref = refEdge.getValue();
      Node call = ref.parent;

      if (isCallSite(ref)) {
        int numArgs = call.getChildCount() - 1;
        if (numArgs > maxArgs) {
          maxArgs = numArgs;
        }
      } 
    }

    for (Definition definition : name.getDeclarations()) {
      eliminateParamsAfter(definition.getRValue(), maxArgs);
    }
  }

  













  private void tryEliminateConstantArgs(Name name,
      List<DiGraphEdge<Name, Reference>> edges) {

    List<Parameter> parameters = Lists.newArrayList();
    boolean firstCall = true;

    
    for (DiGraphEdge<Name, Reference> refEdge : edges) {
      Reference ref = refEdge.getValue();
      Node call = ref.parent;

      if (isCallSite(ref)) {
        Node cur = call.getFirstChild();
        if (firstCall) {
          
          
          buildParameterList(parameters, cur);
          firstCall = false;
        } else {
          findConstantParameters(parameters, cur);
        }
      }
    }

    
    for (DiGraphEdge<Name, Reference> refEdge : edges) {
      Reference ref = refEdge.getValue();
      Node call = ref.parent;

      if (isCallSite(ref)) {
        optimizeCallSite(parameters, call);
      }
    }

    
    
    for (Definition definition : name.getDeclarations()) {
      Node function = definition.getRValue();
      if (NodeUtil.isFunction(function)) {
        optimizeFunctionDefinition(parameters, function);
      }
    }
  }

  private void findConstantParameters(List<Parameter> parameters, Node cur) {
    for (int index = 0; (cur = cur.getNext()) != null; index++) {
      if (index >= parameters.size()) {
        parameters.add(new Parameter(cur, false));
      } else if (parameters.get(index).shouldRemove()){
        Node value = parameters.get(index).getArg();
        if (!nodesAreEqual(cur, value)) {
          parameters.get(index).setShouldRemove(false);
        }
      }
    }
  }

  private void buildParameterList(List<Parameter> parameters, Node cur) {
    while ((cur = cur.getNext()) != null) {
      parameters.add(new Parameter(cur, NodeUtil.isLiteralValue(cur, false)));
    }
  }

  private void optimizeFunctionDefinition(List<Parameter> parameters,
      Node function) {
    for (int index = parameters.size() - 1; index >= 0; index--) {
      if (parameters.get(index).shouldRemove()) {
        Node paramName = eliminateFunctionParamAt(function, index);
        if (paramName != null) {
          addVariableToFunction(function, paramName,
              parameters.get(index).getArg());
        }
      }
    }
  }

  private void optimizeCallSite(List<Parameter> parameters, Node call) {
    for (int index = parameters.size() - 1; index >= 0; index--) {
      if (parameters.get(index).shouldRemove()) {
        eliminateCallParamAt(call, index);
      }
    }
  }

  



  private boolean isCallSite(Reference ref) {
    Node call = ref.parent;
    
    
    
    return isCallOrNew(call) && call.getFirstChild() == ref.site;
  }

  






  private boolean isCallOrNew(Node node) {
    return NodeUtil.isCall(node) || NodeUtil.isNew(node);
  }

  






  private boolean nodesAreEqual(Node n1, Node n2) {
    return NodeUtil.isImmutableValue(n1) && NodeUtil.isImmutableValue(n2) &&
        n1.checkTreeEqualsSilent(n2);
  }

  



  private static class Parameter {
    private final Node arg;
    private boolean shouldRemove;

    public Parameter(Node arg, boolean shouldRemove) {
      this.shouldRemove = shouldRemove;
      this.arg = arg;
    }

    public Node getArg() {
      return arg;
    }

    public boolean shouldRemove() {
      return shouldRemove;
    }

    public void setShouldRemove(boolean value) {
      shouldRemove = value;
    }
  }

  





  private void addVariableToFunction(Node function, Node varName, Node value) {
    Preconditions.checkArgument(NodeUtil.isFunction(function),
        "Node must be a function.");

    Node block = function.getLastChild();
    Preconditions.checkArgument(block.getType() == Token.BLOCK,
        "Node must be a block.");

    Node newVar = NodeUtil.newVarNode(varName.getQualifiedName(),
        value.cloneTree());
    block.addChildToFront(newVar);
    compiler.reportCodeChange();
  }

  



  private boolean eliminateParamsAfter(Node function, int argIndex) {

    boolean paramRemoved = false;

    Node formalArgPtr = function.getFirstChild().getNext().getFirstChild();
    while (argIndex != 0 && formalArgPtr != null) {
      formalArgPtr = formalArgPtr.getNext();
      argIndex--;
    }

    while (formalArgPtr != null) {
      Node next = formalArgPtr.getNext();
      function.getFirstChild().getNext().removeChild(formalArgPtr);
      Node var = new Node(Token.VAR, formalArgPtr);
      function.getLastChild().addChildrenToFront(var);
      compiler.reportCodeChange();
      paramRemoved = true;
      formalArgPtr = next;
    }

    return paramRemoved;
  }

  






  private Node getArgumentAtIndex(Node firstArg, int argIndex) {
    Node formalArgPtr = firstArg;
    while (argIndex != 0 && formalArgPtr != null) {
      formalArgPtr = formalArgPtr.getNext();
      argIndex--;
    }
    return formalArgPtr;
  }

  





  private Node eliminateFunctionParamAt(Node function, int argIndex) {
    Preconditions.checkArgument(NodeUtil.isFunction(function),
        "Node must be a function.");

    Node formalArgPtr = getArgumentAtIndex(
        function.getFirstChild().getNext().getFirstChild(), argIndex);

    if (formalArgPtr != null) {
      function.getFirstChild().getNext().removeChild(formalArgPtr);
    }
    return formalArgPtr;
  }

  





  private Node eliminateCallParamAt(Node call, int argIndex) {
    Preconditions.checkArgument(isCallOrNew(call), "Node must be a call.");

    Node formalArgPtr = getArgumentAtIndex(
        call.getFirstChild().getNext(), argIndex);

    if (formalArgPtr != null) {
      call.removeChild(formalArgPtr);
      compiler.reportCodeChange();
    }
    return formalArgPtr;
  }
}
