















package com.google.javascript.jscomp;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.javascript.jscomp.DefinitionsRemover.Definition;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.Token;

import java.util.Collection;
import java.util.List;













class OptimizeParameters
    implements CompilerPass, OptimizeCalls.CallGraphCompilerPass {

  private final AbstractCompiler compiler;

  OptimizeParameters(AbstractCompiler compiler) {
    this.compiler = compiler;
  }

  
  OptimizeParameters(AbstractCompiler compiler, NameReferenceGraph unused) {
    this(compiler);
  }

  @Override
  @VisibleForTesting
  public void process(Node externs, Node root) {
    SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);
    defFinder.process(externs, root);
    process(externs, root, defFinder);
  }

  @Override
  public void process(
      Node externs, Node root, SimpleDefinitionFinder definitions) {
    for (DefinitionSite defSite : definitions.getDefinitionSites()) {
      if (canChangeSignature(defSite, definitions)) {
        tryEliminateConstantArgs(defSite, definitions);
        tryEliminateOptionalArgs(defSite, definitions);
      }
    }
  }

  



  private boolean canChangeSignature(
      DefinitionSite definitionSite, SimpleDefinitionFinder defFinder) {
    Definition definition = definitionSite.definition;

    if (definitionSite.inExterns) {
      return false;
    }

    
    
    
    Node rValue = definition.getRValue();
    if (rValue == null ||
        !NodeUtil.isFunction(rValue) ||
        NodeUtil.isVarArgsFunction(rValue)) {
      return false;
    }

    
    
    
    
    
    if (!SimpleDefinitionFinder.isSimpleFunctionDeclaration(rValue)) {
      return false;
    }

    
    if (SimpleDefinitionFinder.maybeExported(compiler, definition)) {
      return false;
    }

    Collection<UseSite> useSites = defFinder.getUseSites(definition);

    if (useSites.isEmpty()) {
      return false;
    }

    for (UseSite site : useSites) {
      
      
      
      
      if (!SimpleDefinitionFinder.isCallOrNewSite(site)) {
        return false;
      }

      

      
      
      Node nameNode = site.node;
      Collection<Definition> singleSiteDefinitions =
          defFinder.getDefinitionsReferencedAt(nameNode);
      if (singleSiteDefinitions.size() > 1) {
        return false;
      }
      Preconditions.checkState(!singleSiteDefinitions.isEmpty());
      Preconditions.checkState(singleSiteDefinitions.contains(definition));
    }

    return true;
  }

  


  private void tryEliminateOptionalArgs(
      DefinitionSite defSite, SimpleDefinitionFinder defFinder) {
    
    
    int maxArgs = -1;

    Definition definition = defSite.definition;
    Collection<UseSite> useSites = defFinder.getUseSites(definition);
    for (UseSite site : useSites) {
      Preconditions.checkState(SimpleDefinitionFinder.isCallOrNewSite(site));
      Node call = site.node.getParent();

      int numArgs = call.getChildCount() - 1;
      if (numArgs > maxArgs) {
        maxArgs = numArgs;
      }
    }

    eliminateParamsAfter(definition.getRValue(), maxArgs);
  }

  










  private void tryEliminateConstantArgs(
      DefinitionSite defSite, SimpleDefinitionFinder defFinder) {

    List<Parameter> parameters = Lists.newArrayList();
    boolean firstCall = true;

    
    Definition definition = defSite.definition;
    Collection<UseSite> useSites = defFinder.getUseSites(definition);
    for (UseSite site : useSites) {
      Preconditions.checkState(SimpleDefinitionFinder.isCallOrNewSite(site));
      Node call = site.node.getParent();

      Node cur = call.getFirstChild();
      if (firstCall) {
        
        
        buildParameterList(parameters, cur);
        firstCall = false;
      } else {
        findConstantParameters(parameters, cur);
      }
    }

    
    for (UseSite site : useSites) {
      Preconditions.checkState(SimpleDefinitionFinder.isCallOrNewSite(site));
      Node call = site.node.getParent();

      optimizeCallSite(parameters, call);
    }

    
    
    Node function = definition.getRValue();
    if (NodeUtil.isFunction(function)) {
      optimizeFunctionDefinition(parameters, function);
    }
  }

  private void findConstantParameters(List<Parameter> parameters, Node cur) {
    int index = 0;
    while ((cur = cur.getNext()) != null) {
      if (index >= parameters.size()) {
        parameters.add(new Parameter(cur, false));
      } else if (parameters.get(index).shouldRemove()) {
        Node value = parameters.get(index).getArg();
        if (!nodesAreEqual(cur, value)) {
          parameters.get(index).setShouldRemove(false);
        }
      }
      index++;
    }

    for (;index < parameters.size(); index++) {
      parameters.get(index).setShouldRemove(false);
    }
  }

  private void buildParameterList(List<Parameter> parameters, Node cur) {
    while ((cur = cur.getNext()) != null) {
      parameters.add(new Parameter(cur, NodeUtil.isLiteralValue(cur, false)));
    }
  }

  private void optimizeFunctionDefinition(List<Parameter> parameters,
      Node function) {
    for (int index = parameters.size() - 1; index >= 0; index--) {
      if (parameters.get(index).shouldRemove()) {
        Node paramName = eliminateFunctionParamAt(function, index);
        if (paramName != null) {
          addVariableToFunction(function, paramName,
              parameters.get(index).getArg());
        }
      }
    }
  }

  private void optimizeCallSite(List<Parameter> parameters, Node call) {
    for (int index = parameters.size() - 1; index >= 0; index--) {
      if (parameters.get(index).shouldRemove()) {
        eliminateCallParamAt(call, index);
      }
    }
  }

  






  private boolean nodesAreEqual(Node n1, Node n2) {
    return NodeUtil.isImmutableValue(n1) && NodeUtil.isImmutableValue(n2) &&
        n1.isEquivalentTo(n2);
  }

  



  private static class Parameter {
    private final Node arg;
    private boolean shouldRemove;

    public Parameter(Node arg, boolean shouldRemove) {
      this.shouldRemove = shouldRemove;
      this.arg = arg;
    }

    public Node getArg() {
      return arg;
    }

    public boolean shouldRemove() {
      return shouldRemove;
    }

    public void setShouldRemove(boolean value) {
      shouldRemove = value;
    }
  }

  





  private void addVariableToFunction(Node function, Node varName, Node value) {
    Preconditions.checkArgument(NodeUtil.isFunction(function),
        "Node must be a function.");

    Node block = function.getLastChild();
    Preconditions.checkArgument(block.getType() == Token.BLOCK,
        "Node must be a block.");

    Node newVar = NodeUtil.newVarNode(varName.getQualifiedName(),
        value.cloneTree());
    block.addChildToFront(newVar);
    compiler.reportCodeChange();
  }

  



  private boolean eliminateParamsAfter(Node function, int argIndex) {
    boolean paramRemoved = false;

    Node formalArgPtr = function.getFirstChild().getNext().getFirstChild();
    while (argIndex != 0 && formalArgPtr != null) {
      formalArgPtr = formalArgPtr.getNext();
      argIndex--;
    }

    return eliminateParamsAfter(function, formalArgPtr);
  }

  private boolean eliminateParamsAfter(Node fnNode, Node argNode) {
    if (argNode != null) {
      
      eliminateParamsAfter(fnNode, argNode.getNext());
      argNode.detachFromParent();
      Node var = new Node(Token.VAR, argNode).copyInformationFrom(argNode);
      fnNode.getLastChild().addChildrenToFront(var);
      compiler.reportCodeChange();
      return true;
    }
    return false;
  }

  





  private Node eliminateFunctionParamAt(Node function, int argIndex) {
    Preconditions.checkArgument(NodeUtil.isFunction(function),
        "Node must be a function.");

    Node formalArgPtr = NodeUtil.getArgumentForFunction(
        function, argIndex);

    if (formalArgPtr != null) {
      function.getFirstChild().getNext().removeChild(formalArgPtr);
    }
    return formalArgPtr;
  }

  





  private Node eliminateCallParamAt(Node call, int argIndex) {
    Preconditions.checkArgument(
        NodeUtil.isCallOrNew(call), "Node must be a call or new.");

    Node formalArgPtr = NodeUtil.getArgumentForCallOrNew(
        call, argIndex);

    if (formalArgPtr != null) {
      call.removeChild(formalArgPtr);
      compiler.reportCodeChange();
    }
    return formalArgPtr;
  }
}
