















package com.google.javascript.jscomp;

import com.google.common.base.Preconditions;
import com.google.javascript.jscomp.AnalyzePrototypeProperties.AssignmentProperty;
import com.google.javascript.jscomp.AnalyzePrototypeProperties.GlobalFunction;
import com.google.javascript.jscomp.AnalyzePrototypeProperties.LiteralProperty;
import com.google.javascript.jscomp.AnalyzePrototypeProperties.NameInfo;
import com.google.javascript.jscomp.AnalyzePrototypeProperties.Symbol;
import com.google.javascript.rhino.Node;

import java.util.Collection;
import java.util.logging.Logger;





class RemoveUnusedPrototypeProperties implements
    SpecializationAwareCompilerPass {

  private static final Logger logger =
    Logger.getLogger(RemoveUnusedPrototypeProperties.class.getName());

  private final AbstractCompiler compiler;
  private final boolean canModifyExternsProtypeProps;
  private final boolean anchorUnusedVars;
  private SpecializeModule.SpecializationState specializationState;
  private final boolean canModifyThisProperties;
  private final boolean anchorObjectLiteralProperties;

  











  RemoveUnusedPrototypeProperties(AbstractCompiler compiler,
      boolean canModifyExternsProtypeProps,
      boolean anchorUnusedVars, boolean canModifyThisProperties,
      boolean anchorObjectLiteralProperties) {
    this.compiler = compiler;
    this.canModifyExternsProtypeProps = canModifyExternsProtypeProps;
    this.anchorUnusedVars = anchorUnusedVars;
    this.canModifyThisProperties = canModifyThisProperties;
    this.anchorObjectLiteralProperties = anchorObjectLiteralProperties;
  }

  @Override
  public void enableSpecialization(SpecializeModule.SpecializationState state) {
    this.specializationState = state;
  }

  @Override
  public void process(Node externRoot, Node root) {
    AnalyzePrototypeProperties analyzer =
        new AnalyzePrototypeProperties(compiler,
            null , canModifyExternsProtypeProps,
            anchorUnusedVars, canModifyThisProperties,
            anchorObjectLiteralProperties);
    analyzer.process(externRoot, root);
    removeUnusedSymbols(analyzer.getAllNameInfo());
  }

  



  private void removeUnusedSymbols(Collection<NameInfo> allNameInfo) {
    boolean changed = false;
    for (NameInfo nameInfo : allNameInfo) {
      if (!nameInfo.isReferenced()) {
        for (Symbol declaration : nameInfo.getDeclarations()) {
          boolean canRemove = false;

          if (specializationState == null) {
            canRemove = true;
          } else {
            Node specializableFunction =
              getSpecializableFunctionFromSymbol(declaration);

            if (specializableFunction != null) {
              specializationState.reportRemovedFunction(
                  specializableFunction, null);
              canRemove = true;
            }
          }

          if (canRemove) {
            declaration.remove(compiler);
            changed = true;
          }
        }

        logger.fine("Removed unused prototype property: " + nameInfo.name);
      }
    }

    if (changed) {
      compiler.reportCodeChange();
    }
  }

  


  private Node getSpecializableFunctionFromSymbol(Symbol symbol) {
    Preconditions.checkNotNull(specializationState);

    Node specializableFunction = null;

    if (symbol instanceof GlobalFunction) {
      specializableFunction = ((GlobalFunction) symbol).getFunctionNode();
    } else if (symbol instanceof AssignmentProperty) {
      Node propertyValue = ((AssignmentProperty) symbol).getValue();
      if (propertyValue.isFunction()) {
        specializableFunction = propertyValue;
      }
    } else if (symbol instanceof LiteralProperty) {
      
      
      

      return null;
    } else {
      Preconditions.checkState(false, "Should be unreachable.");
    }

    if (specializableFunction != null &&
        specializationState.canFixupFunction(specializableFunction)) {
      return specializableFunction;
    } else {
      return null;
    }
  }
}
