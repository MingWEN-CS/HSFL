19a20
> import com.google.common.collect.Sets;
21a23,26
> import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;
> import com.google.javascript.jscomp.graph.Graph.GraphEdge;
> import com.google.javascript.jscomp.graph.LinkedUndirectedGraph;
> import com.google.javascript.jscomp.graph.UndiGraph;
26c31,40
< import java.util.*;
---
> import java.util.ArrayList;
> import java.util.Arrays;
> import java.util.Collection;
> import java.util.Comparator;
> import java.util.HashMap;
> import java.util.HashSet;
> import java.util.List;
> import java.util.Map;
> import java.util.Set;
> import java.util.TreeSet;
66a81,90
> 
> 
> 
> 
> 
> 
>   private final UndiGraph<Property, PropertyAffinity> affinityGraph =
>       LinkedUndirectedGraph.createWithoutAnnotations();
> 
>   
73c97,99
<   
---
>   private static final Comparator<Property> FREQUENCY_COMPARATOR =
>     new Comparator<Property>() {
>       public int compare(Property p1, Property p2) {
74a101
>         
77,83c104,114
<   private static final Comparator<Property> FREQUENCY_COMPARATOR =
<       new Comparator<Property>() {
<         public int compare(Property p1, Property p2) {
<           if (p1.numOccurrences != p2.numOccurrences) {
<             return p2.numOccurrences - p1.numOccurrences;
<           }
<           return p1.oldName.compareTo(p2.oldName);
---
>         if (p1.numOccurrences != p2.numOccurrences) {
>           return p2.numOccurrences - p1.numOccurrences;
> 
>         
> 
> 
> 
> 
> 
>         } else if (p1.affinityScore != p2.affinityScore) {
>           return p2.affinityScore - p1.affinityScore;
85c116,122
<       };
---
> 
>         
> 
> 
>         return p1.oldName.compareTo(p2.oldName);
>        }
>     };
173a211
>     computeAffinityScores();
253a292,316
> 
> 
> 
>   private void computeAffinityScores() {
>     for (Property p : propertyMap.values()) {
>       for (Property other : propertyMap.values()) {
>         if (p != other && p.numOccurrences < other.numOccurrences) {
>           List<GraphEdge<Property,PropertyAffinity>> edges =
>               affinityGraph.getEdges(p, other);
>           if (!edges.isEmpty()) {
>             p.affinityScore += edges.get(0)
>                 .getValue().affinity + other.numOccurrences;
>           }
>         }
>       }
>     }
>   }
> 
>   
> 
> 
> 
> 
> 
> 
266d328
< 
268d329
< 
316a378
> 
323c385,388
<   private class ProcessProperties extends AbstractPostOrderCallback {
---
>   private class ProcessProperties extends AbstractPostOrderCallback implements
>       ScopedCallback {
> 
>     private Set<Property> currentHighAffinityProperties = null;
444a510
>         affinityGraph.createNode(prop);
446a513,542
>       if (currentHighAffinityProperties != null) {
>         currentHighAffinityProperties.add(prop);
>       }
>     }
> 
>     @Override
>     public void enterScope(NodeTraversal t) {
>       if (!t.inGlobalScope() && t.getScope().getParent().isGlobal()) {
>         currentHighAffinityProperties = Sets.newHashSet();
>       }
>     }
> 
>     @Override
>     public void exitScope(NodeTraversal t) {
>       if (!t.inGlobalScope() && t.getScope().getParent().isGlobal()) {
>         for (Property p1 : currentHighAffinityProperties) {
>           for (Property p2 : currentHighAffinityProperties) {
>             if (p1.oldName.compareTo(p2.oldName) < 0) {
>               List<GraphEdge<Property,PropertyAffinity>> edges =
>                   affinityGraph.getEdges(p1, p2);
>               if (edges.isEmpty()) {
>                 affinityGraph.connect(p1, new PropertyAffinity(1), p2);
>               } else {
>                 edges.get(0).getValue().increase();
>               }
>             }
>           }
>         }
>         currentHighAffinityProperties = null;
>       }
458a555
>     int affinityScore = 0;
461a559,570
>     }
>   }
> 
>   private class PropertyAffinity {
>     private int affinity = 0;
> 
>     private PropertyAffinity(int affinity) {
>       this.affinity = affinity;
>     }
> 
>     private void increase() {
>       affinity++;
