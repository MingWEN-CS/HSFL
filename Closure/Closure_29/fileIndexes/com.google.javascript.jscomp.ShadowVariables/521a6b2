















package com.google.javascript.jscomp;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;
import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;
import com.google.javascript.jscomp.RenameVars.Assignment;
import com.google.javascript.jscomp.Scope.Var;
import com.google.javascript.rhino.Node;

import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.SortedMap;
import java.util.SortedSet;





















class ShadowVariables implements CompilerPass {

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  private final Multimap<Node, String> scopeUpRefMap = HashMultimap.create();

  
  
  private final Multimap<Var, Node> varToNameUsage = HashMultimap.create();

  private final AbstractCompiler compiler;

  
  private final SortedSet<Assignment> varsByFrequency;
  private final SortedMap<String, Assignment> assignments;
  private final Map<Node, String> pseudoNameMap;

  





  ShadowVariables(
      AbstractCompiler compiler,
      SortedMap<String, Assignment> assignments,
      SortedSet<Assignment> varsByFrequency,
      Map<Node, String> pseudoNameMap) {
    this.compiler = compiler;
    this.assignments = assignments;
    this.varsByFrequency = varsByFrequency;
    this.pseudoNameMap = pseudoNameMap;
  }


  @Override
  public void process(Node externs, Node root) {

    
    
    
    
    
    
    NodeTraversal.traverse(compiler, root, new GatherReferenceInfo());
    NodeTraversal.traverse(compiler, root, new DoShadowVariables());
  }

  private class GatherReferenceInfo extends AbstractPostOrderCallback {
    @Override
    public void visit(NodeTraversal t, Node n, Node parent) {
      
      if (!NodeUtil.isReferenceName(n)) {
        return;
      }

      
      
      
      
      if (t.inGlobalScope()) {
        return;
      }

      Var var = t.getScope().getVar(n.getString());
      if (var == null) {
        
        return;
      }

      if (var.getScope().isGlobal()) {
        
        return;
      }

      
      if (var.getScope() != t.getScope()) {
        for (Scope s = t.getScope();
            s != var.getScope() && s.isLocal(); s = s.getParent()) {
          scopeUpRefMap.put(s.getRootNode(), var.name);
        }
      }

      if (var.getScope() == t.getScope()) {
        scopeUpRefMap.put(t.getScopeRoot(), var.name);
      }

      
      varToNameUsage.put(var, n);
    }
  }

  private class DoShadowVariables extends AbstractPostOrderCallback
      implements ScopedCallback {

    @Override
    public void enterScope(NodeTraversal t) {
      Scope s = t.getScope();
      if (!s.isLocal()) {
        return;
      }

      
      
      if (s.getParent().isGlobal()) {
        return;
      }

      for (Iterator<Var> vars = s.getVars(); vars.hasNext();) {
        Var var = vars.next();

        
        if (var.isBleedingFunction()) {
          continue;
        }

        
        Assignment bestShadow = findBestShadow(s, var);
        if (bestShadow == null) {
          continue;
        }

        
        Assignment localAssignment = assignments.get(var.getName());

        
        
        if (bestShadow.count < localAssignment.count) {
          continue; 
        }

        doShadow(localAssignment, bestShadow, var);

        if (pseudoNameMap != null) {
          String targetPseudoName =
            pseudoNameMap.get(s.getVar(bestShadow.oldName).nameNode);
          for (Node use : varToNameUsage.get(var)) {
            pseudoNameMap.put(use, targetPseudoName);
          }
        }
      }
    }

    @Override
    public void exitScope(NodeTraversal t) {}

    @Override
    public void visit(NodeTraversal t, Node n, Node parent) {}

    



    private Assignment findBestShadow(Scope curScope, Var candidate) {
      
      TARGET: for (Assignment assignment : varsByFrequency) {
        if (assignment.oldName.startsWith(RenameVars.LOCAL_VAR_PREFIX)) {
          if (!scopeUpRefMap.get(curScope.getRootNode()).contains(
              assignment.oldName)) {
            if (curScope.isDeclared(assignment.oldName, true)) {
              return assignment;
            }
          }
        }
      }
      return null;
    }

    private void doShadow(Assignment original, Assignment toShadow, Var var) {
      Scope s = var.getScope();
      
      
      Collection<Node> references = varToNameUsage.get(var);

      
      
      varsByFrequency.remove(original);
      varsByFrequency.remove(toShadow);

      
      original.count -= references.size();
      toShadow.count += references.size();

      
      varsByFrequency.add(original);
      varsByFrequency.add(toShadow);

      
      
      
      
      Var shadowed = s.getVar(toShadow.oldName);
      if (shadowed != null) {
        for (Scope curScope = s; curScope != shadowed.scope;
            curScope = curScope.getParent()) {
          scopeUpRefMap.put(curScope.getRootNode(), toShadow.oldName);
        }
      }

      
      for (Node n : references) {
        n.setString(toShadow.oldName);
        Node cur = n;
        while(cur != s.getRootNode()) {
          cur = cur.getParent();
          if (NodeUtil.isFunction(cur)) {
            scopeUpRefMap.put(cur, toShadow.oldName);
          }
        }
      }
    }
  }
}
