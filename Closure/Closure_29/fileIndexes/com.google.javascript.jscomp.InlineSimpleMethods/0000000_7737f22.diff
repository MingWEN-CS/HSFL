1a2,302
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> package com.google.javascript.jscomp;
> 
> import com.google.common.collect.Lists;
> import com.google.javascript.jscomp.NodeTraversal.Callback;
> import com.google.javascript.rhino.Node;
> import com.google.javascript.rhino.Token;
> 
> import java.util.Collection;
> import java.util.List;
> import java.util.logging.Logger;
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> class InlineSimpleMethods extends MethodCompilerPass {
> 
>   private static final Logger logger =
>       Logger.getLogger(InlineSimpleMethods.class.getName());
> 
>   InlineSimpleMethods(AbstractCompiler compiler) {
>     super(compiler);
>   }
> 
>   
> 
> 
> 
>   private class InlineTrivialAccessors extends InvocationsCallback {
> 
>     @Override
>     void visit(NodeTraversal t, Node callNode, Node parent, String callName) {
>       if (externMethods.contains(callName) ||
>           nonMethodProperties.contains(callName)) {
>         return;
>       }
> 
>       Collection<Node> definitions = methodDefinitions.get(callName);
>       if (definitions == null || definitions.size() == 0) {
>         return;
>       }
> 
>       
>       
>       Node firstDefinition = definitions.iterator().next();
> 
>       
>       if (definitions.size() == 1 || allDefinitionsEquivalent(definitions)) {
> 
>         if (!argsMayHaveSideEffects(callNode)) {
>           
>           Node returned = returnedExpression(firstDefinition);
>           if (returned != null) {
>             if (isPropertyTree(returned)) {
>               logger.fine("Inlining property accessor: " + callName);
>               inlinePropertyReturn(parent, callNode, returned);
>             } else if (NodeUtil.isLiteralValue(returned, false) &&
>               !NodeUtil.mayHaveSideEffects(callNode.getFirstChild())) {
>               logger.fine("Inlining constant accessor: " + callName);
>               inlineConstReturn(parent, callNode, returned);
>             }
>           } else if (isEmptyMethod(firstDefinition) &&
>               !NodeUtil.mayHaveSideEffects(callNode.getFirstChild())) {
>             logger.fine("Inlining empty method: " + callName);
>             inlineEmptyMethod(t, parent, callNode);
>           }
>         }
>       } else {
>         logger.fine("Method '" + callName + "' has conflicting definitions.");
>       }
>     }
>   }
> 
>   @Override
>   Callback getActingCallback() {
>     return new InlineTrivialAccessors();
>   }
> 
>   
> 
> 
> 
> 
>   private static boolean isPropertyTree(Node expectedGetprop) {
>     if (expectedGetprop.getType() != Token.GETPROP) {
>       return false;
>     }
> 
>     Node leftChild = expectedGetprop.getFirstChild();
>     if (leftChild.getType() != Token.THIS &&
>         !isPropertyTree(leftChild)) {
>       return false;
>     }
> 
>     Node retVal = leftChild.getNext();
>     if (NodeUtil.getStringValue(retVal) == null) {
>       return false;
>     }
>     return true;
>   }
> 
>   
> 
> 
> 
>   private static void replaceThis(Node expectedGetprop, Node replacement) {
>     Node leftChild = expectedGetprop.getFirstChild();
>     if (leftChild.getType() == Token.THIS) {
>       expectedGetprop.replaceChild(leftChild, replacement);
>     } else {
>       replaceThis(leftChild, replacement);
>     }
>   }
> 
>   
> 
> 
> 
>   private static Node returnedExpression(Node fn) {
>     Node expectedBlock = getMethodBlock(fn);
>     if (!expectedBlock.hasOneChild()) {
>       return null;
>     }
> 
>     Node expectedReturn = expectedBlock.getFirstChild();
>     if (expectedReturn.getType() != Token.RETURN) {
>       return null;
>     }
> 
>     if (!expectedReturn.hasOneChild()) {
>       return null;
>     }
> 
>     return expectedReturn.getLastChild();
>   }
> 
> 
>   
> 
> 
> 
> 
>   private static boolean isEmptyMethod(Node fn) {
>     Node expectedBlock = getMethodBlock(fn);
>     return expectedBlock == null ?
>         false : NodeUtil.isEmptyBlock(expectedBlock);
>   }
> 
>   
> 
> 
> 
> 
> 
>   private static Node getMethodBlock(Node fn) {
>     if (fn.getChildCount() != 3) {
>       return null;
>     }
> 
>     Node expectedBlock = fn.getLastChild();
>     return  expectedBlock.getType() == Token.BLOCK ?
>         expectedBlock : null;
>   }
> 
>   
> 
> 
>   private boolean allDefinitionsEquivalent(
>       Collection<Node> definitions) {
>     List<Node> list = Lists.newArrayList();
>     list.addAll(definitions);
>     Node node0 = list.get(0);
>     for (int i = 1; i < list.size(); i++) {
>       if (!compiler.areNodesEqualForInlining(list.get(i), node0)) {
>         return false;
>       }
>     }
>     return true;
>   }
> 
>   
> 
> 
> 
> 
> 
> 
> 
> 
> 
>   private void inlinePropertyReturn(Node parent, Node call,
>       Node returnedValue) {
>     Node getProp = returnedValue.cloneTree();
>     replaceThis(getProp, call.getFirstChild().removeFirstChild());
>     parent.replaceChild(call, getProp);
>     compiler.reportCodeChange();
>   }
> 
>   
> 
> 
> 
> 
>   private void inlineConstReturn(Node parent, Node call,
>       Node returnedValue) {
>     Node retValue = returnedValue.cloneTree();
>     parent.replaceChild(call, retValue);
>     compiler.reportCodeChange();
>   }
> 
>   
> 
> 
>   private void inlineEmptyMethod(NodeTraversal t, Node parent, Node call) {
>     
>     
>     if (NodeUtil.isExprCall(parent)) {
>       parent.getParent().replaceChild(parent, new Node(Token.EMPTY));
>     } else {
>       Node srcLocation = call;
>       parent.replaceChild(call, NodeUtil.newUndefinedNode(srcLocation));
>     }
>     compiler.reportCodeChange();
>   }
> 
>   
> 
> 
> 
>   private boolean argsMayHaveSideEffects(Node call) {
>     for (Node currentChild = call.getFirstChild().getNext();
>          currentChild != null;
>          currentChild = currentChild.getNext()) {
>       if (NodeUtil.mayHaveSideEffects(currentChild)) {
>         return true;
>       }
>     }
> 
>     return false;
>   }
> 
>   
> 
> 
>   static final MethodCompilerPass.SignatureStore DUMMY_SIGNATURE_STORE =
>       new MethodCompilerPass.SignatureStore() {
>         @Override
>         public void addSignature(
>             String functionName, Node functionNode, String sourceFile) {
>         }
> 
>         @Override
>         public void removeSignature(String functionName) {
>         }
> 
>         @Override
>         public void reset() {
>         }
>       };
> 
>   @Override
>   SignatureStore getSignatureStore() {
>     return DUMMY_SIGNATURE_STORE;
>   }
> }
