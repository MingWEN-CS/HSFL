19a20
> import com.google.common.flags.DocLevel;
21a23
> import com.google.common.flags.Flags;
22a25
> import com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig;
27a31
> import java.util.logging.Level;
59a64,214
>   @FlagSpec(help = "Prints out the parse tree and exits",
>       docLevel = DocLevel.SECRET)
>   static final Flag<Boolean> FLAG_print_tree = Flag.value(false);
> 
>   @FlagSpec(help = "Runs the compile job many times, then prints out the " +
>       "best phase ordering from this run",
>       docLevel = DocLevel.SECRET)
>   static final Flag<Boolean> FLAG_compute_phase_ordering =
>       Flag.value(false);
> 
>   @FlagSpec(help = "Prints a dot file describing the internal abstract syntax"
>       + " tree and exits",
>       docLevel = DocLevel.SECRET)
>   static final Flag<Boolean> FLAG_print_ast = Flag.value(false);
> 
>   @FlagSpec(help = "Prints a dot file describing the passes that will get run"
>       + " and exits",
>       docLevel = DocLevel.SECRET)
>   static final Flag<Boolean> FLAG_print_pass_graph = Flag.value(false);
> 
>   @FlagSpec(help = "Turns on extra sanity checks", altName = "dev_mode",
>       docLevel = DocLevel.SECRET)
>   static final Flag<CompilerOptions.DevMode> FLAG_jscomp_dev_mode =
>       Flag.value(CompilerOptions.DevMode.OFF);
> 
>   
>   @FlagSpec(help = "The logging level (standard java.util.logging.Level"
>       + " values) for Compiler progress. Does not control errors or"
>       + " warnings for the JavaScript code under compilation",
>       docLevel = DocLevel.SECRET)
>   public static final Flag<String> FLAG_logging_level =
>       Flag.value(Level.WARNING.getName());
> 
>   @FlagSpec(help = "The file containing javascript externs. You may specify"
>       + " multiple")
>   public static final Flag<List<String>> FLAG_externs = Flag.stringCollector();
> 
>   @FlagSpec(help = "The javascript filename. You may specify multiple")
>   static final Flag<List<String>> FLAG_js = Flag.stringCollector();
> 
>   @FlagSpec(help = "Primary output filename. If not specified, output is " +
>             "written to stdout")
>   static final Flag<String> FLAG_js_output_file = Flag.value("");
> 
>   @FlagSpec(help = "A javascript module specification. The format is "
>       + "<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be "
>       + "unique. Each dep is the name of a module that this module "
>       + "depends on. Modules must be listed in dependency order, and js "
>       + "source files must be listed in the corresponding order. Where "
>       + "--module flags occur in relation to --js flags is unimportant")
>   static final Flag<List<String>> FLAG_module = Flag.stringCollector();
> 
>   @FlagSpec(help = "File containing the serialized version of the variable "
>       + "renaming map produced by a previous compilation")
>   static final Flag<String> FLAG_variable_map_input_file =
>       Flag.value("");
> 
>   @FlagSpec(help = "File containing the serialized version of the property "
>       + "renaming map produced by a previous compilation",
>       docLevel = DocLevel.SECRET)
>   static final Flag<String> FLAG_property_map_input_file =
>       Flag.value("");
> 
>   @FlagSpec(help = "File where the serialized version of the variable "
>       + "renaming map produced should be saved",
>       docLevel = DocLevel.SECRET)
>   static final Flag<String> FLAG_variable_map_output_file =
>       Flag.value("");
> 
>   @FlagSpec(help = "If true, variable renaming and property renaming map "
>       + "files will be produced as {binary name}_vars_map.out and "
>       + "{binary name}_props_map.out. Note that this flag cannot be used "
>       + "in conjunction with either variable_map_output_file or "
>       + "property_map_output_file",
>       docLevel = DocLevel.SECRET)
>   static final Flag<Boolean> FLAG_create_name_map_files =
>       Flag.value(false);
> 
>   @FlagSpec(help = "File where the serialized version of the property "
>       + "renaming map produced should be saved")
>   static final Flag<String> FLAG_property_map_output_file =
>       Flag.value("");
> 
>   @FlagSpec(help = "Check source validity but do not enforce Closure style "
>       + "rules and conventions")
>   static final Flag<Boolean> FLAG_third_party = Flag.value(false);
> 
> 
>   @FlagSpec(help = "Controls how detailed the compilation summary is. Values:"
>       + " 0 (never print summary), 1 (print summary only if there are "
>       + "errors or warnings), 2 (print summary if type checking is on, "
>       + "see --check_types), 3 (always print summary). The default level "
>       + "is 1")
>   static final Flag<Integer> FLAG_summary_detail_level = Flag.value(1);
> 
>   @FlagSpec(help = "Interpolate output into this string at the place denoted"
>       + " by the marker token %output%. See --output_wrapper_marker")
>   static final Flag<String> FLAG_output_wrapper = Flag.value("");
> 
>   @FlagSpec(help = "Use this token as output marker in the value of"
>       + " --output_wrapper")
>   static final Flag<String> FLAG_output_wrapper_marker =
>       Flag.value("%output%");
> 
>   @FlagSpec(help = "An output wrapper for a javascript module (optional). "
>       + "The format is <name>:<wrapper>. The module name must correspond "
>       + "with a module specified using --module. The wrapper must "
>       + "contain %s as the code placeholder")
>   static final Flag<List<String>> FLAG_module_wrapper =
>       Flag.stringCollector();
> 
>   @FlagSpec(help = "Prefix for filenames of compiled js modules. "
>       + "<module-name>.js will be appended to this prefix. Directories "
>       + "will be created as needed. Use with --module")
>   static final Flag<String> FLAG_module_output_path_prefix =
>       Flag.value("./");
> 
>   @FlagSpec(help = "If specified, a source map file mapping the generated " +
>             "source files back to the original source file will be " +
>             "output to the specified path. The %outname% placeholder will " +
>             "expand to the name of the output file that the source map " +
>             "corresponds to.")
>   static final Flag<String> FLAG_create_source_map =
>       Flag.value("");
> 
>   @FlagSpec(help = "Make the named class of warnings an error. Options:" +
>       DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)
>   static final Flag<List<String>> FLAG_jscomp_error =
>       Flag.stringCollector();
> 
>   @FlagSpec(help = "Make the named class of warnings a normal warning. " +
>                 "Options:" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)
>   static final Flag<List<String>> FLAG_jscomp_warning =
>       Flag.stringCollector();
> 
>   @FlagSpec(help = "Turn off the named class of warnings. Options:" +
>       DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)
>   static final Flag<List<String>> FLAG_jscomp_off =
>       Flag.stringCollector();
> 
>   @FlagSpec(altName = "D",
>       help = "Override the value of a variable annotated @define. " +
>       "The format is <name>[=<val>], where <name> is the name of a @define " +
>       "variable and <val> is a boolean, number, or a single-quoted string " +
>       "that contains no single quotes. If [=<val>] is omitted, " +
>       "the variable is marked true")
>   static final Flag<List<String>> FLAG_define = Flag.stringCollector();
> 
>   @FlagSpec(help = "Input charset for all files.")
>   static final Flag<String> FLAG_charset = Flag.value("");
> 
116c271
<     super(args);
---
>     super(readConfigFromFlags(args));
120c275,307
<     super(args, out, err);
---
>     super(readConfigFromFlags(args), out, err);
>   }
> 
>   private static CommandLineConfig readConfigFromFlags(String[] args) {
>     Flags.parse(args);
>     return new CommandLineConfig()
>         .setPrintTree(FLAG_print_tree.get())
>         .setComputePhaseOrdering(FLAG_compute_phase_ordering.get())
>         .setPrintAst(FLAG_print_ast.get())
>         .setPrintPassGraph(FLAG_print_pass_graph.get())
>         .setJscompDevMode(FLAG_jscomp_dev_mode.get())
>         .setLoggingLevel(FLAG_logging_level.get())
>         .setExterns(FLAG_externs.get())
>         .setJs(FLAG_js.get())
>         .setJsOutputFile(FLAG_js_output_file.get())
>         .setModule(FLAG_module.get())
>         .setVariableMapInputFile(FLAG_variable_map_input_file.get())
>         .setPropertyMapInputFile(FLAG_property_map_input_file.get())
>         .setVariableMapOutputFile(FLAG_variable_map_output_file.get())
>         .setCreateNameMapFiles(FLAG_create_name_map_files.get())
>         .setPropertyMapOutputFile(FLAG_property_map_output_file.get())
>         .setThirdParty(FLAG_third_party.get())
>         .setSummaryDetailLevel(FLAG_summary_detail_level.get())
>         .setOutputWrapper(FLAG_output_wrapper.get())
>         .setOutputWrapperMarker(FLAG_output_wrapper_marker.get())
>         .setModuleWrapper(FLAG_module_wrapper.get())
>         .setModuleOutputPathPrefix(FLAG_module_output_path_prefix.get())
>         .setCreateSourceMap(FLAG_create_source_map.get())
>         .setJscompError(FLAG_jscomp_error.get())
>         .setJscompWarning(FLAG_jscomp_warning.get())
>         .setJscompOff(FLAG_jscomp_off.get())
>         .setDefine(FLAG_define.get())
>         .setCharset(FLAG_charset.get());
