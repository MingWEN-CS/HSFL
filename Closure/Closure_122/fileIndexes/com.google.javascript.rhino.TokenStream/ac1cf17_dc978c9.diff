48,50d47
< import java.io.IOException;
< import java.io.Reader;
< 
68,111c65
<     private final static int
<         EOF_CHAR = -1;
< 
<     public TokenStream(Parser parser, Reader sourceReader, String sourceString,
<                 int lineno)
<     {
<         this.parser = parser;
<         this.lineno = lineno;
<         if (sourceReader != null) {
<             if (sourceString != null) Kit.codeBug();
<             this.sourceReader = sourceReader;
<             this.sourceBuffer = new char[512];
<             this.sourceEnd = 0;
<         } else {
<             if (sourceString == null) Kit.codeBug();
<             this.sourceString = sourceString;
<             this.sourceEnd = sourceString.length();
<         }
<         this.sourceCursor = 0;
<     }
< 
<     
< 
< 
< 
<     String tokenToString(int token)
<     {
<         if (Token.shouldPrintTrees()) {
<             String name = Token.name(token);
< 
<             switch (token) {
<                 case Token.STRING:
<                 case Token.REGEXP:
<                 case Token.NAME:
<                     return name + " `" + this.string + "'";
< 
<                 case Token.NUMBER:
<                     return "NUMBER " + this.number;
<             }
< 
<             return name;
<         }
<         return "";
<     }
---
>     private final static int EOF_CHAR = -1;
113,114c67
<     public static boolean isKeyword(String s)
<     {
---
>     public static boolean isKeyword(String s) {
118,119c71
<     private static int stringToKeyword(String name)
<     {
---
>     private static int stringToKeyword(String name) {
341,1072c293
<     protected final int getLineno() { return lineno; }
< 
<     protected final int getCharno() { return charno; }
< 
<     final String getString() { return string; }
< 
<     final double getNumber() { return number; }
< 
<     final boolean eof() { return hitEOF; }
< 
<     public final int getToken() throws IOException
<     {
<         tokenno++;
< 
<         
<         if (this.pushbackToken != Token.EOF) {
<             int result = this.pushbackToken;
<             this.pushbackToken = Token.EOF;
<             return result;
<         }
<         int c;
< 
<     retry:
<         for (;;) {
<             
<             for (;;) {
<                 charno = -1;
<                 c = getChar();
<                 if (c == EOF_CHAR) {
<                     return Token.EOF;
<                 } else if (c == '\n') {
<                     dirtyLine = false;
<                     return Token.EOL;
<                 } else if (!isJSSpace(c)) {
<                     if (c != '-') {
<                         dirtyLine = true;
<                     }
<                     break;
<                 }
<             }
< 
<             if (c == '@') return Token.XMLATTR;
< 
<             
<             
<             boolean identifierStart;
<             boolean isUnicodeEscapeStart = false;
<             if (c == '\\') {
<                 c = getChar();
<                 if (c == 'u') {
<                     identifierStart = true;
<                     isUnicodeEscapeStart = true;
<                     stringBufferTop = 0;
<                 } else {
<                     identifierStart = false;
<                     ungetChar(c);
<                     c = '\\';
<                 }
<             } else {
<                 identifierStart = Character.isJavaIdentifierStart((char)c);
<                 if (identifierStart) {
<                     stringBufferTop = 0;
<                     addToString(c);
<                 }
<             }
< 
<             if (identifierStart) {
<                 boolean containsEscape = isUnicodeEscapeStart;
<                 for (;;) {
<                     if (isUnicodeEscapeStart) {
<                         
<                         
<                         
<                         
<                         
<                         
<                         int escapeVal = 0;
<                         for (int i = 0; i != 4; ++i) {
<                             c = getChar();
<                             escapeVal = Kit.xDigitToInt(c, escapeVal);
<                             
<                             if (escapeVal < 0) { break; }
<                         }
<                         if (escapeVal < 0) {
<                             parser.addError("msg.invalid.escape");
<                             return Token.ERROR;
<                         }
<                         addToString(escapeVal);
<                         isUnicodeEscapeStart = false;
<                     } else {
<                         c = getChar();
<                         if (c == '\\') {
<                             c = getChar();
<                             if (c == 'u') {
<                                 isUnicodeEscapeStart = true;
<                                 containsEscape = true;
<                             } else {
<                                 parser.addError("msg.illegal.character");
<                                 return Token.ERROR;
<                             }
<                         } else {
<                             if (c == EOF_CHAR
<                                 || !Character.isJavaIdentifierPart((char)c))
<                             {
<                                 break;
<                             }
<                             addToString(c);
<                         }
<                     }
<                 }
<                 ungetChar(c);
< 
<                    String str = getStringFromBuffer();
<                 if (!containsEscape) {
<                     
<                     
< 
<                     
<                     int result = stringToKeyword(str);
<                     if (result != Token.EOF) {
<                         if (result != Token.RESERVED) {
<                             return result;
<                         } else if (!parser.compilerEnv.
<                                         isReservedKeywordAsIdentifier())
<                         {
<                             return result;
<                         } else {
<                             
<                             
<                             
<                             parser.addWarning("msg.reserved.keyword", str);
<                         }
<                     }
<                 }
<                 this.string = (String)allStrings.intern(str);
<                 return Token.NAME;
<             }
< 
<             
<             if (isDigit(c) || (c == '.' && isDigit(peekChar()))) {
< 
<                 stringBufferTop = 0;
<                 int base = 10;
< 
<                 if (c == '0') {
<                     c = getChar();
<                     if (c == 'x' || c == 'X') {
<                         base = 16;
<                         c = getChar();
<                     } else if (isDigit(c)) {
<                         base = 8;
<                     } else {
<                         addToString('0');
<                     }
<                 }
< 
<                 if (base == 16) {
<                     while (0 <= Kit.xDigitToInt(c, 0)) {
<                         addToString(c);
<                         c = getChar();
<                     }
<                 } else {
<                     while ('0' <= c && c <= '9') {
<                         
< 
< 
< 
< 
< 
<                         if (base == 8 && c >= '8') {
<                             parser.addWarning("msg.bad.octal.literal",
<                                               c == '8' ? "8" : "9");
<                             base = 10;
<                         }
<                         addToString(c);
<                         c = getChar();
<                     }
<                 }
< 
<                 boolean isInteger = true;
< 
<                 if (base == 10 && (c == '.' || c == 'e' || c == 'E')) {
<                     isInteger = false;
<                     if (c == '.') {
<                         do {
<                             addToString(c);
<                             c = getChar();
<                         } while (isDigit(c));
<                     }
<                     if (c == 'e' || c == 'E') {
<                         addToString(c);
<                         c = getChar();
<                         if (c == '+' || c == '-') {
<                             addToString(c);
<                             c = getChar();
<                         }
<                         if (!isDigit(c)) {
<                             parser.addError("msg.missing.exponent");
<                             return Token.ERROR;
<                         }
<                         do {
<                             addToString(c);
<                             c = getChar();
<                         } while (isDigit(c));
<                     }
<                 }
<                 ungetChar(c);
<                 String numString = getStringFromBuffer();
< 
<                 double dval;
<                 if (base == 10 && !isInteger) {
<                     try {
<                         
<                         dval = Double.valueOf(numString).doubleValue();
<                     }
<                     catch (NumberFormatException ex) {
<                         parser.addError("msg.caught.nfe");
<                         return Token.ERROR;
<                     }
<                 } else {
<                     dval = ScriptRuntime.stringToNumber(numString, 0, base);
<                 }
< 
<                 this.number = dval;
<                 return Token.NUMBER;
<             }
< 
<             
<             if (c == '"' || c == '\'') {
<                 
<                 
<                 
<                 
< 
<                 int quoteChar = c;
<                 stringBufferTop = 0;
< 
<                 c = getChar();
<             strLoop: while (c != quoteChar) {
<                     if (c == '\n' || c == EOF_CHAR) {
<                         ungetChar(c);
<                         parser.addError("msg.unterminated.string.lit");
<                         return Token.ERROR;
<                     }
< 
<                     if (c == '\\') {
<                         
<                         int escapeVal;
< 
<                         c = getChar();
<                         switch (c) {
<                         case 'b': c = '\b'; break;
<                         case 'f': c = '\f'; break;
<                         case 'n': c = '\n'; break;
<                         case 'r': c = '\r'; break;
<                         case 't': c = '\t'; break;
< 
<                         
<                         
<                         case 'v': c = 0xb; break;
< 
<                         case 'u':
<                             
<                             
<                             
<                             int escapeStart = stringBufferTop;
<                             addToString('u');
<                             escapeVal = 0;
<                             for (int i = 0; i != 4; ++i) {
<                                 c = getChar();
<                                 escapeVal = Kit.xDigitToInt(c, escapeVal);
<                                 if (escapeVal < 0) {
<                                     continue strLoop;
<                                 }
<                                 addToString(c);
<                             }
<                             
<                             
<                             stringBufferTop = escapeStart;
<                             c = escapeVal;
<                             break;
<                         case 'x':
<                             
<                             
<                             c = getChar();
<                             escapeVal = Kit.xDigitToInt(c, 0);
<                             if (escapeVal < 0) {
<                                 addToString('x');
<                                 continue strLoop;
<                             } else {
<                                 int c1 = c;
<                                 c = getChar();
<                                 escapeVal = Kit.xDigitToInt(c, escapeVal);
<                                 if (escapeVal < 0) {
<                                     addToString('x');
<                                     addToString(c1);
<                                     continue strLoop;
<                                 } else {
<                                     
<                                     c = escapeVal;
<                                 }
<                             }
<                             break;
< 
<                         case '\n':
<                             
<                             
<                             c = getChar();
<                             continue strLoop;
< 
<                         default:
<                             if ('0' <= c && c < '8') {
<                                 int val = c - '0';
<                                 c = getChar();
<                                 if ('0' <= c && c < '8') {
<                                     val = 8 * val + c - '0';
<                                     c = getChar();
<                                     if ('0' <= c && c < '8' && val <= 037) {
<                                         
<                                         
<                                         val = 8 * val + c - '0';
<                                         c = getChar();
<                                     }
<                                 }
<                                 ungetChar(c);
<                                 c = val;
<                             }
<                         }
<                     }
<                     addToString(c);
<                     c = getChar();
<                 }
< 
<                 String str = getStringFromBuffer();
<                 this.string = (String)allStrings.intern(str);
<                 return Token.STRING;
<             }
< 
<             switch (c) {
<             case ';': return Token.SEMI;
<             case '[': return Token.LB;
<             case ']': return Token.RB;
<             case '{': return Token.LC;
<             case '}': return Token.RC;
<             case '(': return Token.LP;
<             case ')': return Token.RP;
<             case ',': return Token.COMMA;
<             case '?': return Token.HOOK;
<             case ':':
<                 if (matchChar(':')) {
<                     return Token.COLONCOLON;
<                 } else {
<                     return Token.COLON;
<                 }
<             case '.':
<                 if (matchChar('.')) {
<                     return Token.DOTDOT;
<                 } else if (matchChar('(')) {
<                     return Token.DOTQUERY;
<                 } else {
<                     return Token.DOT;
<                 }
< 
<             case '|':
<                 if (matchChar('|')) {
<                     return Token.OR;
<                 } else if (matchChar('=')) {
<                     return Token.ASSIGN_BITOR;
<                 } else {
<                     return Token.BITOR;
<                 }
< 
<             case '^':
<                 if (matchChar('=')) {
<                     return Token.ASSIGN_BITXOR;
<                 } else {
<                     return Token.BITXOR;
<                 }
< 
<             case '&':
<                 if (matchChar('&')) {
<                     return Token.AND;
<                 } else if (matchChar('=')) {
<                     return Token.ASSIGN_BITAND;
<                 } else {
<                     return Token.BITAND;
<                 }
< 
<             case '=':
<                 if (matchChar('=')) {
<                     if (matchChar('='))
<                         return Token.SHEQ;
<                     else
<                         return Token.EQ;
<                 } else {
<                     return Token.ASSIGN;
<                 }
< 
<             case '!':
<                 if (matchChar('=')) {
<                     if (matchChar('='))
<                         return Token.SHNE;
<                     else
<                         return Token.NE;
<                 } else {
<                     return Token.NOT;
<                 }
< 
<             case '<':
<                 
<                 if (matchChar('!')) {
<                     if (matchChar('-')) {
<                         if (matchChar('-')) {
<                             skipLine();
<                             continue retry;
<                         }
<                         ungetChar('-');
<                     }
<                     ungetChar('!');
<                 }
<                 if (matchChar('<')) {
<                     if (matchChar('=')) {
<                         return Token.ASSIGN_LSH;
<                     } else {
<                         return Token.LSH;
<                     }
<                 } else {
<                     if (matchChar('=')) {
<                         return Token.LE;
<                     } else {
<                         return Token.LT;
<                     }
<                 }
< 
<             case '>':
<                 if (matchChar('>')) {
<                     if (matchChar('>')) {
<                         if (matchChar('=')) {
<                             return Token.ASSIGN_URSH;
<                         } else {
<                             return Token.URSH;
<                         }
<                     } else {
<                         if (matchChar('=')) {
<                             return Token.ASSIGN_RSH;
<                         } else {
<                             return Token.RSH;
<                         }
<                     }
<                 } else {
<                     if (matchChar('=')) {
<                         return Token.GE;
<                     } else {
<                         return Token.GT;
<                     }
<                 }
< 
<             case '*':
<                 if (matchChar('=')) {
<                     return Token.ASSIGN_MUL;
<                 } else {
<                     return Token.MUL;
<                 }
< 
<             case '/':
<                 
<                 if (matchChar('/')) {
<                     skipLine();
<                     continue retry;
<                 }
<                 if (matchChar('*')) {
<                     while ((c = getChar()) != EOF_CHAR &&
<                            !(c == '*' && matchChar('/'))) {
<                       
<                     }
<                     if (c == EOF_CHAR) {
<                         parser.addError("msg.unterminated.comment");
<                         return Token.ERROR;
<                     }
<                     continue retry;
<                 }
< 
<                 if (matchChar('=')) {
<                     return Token.ASSIGN_DIV;
<                 } else {
<                     return Token.DIV;
<                 }
< 
<             case '%':
<                 if (matchChar('=')) {
<                     return Token.ASSIGN_MOD;
<                 } else {
<                     return Token.MOD;
<                 }
< 
<             case '~':
<                 return Token.BITNOT;
< 
<             case '+':
<                 if (matchChar('=')) {
<                     return Token.ASSIGN_ADD;
<                 } else if (matchChar('+')) {
<                     return Token.INC;
<                 } else {
<                     return Token.ADD;
<                 }
< 
<             case '-':
<                 if (matchChar('=')) {
<                     c = Token.ASSIGN_SUB;
<                 } else if (matchChar('-')) {
<                     if (!dirtyLine) {
<                         
<                         
<                         if (matchChar('>')) {
<                             skipLine();
<                             continue retry;
<                         }
<                     }
<                     c = Token.DEC;
<                 } else {
<                     c = Token.SUB;
<                 }
<                 dirtyLine = true;
<                 return c;
< 
<             default:
<                 parser.addError("msg.illegal.character");
<                 return Token.ERROR;
<             }
<         }
<     }
< 
<     
< 
< 
<     @SuppressWarnings("fallthrough")
<     final int getJSDocToken() throws IOException {
<       int c;
<       stringBufferTop = 0;
<       for (;;) {
<         
<         for (;;) {
<           charno = -1;
<           c = getChar();
<           if (c == EOF_CHAR) {
<             return Token.EOF;
<           } else if (c == '\n') {
<             return Token.EOL;
<           } else if (!isJSSpace(c)) {
<             break;
<           }
<         }
< 
<         switch (c) {
<           
<           case '@':
<             do {
<               c = getChar();
<               if (isAlpha(c)) {
<                 addToString(c);
<               } else {
<                 ungetChar(c);
<                 this.string = getStringFromBuffer();
<                 stringBufferTop = 0;
<                 return Token.ANNOTATION;
<               }
<             } while (true);
< 
<           case '*':
<             if (matchChar('/')) {
<               return Token.EOC;
<             } else {
<               return Token.STAR;
<             }
< 
<           case ',':
<             return Token.COMMA;
< 
<           case '>':
<             return Token.GT;
< 
<           case '(':
<             return Token.LP;
< 
<           case ')':
<             return Token.RP;
< 
<           case '{':
<             return Token.LC;
< 
<           case '}':
<             return Token.RC;
< 
<           case '[':
<             return Token.LB;
< 
<           case ']':
<             return Token.RB;
< 
<           case '?':
<             return Token.QMARK;
< 
<           case '!':
<             return Token.BANG;
< 
<           case ':':
<             return Token.COLON;
< 
<           case '=':
<             return Token.EQUALS;
< 
<           case '|':
<             matchChar('|');
<             return Token.PIPE;
< 
<           case '.':
<             c = getChar();
<             if (c == '<') {
<               return Token.LT;
<             } else {
<               if (c == '.') {
<                 c = getChar();
<                 if (c == '.') {
<                   return Token.ELLIPSIS;
<                 } else {
<                   addToString('.');
<                 }
<               }
<               
<               ungetBuffer[ungetCursor++] = c;
<               c = '.';
<             }
<             
< 
<           default: {
<             
<             
<             int c1 = c;
<             addToString(c);
<             int c2 = getChar();
<             if (!isJSDocString(c2)) {
<               ungetChar(c2);
<               this.string = getStringFromBuffer();
<               stringBufferTop = 0;
<               return Token.STRING;
<             } else {
<               do {
<                 c1 = c2;
<                 c2 = getChar();
<                 if (c1 == '.' && c2 == '<') {
<                   ungetChar(c2);
<                   ungetChar(c1);
<                   this.string = getStringFromBuffer();
<                   stringBufferTop = 0;
<                   return Token.STRING;
<                 } else {
<                   if (isJSDocString(c2)) {
<                     addToString(c1);
<                   } else {
<                     ungetChar(c2);
<                     addToString(c1);
<                     this.string = getStringFromBuffer();
<                     stringBufferTop = 0;
<                     return Token.STRING;
<                   }
<                 }
<               } while (true);
<             }
<           }
<         }
<       }
<     }
< 
<     
< 
< 
< 
<     @SuppressWarnings("fallthrough")
<     String getRemainingJSDocLine() throws IOException {
<       int c;
<       for (;;) {
<         c = getChar();
<         switch (c) {
<           case '*':
<             if (peekChar() != '/') {
<               addToString(c);
<               break;
<             }
<             
<           case EOF_CHAR:
<           case '\n':
<             ungetChar(c);
<             this.string = getStringFromBuffer();
<             stringBufferTop = 0;
<             return this.string;
< 
<           default:
<             addToString(c);
<             break;
<         }
<       }
<     }
< 
<     private boolean isJSDocString(int c) {
<       switch (c) {
<         case '@':
<         case '*':
<         case ',':
<         case '>':
<         case ':':
<         case '(':
<         case ')':
<         case '{':
<         case '}':
<         case '[':
<         case ']':
<         case '?':
<         case '!':
<         case '|':
<         case '=':
<         case EOF_CHAR:
<         case '\n':
<           return false;
< 
<         default:
<           return !isJSSpace(c);
<       }
<     }
< 
<     private static boolean isAlpha(int c)
<     {
---
>     private static boolean isAlpha(int c) {
1081,1082c302
<     static boolean isDigit(int c)
<     {
---
>     static boolean isDigit(int c) {
1094,1095c314
<     static boolean isJSSpace(int c)
<     {
---
>     static boolean isJSSpace(int c) {
1104,1105c323
<     private static boolean isJSFormatChar(int c)
<     {
---
>     private static boolean isJSFormatChar(int c) {
1108,1713d325
< 
<     
< 
< 
< 
<     JSDocInfo getAndResetJSDocInfo() {
<       return null;
<     }
< 
<     
< 
< 
< 
<     JSDocInfo getFileOverviewJSDocInfo() {
<       return null;
<     }
< 
<     
< 
< 
< 
<     boolean isPopulated() {
<       return false;
<     }
< 
<     
< 
< 
<     void readRegExp(int startToken)
<         throws IOException
<     {
<         stringBufferTop = 0;
<         if (startToken == Token.ASSIGN_DIV) {
<             
<             addToString('=');
<         } else {
<             if (startToken != Token.DIV) Kit.codeBug();
<         }
< 
<         boolean inCharSet = false;  
<         int c;
<         while ((c = getChar()) != '/' || inCharSet) {
<             if (c == '\n' || c == EOF_CHAR) {
<                 ungetChar(c);
<                 throw parser.reportError("msg.unterminated.re.lit");
<             }
<             if (c == '\\') {
<                 addToString(c);
<                 c = getChar();
<             } else if (c == '[') {
<                 inCharSet = true;
<             } else if (c == ']') {
<                 inCharSet = false;
<             }
< 
<             addToString(c);
<         }
<         int reEnd = stringBufferTop;
< 
<         while (true) {
<             if (matchChar('g'))
<                 addToString('g');
<             else if (matchChar('i'))
<                 addToString('i');
<             else if (matchChar('m'))
<                 addToString('m');
<             else
<                 break;
<         }
< 
<         if (isAlpha(peekChar())) {
<             throw parser.reportError("msg.invalid.re.flag");
<         }
< 
<         this.string = new String(stringBuffer, 0, reEnd);
<         this.regExpFlags = new String(stringBuffer, reEnd,
<                                       stringBufferTop - reEnd);
<     }
< 
<     boolean isXMLAttribute()
<     {
<         return xmlIsAttribute;
<     }
< 
<     int getFirstXMLToken() throws IOException
<     {
<         xmlOpenTagsCount = 0;
<         xmlIsAttribute = false;
<         xmlIsTagContent = false;
<         ungetChar('<');
<         return getNextXMLToken();
<     }
< 
<     int getNextXMLToken() throws IOException
<     {
<         stringBufferTop = 0; 
< 
<         for (int c = getChar(); c != EOF_CHAR; c = getChar()) {
<             if (xmlIsTagContent) {
<                 switch (c) {
<                 case '>':
<                     addToString(c);
<                     xmlIsTagContent = false;
<                     xmlIsAttribute = false;
<                     break;
<                 case '/':
<                     addToString(c);
<                     if (peekChar() == '>') {
<                         c = getChar();
<                         addToString(c);
<                         xmlIsTagContent = false;
<                         xmlOpenTagsCount--;
<                     }
<                     break;
<                 case '{':
<                     ungetChar(c);
<                     this.string = getStringFromBuffer();
<                     return Token.XML;
<                 case '\'':
<                 case '"':
<                     addToString(c);
<                     if (!readQuotedString(c)) return Token.ERROR;
<                     break;
<                 case '=':
<                     addToString(c);
<                     xmlIsAttribute = true;
<                     break;
<                 case ' ':
<                 case '\t':
<                 case '\r':
<                 case '\n':
<                     addToString(c);
<                     break;
<                 default:
<                     addToString(c);
<                     xmlIsAttribute = false;
<                     break;
<                 }
< 
<                 if (!xmlIsTagContent && xmlOpenTagsCount == 0) {
<                     this.string = getStringFromBuffer();
<                     return Token.XMLEND;
<                 }
<             } else {
<                 switch (c) {
<                 case '<':
<                     addToString(c);
<                     c = peekChar();
<                     switch (c) {
<                     case '!':
<                         c = getChar(); 
<                         addToString(c);
<                         c = peekChar();
<                         switch (c) {
<                         case '-':
<                             c = getChar(); 
<                             addToString(c);
<                             c = getChar();
<                             if (c == '-') {
<                                 addToString(c);
<                                 if(!readXmlComment()) return Token.ERROR;
<                             } else {
<                                 
<                                 stringBufferTop = 0;
<                                 this.string = null;
<                                 parser.addError("msg.XML.bad.form");
<                                 return Token.ERROR;
<                             }
<                             break;
<                         case '[':
<                             c = getChar(); 
<                             addToString(c);
<                             if (getChar() == 'C' &&
<                                 getChar() == 'D' &&
<                                 getChar() == 'A' &&
<                                 getChar() == 'T' &&
<                                 getChar() == 'A' &&
<                                 getChar() == '[')
<                             {
<                                 addToString('C');
<                                 addToString('D');
<                                 addToString('A');
<                                 addToString('T');
<                                 addToString('A');
<                                 addToString('[');
<                                 if (!readCDATA()) return Token.ERROR;
< 
<                             } else {
<                                 
<                                 stringBufferTop = 0;
<                                 this.string = null;
<                                 parser.addError("msg.XML.bad.form");
<                                 return Token.ERROR;
<                             }
<                             break;
<                         default:
<                             if(!readEntity()) return Token.ERROR;
<                             break;
<                         }
<                         break;
<                     case '?':
<                         c = getChar(); 
<                         addToString(c);
<                         if (!readPI()) return Token.ERROR;
<                         break;
<                     case '/':
<                         
<                         c = getChar(); 
<                         addToString(c);
<                         if (xmlOpenTagsCount == 0) {
<                             
<                             stringBufferTop = 0;
<                             this.string = null;
<                             parser.addError("msg.XML.bad.form");
<                             return Token.ERROR;
<                         }
<                         xmlIsTagContent = true;
<                         xmlOpenTagsCount--;
<                         break;
<                     default:
<                         
<                         xmlIsTagContent = true;
<                         xmlOpenTagsCount++;
<                         break;
<                     }
<                     break;
<                 case '{':
<                     ungetChar(c);
<                     this.string = getStringFromBuffer();
<                     return Token.XML;
<                 default:
<                     addToString(c);
<                     break;
<                 }
<             }
<         }
< 
<         stringBufferTop = 0; 
<         this.string = null;
<         parser.addError("msg.XML.bad.form");
<         return Token.ERROR;
<     }
< 
<     
< 
< 
<     private boolean readQuotedString(int quote) throws IOException
<     {
<         for (int c = getChar(); c != EOF_CHAR; c = getChar()) {
<             addToString(c);
<             if (c == quote) return true;
<         }
< 
<         stringBufferTop = 0; 
<         this.string = null;
<         parser.addError("msg.XML.bad.form");
<         return false;
<     }
< 
<     
< 
< 
<     private boolean readXmlComment() throws IOException
<     {
<         for (int c = getChar(); c != EOF_CHAR;) {
<             addToString(c);
<             if (c == '-' && peekChar() == '-') {
<                 c = getChar();
<                 addToString(c);
<                 if (peekChar() == '>') {
<                     c = getChar(); 
<                     addToString(c);
<                     return true;
<                 } else {
<                     continue;
<                 }
<             }
<             c = getChar();
<         }
< 
<         stringBufferTop = 0; 
<         this.string = null;
<         parser.addError("msg.XML.bad.form");
<         return false;
<     }
< 
<     
< 
< 
<     private boolean readCDATA() throws IOException
<     {
<         for (int c = getChar(); c != EOF_CHAR;) {
<             addToString(c);
<             if (c == ']' && peekChar() == ']') {
<                 c = getChar();
<                 addToString(c);
<                 if (peekChar() == '>') {
<                     c = getChar(); 
<                     addToString(c);
<                     return true;
<                 } else {
<                     continue;
<                 }
<             }
<             c = getChar();
<         }
< 
<         stringBufferTop = 0; 
<         this.string = null;
<         parser.addError("msg.XML.bad.form");
<         return false;
<     }
< 
<     
< 
< 
<     private boolean readEntity() throws IOException
<     {
<         int declTags = 1;
<         for (int c = getChar(); c != EOF_CHAR; c = getChar()) {
<             addToString(c);
<             switch (c) {
<             case '<':
<                 declTags++;
<                 break;
<             case '>':
<                 declTags--;
<                 if (declTags == 0) return true;
<                 break;
<             }
<         }
< 
<         stringBufferTop = 0; 
<         this.string = null;
<         parser.addError("msg.XML.bad.form");
<         return false;
<     }
< 
<     
< 
< 
<     private boolean readPI() throws IOException
<     {
<         for (int c = getChar(); c != EOF_CHAR; c = getChar()) {
<             addToString(c);
<             if (c == '?' && peekChar() == '>') {
<                 c = getChar(); 
<                 addToString(c);
<                 return true;
<             }
<         }
< 
<         stringBufferTop = 0; 
<         this.string = null;
<         parser.addError("msg.XML.bad.form");
<         return false;
<     }
< 
<     private String getStringFromBuffer()
<     {
<         return new String(stringBuffer, 0, stringBufferTop);
<     }
< 
<     private void addToString(int c)
<     {
<         int N = stringBufferTop;
<         if (N == stringBuffer.length) {
<             char[] tmp = new char[stringBuffer.length * 2];
<             System.arraycopy(stringBuffer, 0, tmp, 0, N);
<             stringBuffer = tmp;
<         }
<         stringBuffer[N] = (char)c;
<         stringBufferTop = N + 1;
<     }
< 
<     public int getTokenno() { return tokenno; }
< 
<     protected void ungetChar(int c)
<     {
<         
<         if (ungetCursor != 0 && ungetBuffer[ungetCursor - 1] == '\n')
<             Kit.codeBug();
<         ungetBuffer[ungetCursor++] = c;
<     }
< 
<     private boolean matchChar(int test) throws IOException
<     {
<         int c = getChar();
<         if (c == test) {
<             return true;
<         } else {
<             ungetChar(c);
<             return false;
<         }
<     }
< 
<     private int peekChar() throws IOException
<     {
<         int c = getChar();
<         ungetChar(c);
<         return c;
<     }
< 
<     protected int getChar() throws IOException
<     {
<         if (ungetCursor != 0) {
<             --ungetCursor;
<             if (charno == -1) {
<               charno = getOffset();
<             }
<             return ungetBuffer[ungetCursor];
<         }
< 
<         for(;;) {
<             int c;
<             if (sourceString != null) {
<                 if (sourceCursor == sourceEnd) {
<                     hitEOF = true;
<                     if (charno == -1) {
<                       charno = getOffset();
<                     }
<                     return EOF_CHAR;
<                 }
<                 c = sourceString.charAt(sourceCursor++);
<             } else {
<                 if (sourceCursor == sourceEnd) {
<                     if (!fillSourceBuffer()) {
<                         hitEOF = true;
<                         if (charno == -1) {
<                           charno = getOffset();
<                         }
<                         return EOF_CHAR;
<                     }
<                 }
<                 c = sourceBuffer[sourceCursor++];
<             }
< 
<             if (lineEndChar >= 0) {
<                 if (lineEndChar == '\r' && c == '\n') {
<                     lineEndChar = '\n';
<                     continue;
<                 }
<                 lineEndChar = -1;
<                 lineStart = sourceCursor - 1;
<                 lineno++;
<             }
< 
<             if (c <= 127) {
<                 if (c == '\n' || c == '\r') {
<                     lineEndChar = c;
<                     c = '\n';
<                 }
<             } else {
<                 if (isJSFormatChar(c)) {
<                     continue;
<                 }
<                 if (ScriptRuntime.isJSLineTerminator(c)) {
<                     lineEndChar = c;
<                     c = '\n';
<                 }
<             }
< 
<             if (charno == -1) {
<               charno = getOffset();
<             }
< 
<             return c;
<         }
<     }
< 
<     private void skipLine() throws IOException
<     {
<         
<         int c;
<         while ((c = getChar()) != EOF_CHAR && c != '\n') { }
<         ungetChar(c);
<     }
< 
<     final int getOffset()
<     {
<         return sourceCursor - lineStart - ungetCursor - 1;
<     }
< 
<     final String getLine()
<     {
<         if (sourceString != null) {
<             
<             int lineEnd = sourceCursor;
<             if (lineEndChar >= 0) {
<                 --lineEnd;
<             } else {
<                 for (; lineEnd != sourceEnd; ++lineEnd) {
<                     int c = sourceString.charAt(lineEnd);
<                     if (ScriptRuntime.isJSLineTerminator(c)) {
<                         break;
<                     }
<                 }
<             }
<             return sourceString.substring(lineStart, lineEnd);
<         } else {
<             
<             int lineLength = sourceCursor - lineStart;
<             if (lineEndChar >= 0) {
<                 --lineLength;
<             } else {
<                 
<                 for (;; ++lineLength) {
<                     int i = lineStart + lineLength;
<                     if (i == sourceEnd) {
<                         try {
<                             if (!fillSourceBuffer()) { break; }
<                         } catch (IOException ioe) {
<                             
<                             break;
<                         }
<                         
<                         
<                         i = lineStart + lineLength;
<                     }
<                     int c = sourceBuffer[i];
<                     if (ScriptRuntime.isJSLineTerminator(c)) {
<                         break;
<                     }
<                 }
<             }
<             return new String(sourceBuffer, lineStart, lineLength);
<         }
<     }
< 
<     private boolean fillSourceBuffer() throws IOException
<     {
<         if (sourceString != null) Kit.codeBug();
<         if (sourceEnd == sourceBuffer.length) {
<             if (lineStart != 0) {
<                 System.arraycopy(sourceBuffer, lineStart, sourceBuffer, 0,
<                                  sourceEnd - lineStart);
<                 sourceEnd -= lineStart;
<                 sourceCursor -= lineStart;
<                 lineStart = 0;
<             } else {
<                 char[] tmp = new char[sourceBuffer.length * 2];
<                 System.arraycopy(sourceBuffer, 0, tmp, 0, sourceEnd);
<                 sourceBuffer = tmp;
<             }
<         }
<         int n = sourceReader.read(sourceBuffer, sourceEnd,
<                                   sourceBuffer.length - sourceEnd);
<         if (n < 0) {
<             return false;
<         }
<         sourceEnd += n;
<         return true;
<     }
< 
<     
< 
< 
< 
< 
< 
<     public void setFileLevelJsDocBuilder(
<       Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {
<     }
< 
<     
<     private boolean dirtyLine;
< 
<     String regExpFlags;
< 
<     private int pushbackToken;
<     private int tokenno;
< 
<     
<     
<     
<     
<     private String string = "";
<     private double number;
< 
<     private char[] stringBuffer = new char[128];
<     private int stringBufferTop;
<     private ObjToIntMap allStrings = new ObjToIntMap(50);
< 
<     
<     private final int[] ungetBuffer = new int[3];
<     private int ungetCursor;
< 
<     private boolean hitEOF = false;
< 
<     private int lineStart = 0;
<     private int lineno;
<     private int charno = -1;
<     private int lineEndChar = -1;
< 
<     private String sourceString;
<     private Reader sourceReader;
<     private char[] sourceBuffer;
<     private int sourceEnd;
<     private int sourceCursor;
< 
<     
<     private boolean xmlIsAttribute;
<     private boolean xmlIsTagContent;
<     private int xmlOpenTagsCount;
< 
<     private Parser parser;
