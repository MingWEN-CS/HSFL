
















package org.apache.commons.math.random;

import java.io.Serializable;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.util.Collection;

import org.apache.commons.math.util.MathUtils;



























































public class RandomDataImpl implements RandomData, Serializable {

    
    private static final long serialVersionUID = -626730818244969716L;

    
    private RandomGenerator rand = null;

    
    private SecureRandom secRand = null;

    


    public RandomDataImpl() {
    }

    







    public RandomDataImpl(RandomGenerator rand) {
        super();
        this.rand = rand;
    }

    
















    public String nextHexString(int len) {
        if (len <= 0) {
            throw new IllegalArgumentException("length must be positive");
        }

        
        RandomGenerator ran = getRan();

        
        StringBuffer outBuffer = new StringBuffer();

        
        byte[] randomBytes = new byte[(len / 2) + 1];
        ran.nextBytes(randomBytes);

        
        for (int i = 0; i < randomBytes.length; i++) {
            Integer c = Integer.valueOf(randomBytes[i]);

            




            String hex = Integer.toHexString(c.intValue() + 128);

            
            if (hex.length() == 1) {
                hex = "0" + hex;
            }
            outBuffer.append(hex);
        }
        return outBuffer.toString().substring(0, len);
    }

    









    public int nextInt(int lower, int upper) {
        if (lower >= upper) {
            throw new IllegalArgumentException(
                    "upper bound must be > lower bound");
        }
        RandomGenerator rand = getRan();
        double r = rand.nextDouble();
        return (int) ((r * upper) + ((1.0 - r) * lower) + r);
    }

    









    public long nextLong(long lower, long upper) {
        if (lower >= upper) {
            throw new IllegalArgumentException(
                    "upper bound must be > lower bound");
        }
        RandomGenerator rand = getRan();
        double r = rand.nextDouble();
        return (long) ((r * upper) + ((1.0 - r) * lower) + r);
    }

    



















    public String nextSecureHexString(int len) {
        if (len <= 0) {
            throw new IllegalArgumentException("length must be positive");
        }

        
        SecureRandom secRan = getSecRan();
        MessageDigest alg = null;
        try {
            alg = MessageDigest.getInstance("SHA-1");
        } catch (NoSuchAlgorithmException ex) {
            return null; 
        }
        alg.reset();

        
        int numIter = (len / 40) + 1;

        StringBuffer outBuffer = new StringBuffer();
        for (int iter = 1; iter < numIter + 1; iter++) {
            byte[] randomBytes = new byte[40];
            secRan.nextBytes(randomBytes);
            alg.update(randomBytes);

            
            byte hash[] = alg.digest();

            
            for (int i = 0; i < hash.length; i++) {
                Integer c = Integer.valueOf(hash[i]);

                




                String hex = Integer.toHexString(c.intValue() + 128);

                
                if (hex.length() == 1) {
                    hex = "0" + hex;
                }
                outBuffer.append(hex);
            }
        }
        return outBuffer.toString().substring(0, len);
    }

    










    public int nextSecureInt(int lower, int upper) {
        if (lower >= upper) {
            throw new IllegalArgumentException(
                    "lower bound must be < upper bound");
        }
        SecureRandom sec = getSecRan();
        return lower + (int) (sec.nextDouble() * (upper - lower + 1));
    }

    










    public long nextSecureLong(long lower, long upper) {
        if (lower >= upper) {
            throw new IllegalArgumentException(
                    "lower bound must be < upper bound");
        }
        SecureRandom sec = getSecRan();
        return lower + (long) (sec.nextDouble() * (upper - lower + 1));
    }

    




























    public long nextPoisson(double mean) {
        if (mean <= 0) {
            throw new IllegalArgumentException("Poisson mean must be > 0");
        }

        RandomGenerator rand = getRan();

        double pivot = 6.0;
        if (mean < pivot) {
            double p = Math.exp(-mean);
            long n = 0;
            double r = 1.0d;
            double rnd = 1.0d;

            while (n < 1000 * mean) {
                rnd = rand.nextDouble();
                r = r * rnd;
                if (r >= p) {
                    n++;
                } else {
                    return n;
                }
            }
            return n;
        } else {
            double mu = Math.floor(mean);
            double delta = Math.floor(pivot + (mu - pivot) / 2.0); 
            
            
            double mu2delta = 2.0 * mu + delta;
            double muDeltaHalf = mu + delta / 2.0;
            double logMeanMu = Math.log(mean / mu);

            double muFactorialLog = MathUtils.factorialLog((int) mu);

            double c1 = Math.sqrt(Math.PI * mu / 2.0);
            double c2 = c1
                    + Math.sqrt(Math.PI * muDeltaHalf
                            / (2.0 * Math.exp(1.0 / mu2delta)));
            double c3 = c2 + 2.0;
            double c4 = c3 + Math.exp(1.0 / 78.0);
            double c = c4 + 2.0 / delta * mu2delta
                    * Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));

            double y = 0.0;
            double x = 0.0;
            double w = Double.POSITIVE_INFINITY;

            boolean accept = false;
            while (!accept) {
                double u = nextUniform(0.0, c);
                double e = nextExponential(mean);

                if (u <= c1) {
                    double z = nextGaussian(0.0, 1.0);
                    y = -Math.abs(z) * Math.sqrt(mu) - 1.0;
                    x = Math.floor(y);
                    w = -z * z / 2.0 - e - x * logMeanMu;
                    if (x < -mu) {
                        w = Double.POSITIVE_INFINITY;
                    }
                } else if (c1 < u && u <= c2) {
                    double z = nextGaussian(0.0, 1.0);
                    y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);
                    x = Math.ceil(y);
                    w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;
                    if (x > delta) {
                        w = Double.POSITIVE_INFINITY;
                    }
                } else if (c2 < u && u <= c3) {
                    x = 0.0;
                    w = -e;
                } else if (c3 < u && u <= c4) {
                    x = 1.0;
                    w = -e - logMeanMu;
                } else if (c4 < u) {
                    double v = nextExponential(mean);
                    y = delta + v * 2.0 / delta * mu2delta;
                    x = Math.ceil(y);
                    w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;
                }
                accept = (w <= x * Math.log(mu)
                        - MathUtils.factorialLog((int) (mu + x))
                        / muFactorialLog);
            }
            
            
            return (long) (x + mu);
        }
    }

    










    public double nextGaussian(double mu, double sigma) {
        if (sigma <= 0) {
            throw new IllegalArgumentException("Gaussian std dev must be > 0");
        }
        RandomGenerator rand = getRan();
        return sigma * rand.nextGaussian() + mu;
    }

    













    public double nextExponential(double mean) {
        if (mean < 0.0) {
            throw new IllegalArgumentException("Exponential mean must be >= 0");
        }
        RandomGenerator rand = getRan();
        double unif = rand.nextDouble();
        while (unif == 0.0d) {
            unif = rand.nextDouble();
        }
        return -mean * Math.log(unif);
    }

    















    public double nextUniform(double lower, double upper) {
        if (lower >= upper) {
            throw new IllegalArgumentException(
                    "lower bound must be < upper bound");
        }
        RandomGenerator rand = getRan();

        
        double u = rand.nextDouble();
        while (u <= 0.0) {
            u = rand.nextDouble();
        }

        return lower + u * (upper - lower);
    }

    








    private RandomGenerator getRan() {
        if (rand == null) {
            rand = new JDKRandomGenerator();
            rand.setSeed(System.currentTimeMillis());
        }
        return rand;
    }

    







    private SecureRandom getSecRan() {
        if (secRand == null) {
            secRand = new SecureRandom();
            secRand.setSeed(System.currentTimeMillis());
        }
        return secRand;
    }

    








    public void reSeed(long seed) {
        if (rand == null) {
            rand = new JDKRandomGenerator();
        }
        rand.setSeed(seed);
    }

    






    public void reSeedSecure() {
        if (secRand == null) {
            secRand = new SecureRandom();
        }
        secRand.setSeed(System.currentTimeMillis());
    }

    








    public void reSeedSecure(long seed) {
        if (secRand == null) {
            secRand = new SecureRandom();
        }
        secRand.setSeed(seed);
    }

    



    public void reSeed() {
        if (rand == null) {
            rand = new JDKRandomGenerator();
        }
        rand.setSeed(System.currentTimeMillis());
    }

    



















    public void setSecureAlgorithm(String algorithm, String provider)
            throws NoSuchAlgorithmException, NoSuchProviderException {
        secRand = SecureRandom.getInstance(algorithm, provider);
    }

    



























    public int[] nextPermutation(int n, int k) {
        if (k > n) {
            throw new IllegalArgumentException("permutation k exceeds n");
        }
        if (k == 0) {
            throw new IllegalArgumentException("permutation k must be > 0");
        }

        int[] index = getNatural(n);
        shuffle(index, n - k);
        int[] result = new int[k];
        for (int i = 0; i < k; i++) {
            result[i] = index[n - i - 1];
        }

        return result;
    }

    















    public Object[] nextSample(Collection<?> c, int k) {
        int len = c.size();
        if (k > len) {
            throw new IllegalArgumentException(
                    "sample size exceeds collection size");
        }
        if (k == 0) {
            throw new IllegalArgumentException("sample size must be > 0");
        }

        Object[] objects = c.toArray();
        int[] index = nextPermutation(len, k);
        Object[] result = new Object[k];
        for (int i = 0; i < k; i++) {
            result[i] = objects[index[i]];
        }
        return result;
    }

    

    








    private void shuffle(int[] list, int end) {
        int target = 0;
        for (int i = list.length - 1; i >= end; i--) {
            if (i == 0) {
                target = 0;
            } else {
                target = nextInt(0, i);
            }
            int temp = list[target];
            list[target] = list[i];
            list[i] = temp;
        }
    }

    






    private int[] getNatural(int n) {
        int[] natural = new int[n];
        for (int i = 0; i < n; i++) {
            natural[i] = i;
        }
        return natural;
    }
}
