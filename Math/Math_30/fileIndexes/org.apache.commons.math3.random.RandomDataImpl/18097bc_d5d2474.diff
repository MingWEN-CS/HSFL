338,350d337
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
359c346
<         double pivot = 6.0;
---
>         final double pivot = 40.0d;
377,411c364,392
<             double mu = Math.floor(mean);
<             double delta = Math.floor(pivot + (mu - pivot) / 2.0); 
<             
<             
<             double mu2delta = 2.0 * mu + delta;
<             double muDeltaHalf = mu + delta / 2.0;
<             double logMeanMu = Math.log(mean / mu);
< 
<             double muFactorialLog = MathUtils.factorialLog((int) mu);
< 
<             double c1 = Math.sqrt(Math.PI * mu / 2.0);
<             double c2 = c1 +
<                         Math.sqrt(Math.PI * muDeltaHalf /
<                                   (2.0 * Math.exp(1.0 / mu2delta)));
<             double c3 = c2 + 2.0;
<             double c4 = c3 + Math.exp(1.0 / 78.0);
<             double c = c4 + 2.0 / delta * mu2delta *
<                        Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));
< 
<             double y = 0.0;
<             double x = 0.0;
<             double w = Double.POSITIVE_INFINITY;
< 
<             boolean accept = false;
<             while (!accept) {
<                 double u = nextUniform(0.0, c);
<                 double e = nextExponential(mean);
< 
<                 if (u <= c1) {
<                     double z = nextGaussian(0.0, 1.0);
<                     y = -Math.abs(z) * Math.sqrt(mu) - 1.0;
<                     x = Math.floor(y);
<                     w = -z * z / 2.0 - e - x * logMeanMu;
<                     if (x < -mu) {
<                         w = Double.POSITIVE_INFINITY;
---
>             final double lambda = Math.floor(mean);
>             final double lambdaFractional = mean - lambda;
>             final double logLambda = Math.log(lambda);
>             final double logLambdaFactorial = MathUtils.factorialLog((int) lambda);
>             final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional);
>             final double delta = Math.sqrt(lambda * Math.log(32 * lambda / Math.PI + 1));
>             final double halfDelta = delta / 2;
>             final double twolpd = 2 * lambda + delta;
>             final double a1 = Math.sqrt(Math.PI * twolpd) * Math.exp(1 / 8 * lambda);
>             final double a2 = (twolpd / delta) * Math.exp(-delta * (1 + delta) / twolpd);
>             final double aSum = a1 + a2 + 1;
>             final double p1 = a1 / aSum;
>             final double p2 = a2 / aSum;
>             final double c1 = 1 / (8 * lambda);
> 
>             double x = 0;
>             double y = 0;
>             double v = 0;
>             int a = 0;
>             double t = 0;
>             double qr = 0;
>             double qa = 0;
>             for (;;) {
>                 final double u = nextUniform(0.0, 1);
>                 if (u <= p1) {
>                     final double n = nextGaussian(0d, 1d);
>                     x = n * Math.sqrt(lambda + halfDelta) - 0.5d;
>                     if (x > delta || x < -lambda) {
>                         continue;
413,419c394,404
<                 } else if (c1 < u && u <= c2) {
<                     double z = nextGaussian(0.0, 1.0);
<                     y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);
<                     x = Math.ceil(y);
<                     w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;
<                     if (x > delta) {
<                         w = Double.POSITIVE_INFINITY;
---
>                     y = x < 0 ? Math.floor(x) : Math.ceil(x);
>                     final double e = nextExponential(1d);
>                     v = -e - (n * n / 2) + c1;
>                 } else {
>                     if (u > p1 + p2) {
>                         y = lambda;
>                         break;
>                     } else {
>                         x = delta + (twolpd / delta) * nextExponential(1d);
>                         y = Math.ceil(x);
>                         v = -nextExponential(1d) - delta * (x + 1) / twolpd;
421,431d405
<                 } else if (c2 < u && u <= c3) {
<                     x = 0.0;
<                     w = -e;
<                 } else if (c3 < u && u <= c4) {
<                     x = 1.0;
<                     w = -e - logMeanMu;
<                 } else if (c4 < u) {
<                     double v = nextExponential(mean);
<                     y = delta + v * 2.0 / delta * mu2delta;
<                     x = Math.ceil(y);
<                     w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;
433,434c407,425
<                 accept = w <= x * Math.log(mu) -
<                          MathUtils.factorialLog((int) (mu + x)) / muFactorialLog;
---
>                 a = x < 0 ? 1 : 0;
>                 t = y * (y + 1) / (2 * lambda);
>                 if (v < -t && a == 0) {
>                     y = lambda + y;
>                     break;
>                 }
>                 qr = t * ((2 * y + 1) / (6 * lambda) - 1);
>                 qa = qr - (t * t) / (3 * (lambda + a * (y + 1)));
>                 if (v < qa) {
>                     y = lambda + y;
>                     break;
>                 }
>                 if (v > qr) {
>                     continue;
>                 }
>                 if (v < y * logLambda - MathUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {
>                     y = lambda + y;
>                     break;
>                 }
436,438c427
<             
<             
<             return (long) (x + mu);
---
>             return y2 + (long) y;
