19a20
> import java.io.Serializable;
20a22,26
> import org.apache.commons.math.exception.NotStrictlyPositiveException;
> import org.apache.commons.math.exception.NumberIsTooLargeException;
> import org.apache.commons.math.exception.util.LocalizedFormats;
> import org.apache.commons.math.special.Erf;
> import org.apache.commons.math.util.FastMath;
28a35,72
> public class NormalDistribution extends AbstractContinuousDistribution
>         implements Serializable {
>     
> 
> 
> 
>     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
>     
>     private static final long serialVersionUID = 8589540077390120676L;
>     
>     private static final double SQRT2PI = FastMath.sqrt(2 * FastMath.PI);
>     
>     private static final double SQRT2 = FastMath.sqrt(2.0);
>     
>     private final double mean;
>     
>     private final double standardDeviation;
>     
>     private final double solverAbsoluteAccuracy;
> 
>     
> 
> 
> 
> 
> 
> 
>     public NormalDistribution(double mean, double sd)
>         throws NotStrictlyPositiveException {
>         this(mean, sd, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
>     }
> 
>     
> 
> 
> 
> 
> 
33c77,86
< public interface NormalDistribution extends ContinuousDistribution {
---
>     public NormalDistribution(double mean, double sd, double inverseCumAccuracy) {
>         if (sd <= 0) {
>             throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sd);
>         }
> 
>         this.mean = mean;
>         standardDeviation = sd;
>         solverAbsoluteAccuracy = inverseCumAccuracy;
>     }
> 
37a91,96
>     public NormalDistribution(){
>         this(0, 1);
>     }
> 
>     
> 
39c98,102
<     double getMean();
---
> 
> 
>     public double getMean() {
>         return mean;
>     }
46c109,281
<     double getStandardDeviation();
---
>     public double getStandardDeviation() {
>         return standardDeviation;
>     }
> 
>     
>     public double density(double x) {
>         final double x0 = x - mean;
>         final double x1 = x0 / standardDeviation;
>         return FastMath.exp(-0.5 * x1 * x1) / (standardDeviation * SQRT2PI);
>     }
> 
>     
> 
> 
> 
> 
> 
> 
>     public double cumulativeProbability(double x)  {
>         final double dev = x - mean;
>         if (FastMath.abs(dev) > 40 * standardDeviation) {
>             return dev < 0 ? 0.0d : 1.0d;
>         }
>         return 0.5 * (1 + Erf.erf(dev / (standardDeviation * SQRT2)));
>     }
> 
>     
>     @Override
>     public double cumulativeProbability(double x0, double x1)
>         throws NumberIsTooLargeException {
>         if (x0 > x1) {
>             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,
>                                                 x0, x1, true);
>         }
>         final double denom = standardDeviation * SQRT2;
>         final double v0 = (x0 - mean) / denom;
>         final double v1 = (x1 - mean) / denom;
>         return 0.5 * Erf.erf(v0, v1);
>     }
> 
>     
>     @Override
>     protected double getSolverAbsoluteAccuracy() {
>         return solverAbsoluteAccuracy;
>     }
> 
>     
> 
> 
> 
> 
> 
>     @Override
>     public double inverseCumulativeProbability(final double p) {
>         if (p == 0) {
>             return Double.NEGATIVE_INFINITY;
>         }
>         if (p == 1) {
>             return Double.POSITIVE_INFINITY;
>         }
>         return super.inverseCumulativeProbability(p);
>     }
> 
>     
>     @Override
>     public double sample()  {
>         return randomData.nextGaussian(mean, standardDeviation);
>     }
> 
>     
>     @Override
>     protected double getDomainLowerBound(double p) {
>         double ret;
> 
>         if (p < 0.5) {
>             ret = -Double.MAX_VALUE;
>         } else {
>             ret = mean;
>         }
> 
>         return ret;
>     }
> 
>     
>     @Override
>     protected double getDomainUpperBound(double p) {
>         double ret;
> 
>         if (p < 0.5) {
>             ret = mean;
>         } else {
>             ret = Double.MAX_VALUE;
>         }
> 
>         return ret;
>     }
> 
>     
>     @Override
>     protected double getInitialDomain(double p) {
>         double ret;
> 
>         if (p < 0.5) {
>             ret = mean - standardDeviation;
>         } else if (p > 0.5) {
>             ret = mean + standardDeviation;
>         } else {
>             ret = mean;
>         }
> 
>         return ret;
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
>     @Override
>     public double getSupportLowerBound() {
>         return Double.NEGATIVE_INFINITY;
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
>     @Override
>     public double getSupportUpperBound() {
>         return Double.POSITIVE_INFINITY;
>     }
> 
>     
> 
> 
> 
> 
>     @Override
>     protected double calculateNumericalMean() {
>         return getMean();
>     }
> 
>     
> 
> 
> 
> 
>     @Override
>     protected double calculateNumericalVariance() {
>         final double s = getStandardDeviation();
>         return s * s;
>     }
> 
>     
>     @Override
>     public boolean isSupportLowerBoundInclusive() {
>         return false;
>     }
> 
>     
>     @Override
>     public boolean isSupportUpperBoundInclusive() {
>         return false;
>     }
