26a27
> import org.apache.commons.math.MathException;
27a29,41
> import org.apache.commons.math.distribution.BetaDistributionImpl;
> import org.apache.commons.math.distribution.BinomialDistributionImpl;
> import org.apache.commons.math.distribution.CauchyDistributionImpl;
> import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;
> import org.apache.commons.math.distribution.ContinuousDistribution;
> import org.apache.commons.math.distribution.FDistributionImpl;
> import org.apache.commons.math.distribution.GammaDistributionImpl;
> import org.apache.commons.math.distribution.HypergeometricDistributionImpl;
> import org.apache.commons.math.distribution.IntegerDistribution;
> import org.apache.commons.math.distribution.PascalDistributionImpl;
> import org.apache.commons.math.distribution.TDistributionImpl;
> import org.apache.commons.math.distribution.WeibullDistributionImpl;
> import org.apache.commons.math.distribution.ZipfDistributionImpl;
338,350d351
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
359c360
<         double pivot = 6.0;
---
>         final double pivot = 40.0d;
377,411c378,406
<             double mu = Math.floor(mean);
<             double delta = Math.floor(pivot + (mu - pivot) / 2.0); 
<             
<             
<             double mu2delta = 2.0 * mu + delta;
<             double muDeltaHalf = mu + delta / 2.0;
<             double logMeanMu = Math.log(mean / mu);
< 
<             double muFactorialLog = MathUtils.factorialLog((int) mu);
< 
<             double c1 = Math.sqrt(Math.PI * mu / 2.0);
<             double c2 = c1 +
<                         Math.sqrt(Math.PI * muDeltaHalf /
<                                   (2.0 * Math.exp(1.0 / mu2delta)));
<             double c3 = c2 + 2.0;
<             double c4 = c3 + Math.exp(1.0 / 78.0);
<             double c = c4 + 2.0 / delta * mu2delta *
<                        Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));
< 
<             double y = 0.0;
<             double x = 0.0;
<             double w = Double.POSITIVE_INFINITY;
< 
<             boolean accept = false;
<             while (!accept) {
<                 double u = nextUniform(0.0, c);
<                 double e = nextExponential(mean);
< 
<                 if (u <= c1) {
<                     double z = nextGaussian(0.0, 1.0);
<                     y = -Math.abs(z) * Math.sqrt(mu) - 1.0;
<                     x = Math.floor(y);
<                     w = -z * z / 2.0 - e - x * logMeanMu;
<                     if (x < -mu) {
<                         w = Double.POSITIVE_INFINITY;
---
>             final double lambda = Math.floor(mean);
>             final double lambdaFractional = mean - lambda;
>             final double logLambda = Math.log(lambda);
>             final double logLambdaFactorial = MathUtils.factorialLog((int) lambda);
>             final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional);
>             final double delta = Math.sqrt(lambda * Math.log(32 * lambda / Math.PI + 1));
>             final double halfDelta = delta / 2;
>             final double twolpd = 2 * lambda + delta;
>             final double a1 = Math.sqrt(Math.PI * twolpd) * Math.exp(1 / 8 * lambda);
>             final double a2 = (twolpd / delta) * Math.exp(-delta * (1 + delta) / twolpd);
>             final double aSum = a1 + a2 + 1;
>             final double p1 = a1 / aSum;
>             final double p2 = a2 / aSum;
>             final double c1 = 1 / (8 * lambda);
> 
>             double x = 0;
>             double y = 0;
>             double v = 0;
>             int a = 0;
>             double t = 0;
>             double qr = 0;
>             double qa = 0;
>             for (;;) {
>                 final double u = nextUniform(0.0, 1);
>                 if (u <= p1) {
>                     final double n = nextGaussian(0d, 1d);
>                     x = n * Math.sqrt(lambda + halfDelta) - 0.5d;
>                     if (x > delta || x < -lambda) {
>                         continue;
413,419c408,418
<                 } else if (c1 < u && u <= c2) {
<                     double z = nextGaussian(0.0, 1.0);
<                     y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);
<                     x = Math.ceil(y);
<                     w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;
<                     if (x > delta) {
<                         w = Double.POSITIVE_INFINITY;
---
>                     y = x < 0 ? Math.floor(x) : Math.ceil(x);
>                     final double e = nextExponential(1d);
>                     v = -e - (n * n / 2) + c1;
>                 } else {
>                     if (u > p1 + p2) {
>                         y = lambda;
>                         break;
>                     } else {
>                         x = delta + (twolpd / delta) * nextExponential(1d);
>                         y = Math.ceil(x);
>                         v = -nextExponential(1d) - delta * (x + 1) / twolpd;
421,431d419
<                 } else if (c2 < u && u <= c3) {
<                     x = 0.0;
<                     w = -e;
<                 } else if (c3 < u && u <= c4) {
<                     x = 1.0;
<                     w = -e - logMeanMu;
<                 } else if (c4 < u) {
<                     double v = nextExponential(mean);
<                     y = delta + v * 2.0 / delta * mu2delta;
<                     x = Math.ceil(y);
<                     w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;
433,435c421,439
<                 accept = (w <= x * Math.log(mu) -
<                          MathUtils.factorialLog((int) (mu + x)) /
<                          muFactorialLog);
---
>                 a = x < 0 ? 1 : 0;
>                 t = y * (y + 1) / (2 * lambda);
>                 if (v < -t && a == 0) {
>                     y = lambda + y;
>                     break;
>                 }
>                 qr = t * ((2 * y + 1) / (6 * lambda) - 1);
>                 qa = qr - (t * t) / (3 * (lambda + a * (y + 1)));
>                 if (v < qa) {
>                     y = lambda + y;
>                     break;
>                 }
>                 if (v > qr) {
>                     continue;
>                 }
>                 if (v < y * logLambda - MathUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {
>                     y = lambda + y;
>                     break;
>                 }
437,439c441
<             
<             
<             return (long) (x + mu);
---
>             return y2 + (long) y;
475d476
< 
477c478
<         if (mean < 0.0) {
---
>         if (mean <= 0.0) {
530a532,695
> 
> 
>     public double nextBeta(double alpha, double beta) throws MathException {
>         return nextInversionDeviate(new BetaDistributionImpl(alpha, beta));
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public int nextBinomial(int numberOfTrials, double probabilityOfSuccess) throws MathException {
>         return nextInversionDeviate(new BinomialDistributionImpl(numberOfTrials, probabilityOfSuccess));
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public double nextCauchy(double median, double scale) throws MathException {
>         return nextInversionDeviate(new CauchyDistributionImpl(median, scale));
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public double nextChiSquare(double df) throws MathException {
>         return nextInversionDeviate(new ChiSquaredDistributionImpl(df));
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public double nextF(double numeratorDf, double denominatorDf) throws MathException {
>         return nextInversionDeviate(new FDistributionImpl(numeratorDf, denominatorDf));
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public double nextGamma(double shape, double scale) throws MathException {
>         return nextInversionDeviate(new GammaDistributionImpl(shape, scale));
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public int nextHypergeometric(int populationSize, int numberOfSuccesses, int sampleSize) throws MathException {
>         return nextInversionDeviate(new HypergeometricDistributionImpl(populationSize, numberOfSuccesses, sampleSize));
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public int nextPascal(int r, double p) throws MathException {
>         return nextInversionDeviate(new PascalDistributionImpl(r, p));
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public double nextT(double df) throws MathException {
>         return nextInversionDeviate(new TDistributionImpl(df));
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public double nextWeibull(double shape, double scale) throws MathException {
>         return nextInversionDeviate(new WeibullDistributionImpl(shape, scale));
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public int nextZipf(int numberOfElements, double exponent) throws MathException {
>         return nextInversionDeviate(new ZipfDistributionImpl(numberOfElements, exponent));
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
718a884,916
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
>     public double nextInversionDeviate(ContinuousDistribution distribution) throws MathException {
>         return distribution.inverseCumulativeProbability(nextUniform(0, 1));
> 
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
>     public int nextInversionDeviate(IntegerDistribution distribution) throws MathException {
>         final double target = nextUniform(0, 1);
>         final int glb = distribution.inverseCumulativeProbability(target);
>         if (distribution.cumulativeProbability(glb) == 1.0d) { 
>             return glb;
>         } else {
>             return glb + 1;
>         }
