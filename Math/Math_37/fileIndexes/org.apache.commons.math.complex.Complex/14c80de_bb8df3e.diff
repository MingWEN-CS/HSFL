127c127
<         return new Complex(real + rhs.getReal(),
---
>         return createComplex(real + rhs.getReal(),
149c149
<         return new Complex(real, -imaginary);
---
>         return createComplex(real, -imaginary);
204c204
<                 return new Complex(real/c, imaginary/c);
---
>                 return createComplex(real/c, imaginary/c);
208c208
<             return new Complex((real * q + imaginary) / denominator,
---
>             return createComplex((real * q + imaginary) / denominator,
212c212
<                 return new Complex(imaginary/d, -real/c);
---
>                 return createComplex(imaginary/d, -real/c);
216c216
<             return new Complex((imaginary * q + real) / denominator,
---
>             return createComplex((imaginary * q + real) / denominator,
352c352
<         return new Complex(real * rhs.real - imaginary * rhs.imaginary,
---
>         return createComplex(real * rhs.real - imaginary * rhs.imaginary,
369c369
<         return new Complex(-real, -imaginary);
---
>         return createComplex(-real, -imaginary);
395c395
<         return new Complex(real - rhs.getReal(),
---
>         return createComplex(real - rhs.getReal(),
396a397,861
>     }
>     
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Complex acos() {
>         if (isNaN()) {
>             return Complex.NaN;
>         }
> 
>         return this.add(this.sqrt1z().multiply(Complex.I)).log()
>               .multiply(Complex.I.negate());
>     }
>     
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Complex asin() {
>         if (isNaN()) {
>             return Complex.NaN;
>         }
> 
>         return sqrt1z().add(this.multiply(Complex.I)).log()
>               .multiply(Complex.I.negate());
>     }
>     
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Complex atan() {
>         if (isNaN()) {
>             return Complex.NaN;
>         }
>         
>         return this.add(Complex.I).divide(Complex.I.subtract(this)).log()
>             .multiply(Complex.I.divide(createComplex(2.0, 0.0)));
>     }
>     
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Complex cos() {
>         if (isNaN()) {
>             return Complex.NaN;
>         }
>         
>         return createComplex(Math.cos(real) * MathUtils.cosh(imaginary),
>             -Math.sin(real) * MathUtils.sinh(imaginary));
>     }
>     
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Complex cosh() {
>         if (isNaN()) {
>             return Complex.NaN;
>         }
>         
>         return createComplex(MathUtils.cosh(real) * Math.cos(imaginary),
>             MathUtils.sinh(real) * Math.sin(imaginary));
>     }
>     
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Complex exp() {
>         if (isNaN()) {
>             return Complex.NaN;
>         }
>         
>         double expReal = Math.exp(real);
>         return createComplex(expReal *  Math.cos(imaginary), expReal * Math.sin(imaginary));
>     }
>     
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Complex log() {
>         if (isNaN()) {
>             return Complex.NaN;
>         }
> 
>         return createComplex(Math.log(abs()),
>             Math.atan2(imaginary, real));        
>     }
>     
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Complex pow(Complex x) {
>         if (x == null) {
>             throw new NullPointerException();
>         }
>         return this.log().multiply(x).exp();
>     }
>     
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Complex sin() {
>         if (isNaN()) {
>             return Complex.NaN;
>         }
>         
>         return createComplex(Math.sin(real) * MathUtils.cosh(imaginary),
>             Math.cos(real) * MathUtils.sinh(imaginary));
>     }
>     
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Complex sinh() {
>         if (isNaN()) {
>             return Complex.NaN;
>         }
>         
>         return createComplex(MathUtils.sinh(real) * Math.cos(imaginary),
>             MathUtils.cosh(real) * Math.sin(imaginary));
>     }
>     
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Complex sqrt() {
>         if (isNaN()) {
>             return Complex.NaN;
>         }
>         
>         if (real == 0.0 && imaginary == 0.0) {
>             return createComplex(0.0, 0.0);
>         }
>         
>         double t = Math.sqrt((Math.abs(real) + abs()) / 2.0);
>         if (real >= 0.0) {
>             return createComplex(t, imaginary / (2.0 * t));
>         } else {
>             return createComplex(Math.abs(imaginary) / (2.0 * t),
>                 MathUtils.indicator(imaginary) * t);
>         }
>     }
>     
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Complex sqrt1z() {
>         return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();
>     }
>     
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Complex tan() {
>         if (isNaN()) {
>             return Complex.NaN;
>         }
>         
>         double real2 = 2.0 * real;
>         double imaginary2 = 2.0 * imaginary;
>         double d = Math.cos(real2) + MathUtils.cosh(imaginary2);
>         
>         return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);
>     }
>     
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Complex tanh() {
>         if (isNaN()) {
>             return Complex.NaN;
>         }
>         
>         double real2 = 2.0 * real;
>         double imaginary2 = 2.0 * imaginary;
>         double d = MathUtils.cosh(real2) + Math.cos(imaginary2);
>         
>         return createComplex(MathUtils.sinh(real2) / d, Math.sin(imaginary2) / d);
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
>     protected Complex createComplex(double real, double imaginary) {
>         return new Complex(real, imaginary);
