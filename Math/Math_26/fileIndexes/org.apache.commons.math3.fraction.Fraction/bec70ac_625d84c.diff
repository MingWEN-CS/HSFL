17a18
> import java.math.BigInteger;
121a123
> 
123a126,136
>         if (den == 0) {
>             throw new ArithmeticException("The denominator must not be zero");
>         }
>         if (den < 0) {
>             if (num == Integer.MIN_VALUE ||
>                     den == Integer.MIN_VALUE) {
>                 throw new ArithmeticException("overflow: can't negate");
>             }
>             num = -num;
>             den = -den;
>         }
149,162d161
< 
<     public Fraction add(Fraction rhs) {
<         int den = MathUtils.lcm(denominator, rhs.denominator);
<         int num = (numerator * (den / denominator)) +
<             (rhs.numerator * (den / rhs.denominator));
<         return new Fraction(num, den);
<     }
<     
<     
< 
< 
< 
< 
< 
180,189d178
< 
<     
< 
< 
< 
< 
< 
<     public Fraction divide(Fraction rhs) {
<         return multiply(rhs.reciprocal());
<     }
286a276,284
>     public Fraction negate() {
>         if (numerator==Integer.MIN_VALUE) {
>             throw new ArithmeticException("overflow: too large to negate");
>         }
>         return new Fraction(-numerator, denominator);
>     }
> 
>     
> 
289,291c287,288
<     public Fraction multiply(Fraction rhs) {
<         return new Fraction(numerator * rhs.numerator, 
<                 denominator * rhs.denominator);
---
>     public Fraction reciprocal() {
>         return new Fraction(denominator, numerator);
298,299c295,302
<     public Fraction negate() {
<         return new Fraction(-numerator, denominator);
---
> 
> 
> 
> 
> 
> 
>     public Fraction add(Fraction fraction) {
>         return addSub(fraction, true );
306,307c309,316
<     public Fraction reciprocal() {
<         return new Fraction(denominator, numerator);
---
> 
> 
> 
> 
> 
> 
>     public Fraction subtract(Fraction fraction) {
>         return addSub(fraction, false );
308a318
> 
309a320,375
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     private Fraction addSub(Fraction fraction, boolean isAdd) {
>         if (fraction == null) {
>             throw new IllegalArgumentException("The fraction must not be null");
>         }
>         
>         if (numerator == 0) {
>             return isAdd ? fraction : fraction.negate();
>         }
>         if (fraction.numerator == 0) {
>             return this;
>         }     
>         
>         
>         int d1 = MathUtils.gcd(denominator, fraction.denominator);
>         if (d1==1) {
>             
>             int uvp = MathUtils.mulAndCheck(numerator, fraction.denominator);
>             int upv = MathUtils.mulAndCheck(fraction.numerator, denominator);
>             return new Fraction
>                 (isAdd ? MathUtils.addAndCheck(uvp, upv) : 
>                  MathUtils.subAndCheck(uvp, upv),
>                  MathUtils.mulAndCheck(denominator, fraction.denominator));
>         }
>         
>         
>         
>         BigInteger uvp = BigInteger.valueOf(numerator)
>         .multiply(BigInteger.valueOf(fraction.denominator/d1));
>         BigInteger upv = BigInteger.valueOf(fraction.numerator)
>         .multiply(BigInteger.valueOf(denominator/d1));
>         BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);
>         
>         
>         int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();
>         int d2 = (tmodd1==0)?d1:MathUtils.gcd(tmodd1, d1);
> 
>         
>         BigInteger w = t.divide(BigInteger.valueOf(d2));
>         if (w.bitLength() > 31) {
>             throw new ArithmeticException
>             ("overflow: numerator too large after multiply");
>         }
>         return new Fraction (w.intValue(), 
>                 MathUtils.mulAndCheck(denominator/d1, 
>                         fraction.denominator/d2));
>     }
> 
316,317c382,456
<     public Fraction subtract(Fraction rhs) {
<         return add(rhs.negate());
---
> 
> 
> 
> 
>     public Fraction multiply(Fraction fraction) {
>         if (fraction == null) {
>             throw new IllegalArgumentException("The fraction must not be null");
>         }
>         if (numerator == 0 || fraction.numerator == 0) {
>             return ZERO;
>         }
>         
>         
>         int d1 = MathUtils.gcd(numerator, fraction.denominator);
>         int d2 = MathUtils.gcd(fraction.numerator, denominator);
>         return getReducedFraction
>         (MathUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),
>                 MathUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Fraction divide(Fraction fraction) {
>         if (fraction == null) {
>             throw new IllegalArgumentException("The fraction must not be null");
>         }
>         if (fraction.numerator == 0) {
>             throw new ArithmeticException("The fraction to divide by must not be zero");
>         }
>         return multiply(fraction.reciprocal());
>     }
>     
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public static Fraction getReducedFraction(int numerator, int denominator) {
>         if (denominator == 0) {
>             throw new ArithmeticException("The denominator must not be zero");
>         }
>         if (numerator==0) {
>             return ZERO; 
>         }
>         
>         if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
>             numerator/=2; denominator/=2;
>         }
>         if (denominator < 0) {
>             if (numerator==Integer.MIN_VALUE ||
>                     denominator==Integer.MIN_VALUE) {
>                 throw new ArithmeticException("overflow: can't negate");
>             }
>             numerator = -numerator;
>             denominator = -denominator;
>         }
>         
>         int gcd = MathUtils.gcd(numerator, denominator);
>         numerator /= gcd;
>         denominator /= gcd;
>         return new Fraction(numerator, denominator);
