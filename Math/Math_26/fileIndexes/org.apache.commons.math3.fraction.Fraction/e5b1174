














package org.apache.commons.math.fraction;

import org.apache.commons.math.ConvergenceException;
import org.apache.commons.math.util.MathUtils;







public class Fraction extends Number implements Comparable {

    
    public static final Fraction ONE = new Fraction(1, 1);

    
    public static final Fraction ZERO = new Fraction(0, 1);
    
    
    static final long serialVersionUID = 65382027393090L;
    
    
    private int denominator;
    
    
    private int numerator;

    





    public Fraction(double value) throws ConvergenceException {
        this(value, 1.0e-5, 100);
    }

    















    public Fraction(double value, double epsilon, int maxIterations)
        throws ConvergenceException
    {
        double r0 = value;
        int a0 = (int)Math.floor(r0);
        
        int p0 = 1;
        int q0 = 0;
        int p1 = a0;
        int q1 = 1;

        int p2 = 0;
        int q2 = 1;

        int n = 0;
        boolean stop = false;
        do {
            ++n;
            double r1 = 1.0 / (r0 - a0);
            int a1 = (int)Math.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;
            
            double convergent = (double)p2 / (double)q2;
            if (n < maxIterations && Math.abs(convergent - value) > epsilon) {
                p0 = p1;
                p1 = p2;
                q0 = q1;
                q1 = q2;
                a0 = a1;
                r0 = r1;
            } else {
                stop = true;
            }
        } while (!stop);

        if (n >= maxIterations) {
            throw new ConvergenceException(
                    "Unable to convert double to fraction");
        }
        
        this.numerator = p2;
        this.denominator = q2;
        reduce();
    }
    
    





    public Fraction(int num, int den) {
        super();
        this.numerator = num;
        this.denominator = den;
        reduce();
    }
    
    



    public Fraction abs() {
        Fraction ret;
        if (numerator >= 0) {
            ret = this;
        } else {
            ret = negate();
        }
        return ret;        
    }
    
    






    public Fraction add(Fraction rhs) {
        int den = MathUtils.lcm(denominator, rhs.denominator);
        int num = (numerator * (den / denominator)) +
            (rhs.numerator * (den / rhs.denominator));
        return new Fraction(num, den);
    }
    
    





    public int compareTo(Object object) {
        int ret = 0;
        
        if (this != object) { 
            Fraction other = (Fraction)object;
            double first = doubleValue();
            double second = other.doubleValue();
            
            if (first < second) {
                ret = -1;
            } else if (first > second) {
                ret = 1;
            }
        }
        
        return ret;
    }

    





    public Fraction divide(Fraction rhs) {
        return multiply(rhs.reciprocal());
    }
    
    




    public double doubleValue() {
        return (double)numerator / (double)denominator;
    }
    
    








    public boolean equals(Object other) {
        boolean ret;
        
        if (this == other) { 
            ret = true;
        } else if (other == null) {
            ret = false;
        } else {
            try {
                
                
                Fraction rhs = (Fraction)other;
                ret = (numerator == rhs.numerator) &&
                    (denominator == rhs.denominator);
            } catch (ClassCastException ex) {
                
                ret = false;
            }
        }
        
        return ret;
    }
    
    




    public float floatValue() {
        return (float)doubleValue();
    }
    
    



    public int getDenominator() {
        return denominator;
    }
    
    



    public int getNumerator() {
        return numerator;
    }
    
    



    public int hashCode() {
        return 37 * (37 * 17 + getNumerator()) + getDenominator();
    }
    
    




    public int intValue() {
        return (int)doubleValue();
    }
    
    




    public long longValue() {
        return (long)doubleValue();
    }
    
    





    public Fraction multiply(Fraction rhs) {
        return new Fraction(numerator * rhs.numerator, 
                denominator * rhs.denominator);
    }
    
    



    public Fraction negate() {
        return new Fraction(-numerator, denominator);
    }

    



    public Fraction reciprocal() {
        return new Fraction(denominator, numerator);
    }
    
    





    public Fraction subtract(Fraction rhs) {
        return add(rhs.negate());
    }
    
    



    private void reduce() {
        
        int d = MathUtils.gcd(numerator, denominator);
        if (d > 1) {
            numerator /= d;
            denominator /= d;
        }

        
        if (denominator < 0) {
            numerator *= -1;
            denominator *= -1;
        }
    }
}
