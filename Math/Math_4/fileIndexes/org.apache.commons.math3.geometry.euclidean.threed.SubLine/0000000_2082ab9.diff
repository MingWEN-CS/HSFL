1a2,137
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> package org.apache.commons.math.geometry.euclidean.threed;
> 
> import java.util.ArrayList;
> import java.util.List;
> 
> import org.apache.commons.math.geometry.euclidean.oned.Interval;
> import org.apache.commons.math.geometry.euclidean.oned.IntervalsSet;
> import org.apache.commons.math.geometry.euclidean.oned.Vector1D;
> import org.apache.commons.math.geometry.partitioning.Hyperplane;
> import org.apache.commons.math.geometry.partitioning.Region.Location;
> 
> 
> 
> 
> 
> public class SubLine {
> 
>     
>     private final Line line;
> 
>     
>     private final IntervalsSet remainingRegion;
> 
>     
> 
> 
> 
>     public SubLine(final Line line, final IntervalsSet remainingRegion) {
>         this.line            = line;
>         this.remainingRegion = remainingRegion;
>     }
> 
>     
> 
> 
> 
>     public SubLine(final Vector3D start, final Vector3D end) {
>         this(new Line(start, end), buildIntervalSet(start, end));
>     }
> 
>     
> 
> 
>     public SubLine(final Segment segment) {
>         this(segment.getLine(), buildIntervalSet(segment.getStart(), segment.getEnd()));
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public List<Segment> getSegments() {
> 
>         final List<Interval> list = remainingRegion.asList();
>         final List<Segment> segments = new ArrayList<Segment>();
> 
>         for (final Interval interval : list) {
>             final Vector3D start = line.toSpace(new Vector1D(interval.getLower()));
>             final Vector3D end   = line.toSpace(new Vector1D(interval.getUpper()));
>             segments.add(new Segment(start, end, line));
>         }
> 
>         return segments;
> 
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {
> 
>         
>         Vector3D v1D = line.intersection(subLine.line);
> 
>         
>         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
> 
>         
>         Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
> 
>         if (includeEndPoints) {
>             return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
>         } else {
>             return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
>         }
> 
>     }
> 
>     
> 
> 
> 
> 
>     private static IntervalsSet buildIntervalSet(final Vector3D start, final Vector3D end) {
>         final Line line = new Line(start, end);
>         return new IntervalsSet(line.toSubSpace(start).getX(),
>                                 line.toSubSpace(end).getX());
>     }
> 
> }
