
















package org.apache.commons.math.estimation;

import java.io.Serializable;

import org.apache.commons.math.linear.InvalidMatrixException;
import org.apache.commons.math.linear.RealMatrix;
import org.apache.commons.math.linear.RealMatrixImpl;












public class GaussNewtonEstimator extends AbstractEstimator implements Serializable {

    






























    public GaussNewtonEstimator(int maxCostEval,
            double convergence,
            double steadyStateThreshold) {
        setMaxCostEval(maxCostEval);
        this.steadyStateThreshold = steadyStateThreshold;
        this.convergence          = convergence;
    }

    






















    public void estimate(EstimationProblem problem)
    throws EstimationException {

        initializeEstimate(problem);

        
        double[] grad             = new double[parameters.length];
        RealMatrixImpl bDecrement = new RealMatrixImpl(parameters.length, 1);
        double[][] bDecrementData = bDecrement.getDataRef();
        RealMatrixImpl wGradGradT = new RealMatrixImpl(parameters.length, parameters.length);
        double[][] wggData        = wGradGradT.getDataRef();

        
        double previous = Double.POSITIVE_INFINITY;
        do {

            
            ++jacobianEvaluations;
            RealMatrix b = new RealMatrixImpl(parameters.length, 1);
            RealMatrix a = new RealMatrixImpl(parameters.length, parameters.length);
            for (int i = 0; i < measurements.length; ++i) {
                if (! measurements [i].isIgnored()) {

                    double weight   = measurements[i].getWeight();
                    double residual = measurements[i].getResidual();

                    
                    for (int j = 0; j < parameters.length; ++j) {
                        grad[j] = measurements[i].getPartial(parameters[j]);
                        bDecrementData[j][0] = weight * residual * grad[j];
                    }

                    
                    for (int k = 0; k < parameters.length; ++k) {
                        double[] wggRow = wggData[k];
                        double gk = grad[k];
                        for (int l = 0; l < parameters.length; ++l) {
                            wggRow[l] =  weight * gk * grad[l];
                        }
                    }

                    
                    a = a.add(wGradGradT);
                    b = b.add(bDecrement);

                }
            }

            try {

                
                RealMatrix dX = a.solve(b);

                
                for (int i = 0; i < parameters.length; ++i) {
                    parameters[i].setEstimate(parameters[i].getEstimate() + dX.getEntry(i, 0));
                }

            } catch(InvalidMatrixException e) {
                throw new EstimationException("unable to solve: singular problem", new Object[0]);
            }


            previous = cost;
            updateResidualsAndCost();

        } while ((getCostEvaluations() < 2) ||
                 (Math.abs(previous - cost) > (cost * steadyStateThreshold) &&
                  (Math.abs(cost) > convergence)));

    }

    
    private double steadyStateThreshold;

    
    private double convergence;

    
     private static final long serialVersionUID = 5485001826076289109L;

}
