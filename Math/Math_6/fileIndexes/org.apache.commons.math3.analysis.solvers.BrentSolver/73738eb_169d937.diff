20,24c20
< import org.apache.commons.math.MathRuntimeException;
< import org.apache.commons.math.MaxIterationsExceededException;
< import org.apache.commons.math.analysis.UnivariateRealFunction;
< import org.apache.commons.math.exception.MathUserException;
< import org.apache.commons.math.exception.util.LocalizedFormats;
---
> import org.apache.commons.math.exception.NoBracketingException;
25a22
> import org.apache.commons.math.util.MathUtils;
35d31
< public class BrentSolver extends UnivariateRealSolverImpl {
37,43d32
<     
< 
< 
< 
<     public static final double DEFAULT_ABSOLUTE_ACCURACY = 1E-6;
< 
<     
46d34
<     public static final int DEFAULT_MAXIMUM_ITERATIONS = 100;
47a36
> public class BrentSolver extends AbstractUnivariateRealSolver {
49a39,40
>     
>     public static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;
55c46
<         super(DEFAULT_MAXIMUM_ITERATIONS, DEFAULT_ABSOLUTE_ACCURACY);
---
>         this(DEFAULT_ABSOLUTE_ACCURACY);
57d47
< 
63d52
< 
65c54
<         super(DEFAULT_MAXIMUM_ITERATIONS, absoluteAccuracy);
---
>         super(absoluteAccuracy);
67d55
< 
74,76c62,64
< 
<     public BrentSolver(int maximumIterations, double absoluteAccuracy) {
<         super(maximumIterations, absoluteAccuracy);
---
>     public BrentSolver(double relativeAccuracy,
>                        double absoluteAccuracy) {
>         super(relativeAccuracy, absoluteAccuracy);
78d65
< 
85a73,77
>     public BrentSolver(double relativeAccuracy,
>                        double absoluteAccuracy,
>                        double functionValueAccuracy) {
>         super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);
>     }
86a79
>     
88a82,87
>     @Override
>     protected double doSolve() {
>         double min = getMin();
>         double max = getMax();
>         final double initial = getStartValue();
>         final double functionValueAccuracy = getFunctionValueAccuracy();
90,106c89
< 
< 
< 
< 
< 
< 
< 
<     public double solve(final UnivariateRealFunction f,
<                         final double min, final double max, final double initial)
<         throws MaxIterationsExceededException, MathUserException {
< 
<         clearResult();
<         if ((initial < min) || (initial > max)) {
<             throw MathRuntimeException.createIllegalArgumentException(
<                   LocalizedFormats.INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS,
<                   min, initial, max);
<         }
---
>         verifySequence(min, initial, max);
109c92
<         double yInitial = f.value(initial);
---
>         double yInitial = computeObjectiveValue(initial);
111,112c94
<             setResult(initial, 0);
<             return result;
---
>             return initial;
116c98
<         double yMin = f.value(min);
---
>         double yMin = computeObjectiveValue(min);
118,119c100
<             setResult(min, 0);
<             return result;
---
>             return min;
124c105
<             return solve(f, min, yMin, initial, yInitial, min, yMin);
---
>             return brent(min, initial, yMin, yInitial);
128c109
<         double yMax = f.value(max);
---
>         double yMax = computeObjectiveValue(max);
130,131c111
<             setResult(max, 0);
<             return result;
---
>             return max;
136c116
<             return solve(f, initial, yInitial, max, yMax, initial, yInitial);
---
>             return brent(initial, max, yInitial, yMax);
139,141c119
<         throw MathRuntimeException.createIllegalArgumentException(
<               LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, yMin, yMax);
< 
---
>         throw new NoBracketingException(min, max, yMin, yMax);
160,235c138,167
<     public double solve(final UnivariateRealFunction f,
<                         final double min, final double max)
<         throws MaxIterationsExceededException, MathUserException {
< 
<         clearResult();
<         verifyInterval(min, max);
< 
<         double ret = Double.NaN;
< 
<         double yMin = f.value(min);
<         double yMax = f.value(max);
< 
<         
<         double sign = yMin * yMax;
<         if (sign > 0) {
<             
<             if (FastMath.abs(yMin) <= functionValueAccuracy) {
<                 setResult(min, 0);
<                 ret = min;
<             } else if (FastMath.abs(yMax) <= functionValueAccuracy) {
<                 setResult(max, 0);
<                 ret = max;
<             } else {
<                 
<                 throw MathRuntimeException.createIllegalArgumentException(
<                         LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, yMin, yMax);
<             }
<         } else if (sign < 0){
<             
<             ret = solve(f, min, yMin, max, yMax, min, yMin);
<         } else {
<             
<             if (yMin == 0.0) {
<                 ret = min;
<             } else {
<                 ret = max;
<             }
<         }
< 
<         return ret;
<     }
< 
<     
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
<     private double solve(final UnivariateRealFunction f,
<                          double x0, double y0,
<                          double x1, double y1,
<                          double x2, double y2)
<     throws MaxIterationsExceededException, MathUserException {
< 
<         double delta = x1 - x0;
<         double oldDelta = delta;
< 
<         int i = 0;
<         while (i < maximalIterationCount) {
<             if (FastMath.abs(y2) < FastMath.abs(y1)) {
<                 
<                 x0 = x1;
<                 x1 = x2;
<                 x2 = x0;
<                 y0 = y1;
<                 y1 = y2;
<                 y2 = y0;
---
>     private double brent(double lo, double hi,
>                          double fLo, double fHi) {
>         double a = lo;
>         double fa = fLo;
>         double b = hi;
>         double fb = fHi;
>         double c = a;
>         double fc = fa;
>         double d = b - a;
>         double e = d;
> 
>         final double t = getAbsoluteAccuracy();
>         final double eps = getRelativeAccuracy();
> 
>         while (true) {
>             if (FastMath.abs(fc) < FastMath.abs(fb)) {
>                 a = b;
>                 b = c;
>                 c = a;
>                 fa = fb;
>                 fb = fc;
>                 fc = fa;
>             }
> 
>             final double tol = 2 * eps * FastMath.abs(b) + t;
>             final double m = 0.5 * (c - b);
> 
>             if (FastMath.abs(m) <= tol ||
>                 MathUtils.equals(fb, 0))  {
>                 return b;
237c169,170
<             if (FastMath.abs(y1) <= functionValueAccuracy) {
---
>             if (FastMath.abs(e) < tol ||
>                 FastMath.abs(fa) <= FastMath.abs(fb)) {
239,255c172,173
<                 
<                 
<                 setResult(x1, i);
<                 return result;
<             }
<             double dx = x2 - x1;
<             double tolerance =
<                 FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy);
<             if (FastMath.abs(dx) <= tolerance) {
<                 setResult(x1, i);
<                 return result;
<             }
<             if ((FastMath.abs(oldDelta) < tolerance) ||
<                     (FastMath.abs(y0) <= FastMath.abs(y1))) {
<                 
<                 delta = 0.5 * dx;
<                 oldDelta = delta;
---
>                 d = m;
>                 e = d;
257c175
<                 double r3 = y1 / y0;
---
>                 double s = fb / fa;
259c177
<                 double p1;
---
>                 double q;
263c181
<                 if (x0 == x2) {
---
>                 if (a == c) {
265,266c183,184
<                     p = dx * r3;
<                     p1 = 1.0 - r3;
---
>                     p = 2 * m * s;
>                     q = 1 - s;
269,272c187,190
<                     double r1 = y0 / y2;
<                     double r2 = y1 / y2;
<                     p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));
<                     p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);
---
>                     q = fa / fc;
>                     final double r = fb / fc;
>                     p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));
>                     q = (q - 1) * (r - 1) * (s - 1);
274,275c192,193
<                 if (p > 0.0) {
<                     p1 = -p1;
---
>                 if (p > 0) {
>                     q = -q;
279,280c197,200
<                 if (2.0 * p >= 1.5 * dx * p1 - FastMath.abs(tolerance * p1) ||
<                         p >= FastMath.abs(0.5 * oldDelta * p1)) {
---
>                 s = e;
>                 e = d;
>                 if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||
>                     p >= FastMath.abs(0.5 * s * q)) {
284,285c204,205
<                     delta = 0.5 * dx;
<                     oldDelta = delta;
---
>                     d = m;
>                     e = d;
287,288c207
<                     oldDelta = delta;
<                     delta = p / p1;
---
>                     d = p / q;
291,300c210,218
<             
<             x0 = x1;
<             y0 = y1;
<             
<             if (FastMath.abs(delta) > tolerance) {
<                 x1 = x1 + delta;
<             } else if (dx > 0.0) {
<                 x1 = x1 + 0.5 * tolerance;
<             } else if (dx <= 0.0) {
<                 x1 = x1 - 0.5 * tolerance;
---
>             a = b;
>             fa = fb;
> 
>             if (FastMath.abs(d) > tol) {
>                 b += d;
>             } else if (m > 0) {
>                 b += tol;
>             } else {
>                 b -= tol;
302,307c220,226
<             y1 = f.value(x1);
<             if ((y1 > 0) == (y2 > 0)) {
<                 x2 = x0;
<                 y2 = y0;
<                 delta = x1 - x0;
<                 oldDelta = delta;
---
>             fb = computeObjectiveValue(b);
>             if ((fb > 0 && fc > 0) ||
>                 (fb <= 0 && fc <= 0)) {
>                 c = a;
>                 fc = fa;
>                 d = b - a;
>                 e = d;
309d227
<             i++;
311d228
<         throw new MaxIterationsExceededException(maximalIterationCount);
