16a17
> 
19a21
> import java.util.NoSuchElementException;
20a23,30
> import org.apache.commons.math.exception.MathUnsupportedOperationException;
> import org.apache.commons.math.exception.DimensionMismatchException;
> import org.apache.commons.math.exception.OutOfRangeException;
> import org.apache.commons.math.exception.MathArithmeticException;
> import org.apache.commons.math.analysis.FunctionUtils;
> import org.apache.commons.math.analysis.function.Add;
> import org.apache.commons.math.analysis.function.Multiply;
> import org.apache.commons.math.analysis.function.Divide;
21a32,33
> import org.apache.commons.math.exception.util.LocalizedFormats;
> import org.apache.commons.math.util.FastMath;
46,47c58
< 
< public interface RealVector {
---
> public abstract class RealVector {
52a64
>     public abstract int getDimension();
53a66
>     
62c75
<     RealVector mapToSelf(UnivariateRealFunction function);
---
>     public abstract double getEntry(int index);
71a85,87
>     public abstract void setEntry(int index, double value);
> 
>     
75c91,93
<     RealVector map(UnivariateRealFunction function);
---
> 
> 
>     public abstract RealVector append(RealVector v);
78,80d95
<     public abstract class Entry {
<         
<         private int index;
82d96
<         
87,88c101
<         public abstract double getValue();
<         
---
>     public abstract RealVector append(double d);
89a103
>     
93,94d106
<         public abstract void setValue(double value);
<         
96a109
>     public abstract RealVector append(double[] a);
97a111
>     
99,102d112
<         public int getIndex() {
<             return index;
<         }
<         
107,110c117,120
<         public void setIndex(int index) {
<             this.index = index;
<         }
<     }
---
> 
> 
> 
>     public abstract RealVector getSubVector(int index, int n);
118d127
<     Iterator<Entry> iterator();
120d128
<     
122a131,133
>     public abstract void setSubVector(int index, RealVector v);
> 
>     
131c142
<     Iterator<Entry> sparseIterator();
---
>     public abstract void setSubVector(int index, double[] v);
138c149,150
<     RealVector copy();
---
> 
>     public abstract boolean isNaN();
145a158,162
>     public abstract boolean isInfinite();
> 
>     
> 
> 
148c165,169
<     RealVector add(RealVector v);
---
> 
> 
>     protected void checkVectorDimensions(RealVector v) {
>         checkVectorDimensions(v.getDimension());
>     }
156a178,188
>     protected void checkVectorDimensions(int n) {
>         int d = getDimension();
>         if (d != n) {
>             throw new DimensionMismatchException(d, n);
>         }
>     }
> 
>     
> 
> 
> 
158d189
<     RealVector add(double[] v);
159a191,197
>     protected void checkIndex(final int index) {
>         if (index < 0 ||
>             index >= getDimension()) {
>             throw new OutOfRangeException(LocalizedFormats.INDEX,
>                                           index, 0, getDimension() - 1);
>         }
>     }
169c207,215
<     RealVector subtract(RealVector v);
---
>     public RealVector add(double[] v) {
>         double[] result = v.clone();
>         Iterator<Entry> it = sparseIterator();
>         Entry e;
>         while (it.hasNext() && (e = it.next()) != null) {
>             result[e.getIndex()] += e.getValue();
>         }
>         return new ArrayRealVector(result, false);
>     }
179c225,238
<     RealVector subtract(double[] v);
---
>     public RealVector add(RealVector v) {
>         if (v instanceof ArrayRealVector) {
>             double[] values = ((ArrayRealVector)v).getDataRef();
>             return add(values);
>         }
>         RealVector result = v.copy();
>         Iterator<Entry> it = sparseIterator();
>         Entry e;
>         while (it.hasNext() && (e = it.next()) != null) {
>             final int index = e.getIndex();
>             result.setEntry(index, e.getValue() + result.getEntry(index));
>         }
>         return result;
>     }
187c246,257
<     RealVector mapAdd(double d);
---
> 
> 
>     public RealVector subtract(double[] v) {
>         double[] result = v.clone();
>         Iterator<Entry> it = sparseIterator();
>         Entry e;
>         while (it.hasNext() && (e = it.next()) != null) {
>             final int index = e.getIndex();
>             result[index] = e.getValue() - result[index];
>         }
>         return new ArrayRealVector(result, false);
>     }
196c266,280
<     RealVector mapAddToSelf(double d);
---
> 
>     public RealVector subtract(RealVector v) {
>         if (v instanceof ArrayRealVector) {
>             double[] values = ((ArrayRealVector)v).getDataRef();
>             return add(values);
>         }
>         RealVector result = v.copy();
>         Iterator<Entry> it = sparseIterator();
>         Entry e;
>         while (it.hasNext() && (e = it.next()) != null) {
>             final int index = e.getIndex();
>             v.setEntry(index, e.getValue() - result.getEntry(index));
>         }
>         return result;
>     }
204c288,290
<     RealVector mapSubtract(double d);
---
>     public RealVector mapAdd(double d) {
>         return copy().mapAddToSelf(d);
>     }
213c299,304
<     RealVector mapSubtractToSelf(double d);
---
>     public RealVector mapAddToSelf(double d) {
>         if (d != 0) {
>             return mapToSelf(FunctionUtils.fix2ndArgument(new Add(), d));
>         }
>         return this;
>     }
220,221c311
< 
<     RealVector mapMultiply(double d);
---
>     public abstract RealVector copy();
230c320,322
<     RealVector mapMultiplyToSelf(double d);
---
>     public double dotProduct(double[] v) {
>         return dotProduct(new ArrayRealVector(v, false));
>     }
238c330,340
<     RealVector mapDivide(double d);
---
> 
>     public double dotProduct(RealVector v) {
>         checkVectorDimensions(v);
>         double d = 0;
>         Iterator<Entry> it = sparseIterator();
>         Entry e;
>         while (it.hasNext() && (e = it.next()) != null) {
>             d += e.getValue() * v.getEntry(e.getIndex());
>         }
>         return d;
>     }
247c349,358
<     RealVector mapDivideToSelf(double d);
---
>     public double cosine(RealVector v) {
>         final double norm = getNorm();
>         final double vNorm = v.getNorm();
> 
>         if (norm == 0 ||
>             vNorm == 0) {
>             throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
>         }
>         return dotProduct(v) / (norm * vNorm);
>     }
256c367,369
<     RealVector ebeMultiply(RealVector v);
---
>     public double cosine(double[] v) {
>         return cosine(new ArrayRealVector(v, false));
>     }
265c378,379
<     RealVector ebeMultiply(double[] v);
---
> 
>     public abstract RealVector ebeDivide(RealVector v);
274c388,391
<     RealVector ebeDivide(RealVector v);
---
> 
>     public RealVector ebeDivide(double[] v) {
>         return ebeDivide(new ArrayRealVector(v, false));
>     }
283c400,401
<     RealVector ebeDivide(double[] v);
---
> 
>     public abstract RealVector ebeMultiply(RealVector v);
289c407,413
<      double[] getData();
---
> 
> 
> 
> 
>     public RealVector ebeMultiply(double[] v) {
>         return ebeMultiply(new ArrayRealVector(v, false));
>     }
298c422,438
<     double dotProduct(RealVector v);
---
> 
> 
> 
> 
> 
> 
>     public double getDistance(RealVector v) {
>         checkVectorDimensions(v);
>         double d = 0;
>         Iterator<Entry> it = iterator();
>         Entry e;
>         while (it.hasNext() && (e = it.next()) != null) {
>             final double diff = e.getValue() - v.getEntry(e.getIndex());
>             d += diff * diff;
>         }
>         return FastMath.sqrt(d);
>     }
307c447,455
<     double dotProduct(double[] v);
---
> 
> 
> 
> 
> 
> 
>     public double getDistance(double[] v) {
>         return getDistance(new ArrayRealVector(v,false));
>     }
316c464,475
<     double cosine(RealVector v);
---
> 
> 
>     public double getNorm() {
>         double sum = 0;
>         Iterator<Entry> it = sparseIterator();
>         Entry e;
>         while (it.hasNext() && (e = it.next()) != null) {
>             final double value = e.getValue();
>             sum += value * value;
>         }
>         return FastMath.sqrt(sum);
>     }
325c484,494
<     double cosine(double[] v);
---
> 
> 
>     public double getL1Norm() {
>         double norm = 0;
>         Iterator<Entry> it = sparseIterator();
>         Entry e;
>         while (it.hasNext() && (e = it.next()) != null) {
>             norm += FastMath.abs(e.getValue());
>         }
>         return norm;
>     }
336c505,513
<     double getNorm();
---
>     public double getLInfNorm() {
>         double norm = 0;
>         Iterator<Entry> it = sparseIterator();
>         Entry e;
>         while (it.hasNext() && (e = it.next()) != null) {
>             norm = FastMath.max(norm, FastMath.abs(e.getValue()));
>         }
>         return norm;
>     }
347c524,537
<     double getL1Norm();
---
> 
> 
> 
> 
>     public double getL1Distance(RealVector v) {
>         checkVectorDimensions(v);
>         double d = 0;
>         Iterator<Entry> it = iterator();
>         Entry e;
>         while (it.hasNext() && (e = it.next()) != null) {
>             d += FastMath.abs(e.getValue() - v.getEntry(e.getIndex()));
>         }
>         return d;
>     }
358c548,561
<     double getLInfNorm();
---
> 
> 
> 
> 
>     public double getL1Distance(double[] v) {
>         checkVectorDimensions(v.length);
>         double d = 0;
>         Iterator<Entry> it = iterator();
>         Entry e;
>         while (it.hasNext() && (e = it.next()) != null) {
>             d += FastMath.abs(e.getValue() - v[e.getIndex()]);
>         }
>         return d;
>     }
373c576,585
<     double getDistance(RealVector v);
---
>     public double getLInfDistance(RealVector v) {
>         checkVectorDimensions(v);
>         double d = 0;
>         Iterator<Entry> it = iterator();
>         Entry e;
>         while (it.hasNext() && (e = it.next()) != null) {
>             d = FastMath.max(FastMath.abs(e.getValue() - v.getEntry(e.getIndex())), d);
>         }
>         return d;
>     }
388c600,609
<     double getDistance(double[] v);
---
>     public double getLInfDistance(double[] v) {
>         checkVectorDimensions(v.length);
>         double d = 0;
>         Iterator<Entry> it = iterator();
>         Entry e;
>         while (it.hasNext() && (e = it.next()) != null) {
>             d = FastMath.max(FastMath.abs(e.getValue() - v[e.getIndex()]), d);
>         }
>         return d;
>     }
393a615,629
>     public int getMinIndex() {
>         int minIndex    = -1;
>         double minValue = Double.POSITIVE_INFINITY;
>         Iterator<Entry> iterator = iterator();
>         while (iterator.hasNext()) {
>             final Entry entry = iterator.next();
>             if (entry.getValue() <= minValue) {
>                 minIndex = entry.getIndex();
>                 minValue = entry.getValue();
>             }
>         }
>         return minIndex;
>     }
> 
>     
395a632,635
>     public double getMinValue() {
>         final int minIndex = getMinIndex();
>         return minIndex < 0 ? Double.NaN : getEntry(minIndex);
>     }
396a637
>     
399a641,653
>     public int getMaxIndex() {
>         int maxIndex    = -1;
>         double maxValue = Double.NEGATIVE_INFINITY;
>         Iterator<Entry> iterator = iterator();
>         while (iterator.hasNext()) {
>             final Entry entry = iterator.next();
>             if (entry.getValue() >= maxValue) {
>                 maxIndex = entry.getIndex();
>                 maxValue = entry.getValue();
>             }
>         }
>         return maxIndex;
>     }
400a655
>     
403c658,662
<     double getL1Distance(RealVector v);
---
>     public double getMaxValue() {
>         final int maxIndex = getMaxIndex();
>         return maxIndex < 0 ? Double.NaN : getEntry(maxIndex);
>     }
> 
410a670,672
>     public RealVector mapMultiply(double d) {
>         return copy().mapMultiplyToSelf(d);
>     }
411a674
>     
418c681,683
<     double getL1Distance(double[] v);
---
>     public RealVector mapMultiplyToSelf(double d){
>         return mapToSelf(FunctionUtils.fix2ndArgument(new Multiply(), d));
>     }
425a691,693
>     public RealVector mapSubtract(double d) {
>         return copy().mapSubtractToSelf(d);
>     }
426a695
>     
433c702,704
<     double getLInfDistance(RealVector v);
---
>     public RealVector mapSubtractToSelf(double d){
>         return mapAddToSelf(-d);
>     }
440a712,714
>     public RealVector mapDivide(double d) {
>         return copy().mapDivideToSelf(d);
>     }
441a716
>     
448c723,725
<     double getLInfDistance(double[] v);
---
>     public RealVector mapDivideToSelf(double d){
>         return mapToSelf(FunctionUtils.fix2ndArgument(new Divide(), d));
>     }
455c732,754
<     RealVector unitVector();
---
>     public RealMatrix outerProduct(RealVector v) {
>         RealMatrix product;
>         if (v instanceof SparseRealVector || this instanceof SparseRealVector) {
>             product = new OpenMapRealMatrix(this.getDimension(),
>                                             v.getDimension());
>         } else {
>             product = new Array2DRowRealMatrix(this.getDimension(),
>                                                v.getDimension());
>         }
>         Iterator<Entry> thisIt = sparseIterator();
>         Entry thisE = null;
>         while (thisIt.hasNext() && (thisE = thisIt.next()) != null) {
>             Iterator<Entry> otherIt = v.sparseIterator();
>             Entry otherE = null;
>             while (otherIt.hasNext() && (otherE = otherIt.next()) != null) {
>                 product.setEntry(thisE.getIndex(), otherE.getIndex(),
>                                  thisE.getValue() * otherE.getValue());
>             }
>         }
> 
>         return product;
> 
>     }
462c761,763
<     void unitize();
---
>     public RealMatrix outerProduct(double[] v) {
>         return outerProduct(new ArrayRealVector(v, false));
>     }
470c771,773
<     RealVector projection(RealVector v);
---
> 
> 
>     public abstract RealVector projection(RealVector v);
478c781,797
<     RealVector projection(double[] v);
---
> 
> 
>     public RealVector projection(double[] v) {
>         return projection(new ArrayRealVector(v, false));
>     }
> 
>     
> 
> 
> 
>     public void set(double value) {
>         Iterator<Entry> it = iterator();
>         Entry e = null;
>         while (it.hasNext() && (e = it.next()) != null) {
>             e.setValue(value);
>         }
>     }
485c804,812
<     RealMatrix outerProduct(RealVector v);
---
> 
>     public double[] toArray() {
>         int dim = getDimension();
>         double[] values = new double[dim];
>         for (int i = 0; i < dim; i++) {
>             values[i] = getEntry(i);
>         }
>         return values;
>     }
492c819,821
<     RealMatrix outerProduct(double[] v);
---
>     public double[] getData() {
>         return toArray();
>     }
500a830,837
>     public RealVector unitVector() {
>         RealVector copy = copy();
>         copy.unitize();
>         return copy;
>     }
> 
>     
> 
503c840,845
<     double getEntry(int index);
---
> 
> 
> 
>     public void unitize() {
>         mapDivideToSelf(getNorm());
>     }
513c855,860
<     void setEntry(int index, double value);
---
> 
> 
> 
>     public Iterator<Entry> sparseIterator() {
>         return new SparseEntryIterator();
>     }
519c866,894
<     int getDimension();
---
> 
> 
>     public Iterator<Entry> iterator() {
>         final int dim = getDimension();
>         return new Iterator<Entry>() {
> 
>             
>             private int i = 0;
> 
>             
>             private Entry e = new Entry();
> 
>             
>             public boolean hasNext() {
>                 return i < dim;
>             }
> 
>             
>             public Entry next() {
>                 e.setIndex(i++);
>                 return e;
>             }
> 
>             
>             public void remove() {
>                 throw new MathUnsupportedOperationException();
>             }
>         };
>     }
526d900
<     RealVector append(RealVector v);
528d901
<     
533c906,909
<     RealVector append(double d);
---
> 
>     public RealVector map(UnivariateRealFunction function) {
>         return copy().mapToSelf(function);
>     }
540d915
<     RealVector append(double[] a);
542d916
<     
550c924,932
<     RealVector getSubVector(int index, int n);
---
> 
>     public RealVector mapToSelf(UnivariateRealFunction function) {
>         Iterator<Entry> it = (function.value(0) == 0) ? sparseIterator() : iterator();
>         Entry e;
>         while (it.hasNext() && (e = it.next()) != null) {
>             e.setValue(function.value(e.getValue()));
>         }
>         return this;
>     }
560c942,947
<     void setSubVector(int index, RealVector v);
---
> 
> 
> 
>     public RealVector combine(double a, double b, double[] y) {
>         return copy().combineToSelf(a, b, y);
>     }
570c957,962
<     void setSubVector(int index, double[] v);
---
> 
> 
> 
>     public RealVector combine(double a, double b, RealVector y) {
>         return copy().combineToSelf(a, b, y);
>     }
576d967
<     void set(double value);
578d968
<     
584c974,978
<     double[] toArray();
---
> 
> 
>     public RealVector combineToSelf(double a, double b, double[] y) {
>         return combineToSelf(a, b, new ArrayRealVector(y, false));
>     }
591d984
<     boolean isNaN();
593d985
<     
599c991,1000
<     boolean isInfinite();
---
> 
>     public RealVector combineToSelf(double a, double b, RealVector y) {
>         checkVectorDimensions(y);
>         for (int i = 0; i < getDimension(); i++) {
>             final double xi = getEntry(i);
>             final double yi = y.getEntry(i);
>             setEntry(i, a * xi + b * yi);
>         }
>         return this;
>     }
601a1003,1005
>     protected class Entry {
>         
>         private int index;
602a1007,1010
>         
>         public Entry() {
>             setIndex(0);
>         }
603a1012
>         
607a1017,1019
>         public double getValue() {
>             return getEntry(getIndex());
>         }
608a1021
>         
612d1024
<     RealVector combine(double a, double b, double[] y);
614c1026,1028
<     
---
>         public void setValue(double value) {
>             setEntry(getIndex(), value);
>         }
615a1030
>         
619a1035,1037
>         public int getIndex() {
>             return index;
>         }
620a1039
>         
625c1044,1047
<     RealVector combine(double a, double b, RealVector y);
---
>         public void setIndex(int index) {
>             this.index = index;
>         }
>     }
639c1061,1117
<     RealVector combineToSelf(double a, double b, double[] y);
---
> 
>     protected class SparseEntryIterator implements Iterator<Entry> {
>         
>         private final int dim;
>         
>         private Entry current;
>         
>         private Entry next;
> 
>         
>         protected SparseEntryIterator() {
>             dim = getDimension();
>             current = new Entry();
>             next = new Entry();
>             if (next.getValue() == 0) {
>                 advance(next);
>             }
>         }
> 
>         
> 
> 
> 
> 
>         protected void advance(Entry e) {
>             if (e == null) {
>                 return;
>             }
>             do {
>                 e.setIndex(e.getIndex() + 1);
>             } while (e.getIndex() < dim && e.getValue() == 0);
>             if (e.getIndex() >= dim) {
>                 e.setIndex(-1);
>             }
>         }
> 
>         
>         public boolean hasNext() {
>             return next.getIndex() >= 0;
>         }
> 
>         
>         public Entry next() {
>             int index = next.getIndex();
>             if (index < 0) {
>                 throw new NoSuchElementException();
>             }
>             current.setIndex(index);
>             advance(next);
>             return current;
>         }
> 
>         
>         public void remove() {
>             throw new MathUnsupportedOperationException();
>         }
>     }
653c1131,1561
<     RealVector combineToSelf(double a, double b, RealVector y);
---
> 
> 
> 
> 
> 
> 
>     public static RealVector unmodifiableRealVector(final RealVector v) {
>         
> 
> 
> 
> 
> 
> 
> 
> 
>         return new RealVector() {
>             
>             @Override
>             public RealVector mapToSelf(UnivariateRealFunction function) {
>                 throw new MathUnsupportedOperationException();
>             }
> 
>             
>             @Override
>             public RealVector map(UnivariateRealFunction function) {
>                 return v.map(function);
>             }
> 
>             
>             @Override
>             public Iterator<Entry> iterator() {
>                 final Iterator<Entry> i = v.iterator();
>                 return new Iterator<Entry>() {
>                     
>                     private final UnmodifiableEntry e = new UnmodifiableEntry();
> 
>                     
>                     @Override
>                     public boolean hasNext() {
>                         return i.hasNext();
>                     }
> 
>                     
>                     @Override
>                     public Entry next() {
>                         e.setIndex(i.next().getIndex());
>                         return e;
>                     }
> 
>                     
>                     @Override
>                     public void remove() {
>                         throw new MathUnsupportedOperationException();
>                     }
>                 };
>             }
> 
>             
>             @Override
>             public Iterator<Entry> sparseIterator() {
>                 final Iterator<Entry> i = v.sparseIterator();
> 
>                 return new Iterator<Entry>() {
>                     
>                     private final UnmodifiableEntry e = new UnmodifiableEntry();
> 
>                     
>                     @Override
>                     public boolean hasNext() {
>                         return i.hasNext();
>                     }
> 
>                     
>                     @Override
>                     public Entry next() {
>                         e.setIndex(i.next().getIndex());
>                         return e;
>                     }
> 
>                     
>                     @Override
>                     public void remove() {
>                         throw new MathUnsupportedOperationException();
>                     }
>                 };
>             }
> 
>             
>             @Override
>             public RealVector copy() {
>                 return v.copy();
>             }
> 
>             
>             @Override
>             public RealVector add(RealVector w) {
>                 return v.add(w);
>             }
> 
>             
>             @Override
>             public RealVector add(double[] w) {
>                 return v.add(w);
>             }
> 
>             
>             @Override
>             public RealVector subtract(RealVector w) {
>                 return v.subtract(w);
>             }
> 
>             
>             @Override
>             public RealVector subtract(double[] w) {
>                 return v.subtract(w);
>             }
> 
>             
>             @Override
>             public RealVector mapAdd(double d) {
>                 return v.mapAdd(d);
>             }
> 
>             
>             @Override
>             public RealVector mapAddToSelf(double d) {
>                 throw new MathUnsupportedOperationException();
>             }
> 
>             
>             @Override
>             public RealVector mapSubtract(double d) {
>                 return v.mapSubtract(d);
>             }
> 
>             
>             @Override
>             public RealVector mapSubtractToSelf(double d) {
>                 throw new MathUnsupportedOperationException();
>             }
> 
>             
>             @Override
>             public RealVector mapMultiply(double d) {
>                 return v.mapMultiply(d);
>             }
> 
>             
>             @Override
>             public RealVector mapMultiplyToSelf(double d) {
>                 throw new MathUnsupportedOperationException();
>             }
> 
>             
>             @Override
>             public RealVector mapDivide(double d) {
>                 return v.mapDivide(d);
>             }
> 
>             
>             @Override
>             public RealVector mapDivideToSelf(double d) {
>                 throw new MathUnsupportedOperationException();
>             }
> 
>             
>             @Override
>             public RealVector ebeMultiply(RealVector w) {
>                 return v.ebeMultiply(w);
>             }
> 
>             
>             @Override
>             public RealVector ebeMultiply(double[] w) {
>                 return v.ebeMultiply(w);
>             }
> 
>             
>             @Override
>             public RealVector ebeDivide(RealVector w) {
>                 return v.ebeDivide(w);
>             }
> 
>             
>             @Override
>             public RealVector ebeDivide(double[] w) {
>                 return v.ebeDivide(w);
>             }
> 
>             
>             @Override
>             public double[] getData() {
>                 
>                 
>                 
>                 return v.getData();
>             }
> 
>             
>             @Override
>             public double dotProduct(RealVector w) {
>                 return v.dotProduct(w);
>             }
> 
>             
>             @Override
>             public double dotProduct(double[] w) {
>                 return v.dotProduct(w);
>             }
> 
>             
>             @Override
>             public double cosine(RealVector w) {
>                 return v.cosine(w);
>             }
> 
>             
>             @Override
>             public double cosine(double[] w) {
>                 return v.cosine(w);
>             }
> 
>             
>             @Override
>             public double getNorm() {
>                 return v.getNorm();
>             }
> 
>             
>             @Override
>             public double getL1Norm() {
>                 return v.getL1Norm();
>             }
> 
>             
>             @Override
>             public double getLInfNorm() {
>                 return v.getLInfNorm();
>             }
> 
>             
>             @Override
>             public double getDistance(RealVector w) {
>                 return v.getDistance(w);
>             }
> 
>             
>             @Override
>             public double getDistance(double[] w) {
>                 return v.getDistance(w);
>             }
> 
>             
>             @Override
>             public double getL1Distance(RealVector w) {
>                 return v.getL1Distance(w);
>             }
> 
>             
>             @Override
>             public double getL1Distance(double[] w) {
>                 return v.getL1Distance(w);
>             }
> 
>             
>             @Override
>             public double getLInfDistance(RealVector w) {
>                 return v.getLInfDistance(w);
>             }
> 
>             
>             @Override
>             public double getLInfDistance(double[] w) {
>                 return v.getLInfDistance(w);
>             }
> 
>             
>             @Override
>             public RealVector unitVector() {
>                 return v.unitVector();
>             }
> 
>             
>             @Override
>             public void unitize() {
>                 throw new MathUnsupportedOperationException();
>             }
> 
>             
>             @Override
>             public RealVector projection(RealVector w) {
>                 return v.projection(w);
>             }
> 
>             
>             @Override
>             public RealVector projection(double[] w) {
>                 return v.projection(w);
>             }
> 
>             
>             @Override
>             public RealMatrix outerProduct(RealVector w) {
>                 return v.outerProduct(w);
>             }
> 
>             
>             @Override
>             public RealMatrix outerProduct(double[] w) {
>                 return v.outerProduct(w);
>             }
> 
>             
>             @Override
>             public double getEntry(int index) {
>                 return v.getEntry(index);
>             }
> 
>             
>             @Override
>             public void setEntry(int index, double value) {
>                 throw new MathUnsupportedOperationException();
>             }
> 
>             
>             @Override
>             public int getDimension() {
>                 return v.getDimension();
>             }
> 
>             
>             @Override
>             public RealVector append(RealVector w) {
>                 return v.append(w);
>             }
> 
>             
>             @Override
>             public RealVector append(double d) {
>                 return v.append(d);
>             }
> 
>             
>             @Override
>             public RealVector append(double[] a) {
>                 return v.append(a);
>             }
> 
>             
>             @Override
>             public RealVector getSubVector(int index, int n) {
>                 return v.getSubVector(index, n);
>             }
> 
>             
>             @Override
>             public void setSubVector(int index, RealVector w) {
>                 throw new MathUnsupportedOperationException();
>             }
> 
>             
>             @Override
>             public void setSubVector(int index, double[] w) {
>                 throw new MathUnsupportedOperationException();
>             }
> 
>             
>             @Override
>             public void set(double value) {
>                 throw new MathUnsupportedOperationException();
>             }
> 
>             
>             @Override
>             public double[] toArray() {
>                 return v.toArray();
>             }
> 
>             
>             @Override
>             public boolean isNaN() {
>                 return v.isNaN();
>             }
> 
>             
>             @Override
>             public boolean isInfinite() {
>                 return v.isInfinite();
>             }
> 
>             
>             @Override
>             public RealVector combine(double a, double b, double[] y) {
>                 return v.combine(a, b, y);
>             }
> 
>             
>             @Override
>             public RealVector combine(double a, double b, RealVector y) {
>                 return v.combine(a, b, y);
>             }
> 
>             
>             @Override
>             public RealVector combineToSelf(double a, double b, double[] y) {
>                 throw new MathUnsupportedOperationException();
>             }
> 
>             
>             @Override
>             public RealVector combineToSelf(double a, double b, RealVector y) {
>                 throw new MathUnsupportedOperationException();
>             }
> 
>             
>             class UnmodifiableEntry extends Entry {
>                 
>                 @Override
>                     public double getValue() {
>                     return v.getEntry(getIndex());
>                 }
> 
>                 
>                 @Override
>                     public void setValue(double value) {
>                     throw new MathUnsupportedOperationException();
>                 }
>             }
>         };
>     }
