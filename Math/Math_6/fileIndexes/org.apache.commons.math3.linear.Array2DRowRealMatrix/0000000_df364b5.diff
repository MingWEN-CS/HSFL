1a2,625
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> package org.apache.commons.math.linear;
> 
> import java.io.Serializable;
> 
> import org.apache.commons.math.MathRuntimeException;
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> public class Array2DRowRealMatrix extends AbstractRealMatrix implements Serializable {
>     
>     
>     private static final long serialVersionUID = -1067294169172445528L;
> 
>     
>     protected double data[][];
> 
>     
> 
> 
>     public Array2DRowRealMatrix() {
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
>     public Array2DRowRealMatrix(final int rowDimension, final int columnDimension)
>         throws IllegalArgumentException {
>         super(rowDimension, columnDimension);
>         data = new double[rowDimension][columnDimension];
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Array2DRowRealMatrix(final double[][] d)
>         throws IllegalArgumentException, NullPointerException {
>         copyIn(d);
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)
>         throws IllegalArgumentException, NullPointerException {
>         if (copyArray) {
>             copyIn(d);
>         } else {
>             if (d == null) {
>                 throw new NullPointerException();
>             }   
>             final int nRows = d.length;
>             if (nRows == 0) {
>                 throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one row"); 
>             }
>             final int nCols = d[0].length;
>             if (nCols == 0) {
>                 throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column"); 
>             }
>             for (int r = 1; r < nRows; r++) {
>                 if (d[r].length != nCols) {
>                     throw MathRuntimeException.createIllegalArgumentException(
>                             "some rows have length {0} while others have length {1}",
>                             nCols, d[r].length);
>                 }
>             }       
>             data = d;
>         }
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
>     public Array2DRowRealMatrix(final double[] v) {
>         final int nRows = v.length;
>         data = new double[nRows][1];
>         for (int row = 0; row < nRows; row++) {
>             data[row][0] = v[row];
>         }
>     }
> 
>     
>     @Override
>     public RealMatrix createMatrix(final int rowDimension, final int columnDimension)
>         throws IllegalArgumentException {
>         return new Array2DRowRealMatrix(rowDimension, columnDimension);
>     }
> 
>     
>     @Override
>     public RealMatrix copy() {
>         return new Array2DRowRealMatrix(copyOut(), false);
>     }
> 
>     
>     @Override
>     public RealMatrix add(final RealMatrix m)
>         throws IllegalArgumentException {
>         try {
>             return add((Array2DRowRealMatrix) m);
>         } catch (ClassCastException cce) {
>             return super.add(m);
>         }
>     }
> 
>     
> 
> 
> 
> 
> 
> 
>     public Array2DRowRealMatrix add(final Array2DRowRealMatrix m)
>         throws IllegalArgumentException {
> 
>         
>         MatrixUtils.checkAdditionCompatible(this, m);
> 
>         final int rowCount    = getRowDimension();
>         final int columnCount = getColumnDimension();
>         final double[][] outData = new double[rowCount][columnCount];
>         for (int row = 0; row < rowCount; row++) {
>             final double[] dataRow    = data[row];
>             final double[] mRow       = m.data[row];
>             final double[] outDataRow = outData[row];
>             for (int col = 0; col < columnCount; col++) {
>                 outDataRow[col] = dataRow[col] + mRow[col];
>             }
>         }
> 
>         return new Array2DRowRealMatrix(outData, false);
> 
>     }
> 
>     
>     @Override
>     public RealMatrix subtract(final RealMatrix m)
>         throws IllegalArgumentException {
>         try {
>             return subtract((Array2DRowRealMatrix) m);
>         } catch (ClassCastException cce) {
>             return super.subtract(m);
>         }
>     }
> 
>     
> 
> 
> 
> 
> 
> 
>     public Array2DRowRealMatrix subtract(final Array2DRowRealMatrix m)
>         throws IllegalArgumentException {
> 
>         
>         MatrixUtils.checkSubtractionCompatible(this, m);
> 
>         final int rowCount    = getRowDimension();
>         final int columnCount = getColumnDimension();
>         final double[][] outData = new double[rowCount][columnCount];
>         for (int row = 0; row < rowCount; row++) {
>             final double[] dataRow    = data[row];
>             final double[] mRow       = m.data[row];
>             final double[] outDataRow = outData[row];
>             for (int col = 0; col < columnCount; col++) {
>                 outDataRow[col] = dataRow[col] - mRow[col];
>             }
>         }
> 
>         return new Array2DRowRealMatrix(outData, false);
> 
>     }
> 
>     
>     @Override
>     public RealMatrix multiply(final RealMatrix m)
>         throws IllegalArgumentException {
>         try {
>             return multiply((Array2DRowRealMatrix) m);
>         } catch (ClassCastException cce) {
>             return super.multiply(m);
>         }
>     }
> 
>     
> 
> 
> 
> 
> 
> 
>     public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m)
>         throws IllegalArgumentException {
> 
>         
>         MatrixUtils.checkMultiplicationCompatible(this, m);
> 
>         final int nRows = this.getRowDimension();
>         final int nCols = m.getColumnDimension();
>         final int nSum = this.getColumnDimension();
>         final double[][] outData = new double[nRows][nCols];
>         for (int row = 0; row < nRows; row++) {
>             final double[] dataRow    = data[row];
>             final double[] outDataRow = outData[row];
>             for (int col = 0; col < nCols; col++) {
>                 double sum = 0;
>                 for (int i = 0; i < nSum; i++) {
>                     sum += dataRow[i] * m.data[i][col];
>                 }
>                 outDataRow[col] = sum;
>             }
>         }
> 
>         return new Array2DRowRealMatrix(outData, false);
> 
>     }
> 
>     
>     @Override
>     public double[][] getData() {
>         return copyOut();
>     }
> 
>     
> 
> 
> 
> 
> 
> 
>     public double[][] getDataRef() {
>         return data;
>     }
> 
>     
>     @Override
>     public void setSubMatrix(final double[][] subMatrix, final int row, final int column) 
>     throws MatrixIndexException {
>         if (data == null) {
>             if (row > 0) {
>                 throw MathRuntimeException.createIllegalStateException(
>                         "first {0} rows are not initialized yet",
>                         row);
>             }
>             if (column > 0) {
>                 throw MathRuntimeException.createIllegalStateException(
>                         "first {0} columns are not initialized yet",
>                         column);
>             }
>             final int nRows = subMatrix.length;
>             if (nRows == 0) {
>                 throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one row"); 
>             }
> 
>             final int nCols = subMatrix[0].length;
>             if (nCols == 0) {
>                 throw MathRuntimeException.createIllegalArgumentException("matrix must have at least one column"); 
>             }
>             data = new double[subMatrix.length][nCols];
>             for (int i = 0; i < data.length; ++i) {
>                 if (subMatrix[i].length != nCols) {
>                     throw MathRuntimeException.createIllegalArgumentException(
>                             "some rows have length {0} while others have length {1}",
>                             nCols, subMatrix[i].length); 
>                 }
>                 System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);
>             }
>         } else {
>             super.setSubMatrix(subMatrix, row, column);
>         }
> 
>     }
> 
>     
>     @Override
>     public double getEntry(final int row, final int column)
>         throws MatrixIndexException {
>         try {
>             return data[row][column];
>         } catch (ArrayIndexOutOfBoundsException e) {
>             throw new MatrixIndexException(
>                     "no entry at indices ({0}, {1}) in a {2}x{3} matrix",
>                     row, column, getRowDimension(), getColumnDimension());
>         }
>     }
> 
>     
>     @Override
>     public void setEntry(final int row, final int column, final double value)
>         throws MatrixIndexException {
>         try {
>             data[row][column] = value;
>         } catch (ArrayIndexOutOfBoundsException e) {
>             throw new MatrixIndexException(
>                     "no entry at indices ({0}, {1}) in a {2}x{3} matrix",
>                     row, column, getRowDimension(), getColumnDimension());
>         }
>     }
> 
>     
>     @Override
>     public void addToEntry(final int row, final int column, final double increment)
>         throws MatrixIndexException {
>         try {
>             data[row][column] += increment;
>         } catch (ArrayIndexOutOfBoundsException e) {
>             throw new MatrixIndexException(
>                     "no entry at indices ({0}, {1}) in a {2}x{3} matrix",
>                     row, column, getRowDimension(), getColumnDimension());
>         }      
>     }
> 
>     
>     @Override
>     public void multiplyEntry(final int row, final int column, final double factor)
>         throws MatrixIndexException {
>         try {
>             data[row][column] *= factor;
>         } catch (ArrayIndexOutOfBoundsException e) {
>             throw new MatrixIndexException(
>                     "no entry at indices ({0}, {1}) in a {2}x{3} matrix",
>                     row, column, getRowDimension(), getColumnDimension());
>         }      
>     }
> 
>     
>     @Override
>     public int getRowDimension() {
>         return (data == null) ? 0 : data.length;
>     }
> 
>     
>     @Override
>     public int getColumnDimension() {
>         return ((data == null) || (data[0] == null)) ? 0 : data[0].length;
>     }
> 
>     
>     @Override
>     public double[] operate(final double[] v)
>         throws IllegalArgumentException {
>         final int nRows = this.getRowDimension();
>         final int nCols = this.getColumnDimension();
>         if (v.length != nCols) {
>             throw MathRuntimeException.createIllegalArgumentException(
>                     "vector length mismatch: got {0} but expected {1}",
>                     v.length, nCols);
>         }
>         final double[] out = new double[nRows];
>         for (int row = 0; row < nRows; row++) {
>             final double[] dataRow = data[row];
>             double sum = 0;
>             for (int i = 0; i < nCols; i++) {
>                 sum += dataRow[i] * v[i];
>             }
>             out[row] = sum;
>         }
>         return out;
>     }
> 
>     
>     @Override
>     public double[] preMultiply(final double[] v)
>         throws IllegalArgumentException {
> 
>         final int nRows = getRowDimension();
>         final int nCols = getColumnDimension();
>         if (v.length != nRows) {
>             throw MathRuntimeException.createIllegalArgumentException(
>                     "vector length mismatch: got {0} but expected {1}",
>                     v.length, nRows);
>         }
> 
>         final double[] out = new double[nCols];
>         for (int col = 0; col < nCols; ++col) {
>             double sum = 0;
>             for (int i = 0; i < nRows; ++i) {
>                 sum += data[i][col] * v[i];
>             }
>             out[col] = sum;
>         }
> 
>         return out;
> 
>     }
> 
>     
>     @Override
>     public double walkInRowOrder(final RealMatrixChangingVisitor visitor)
>         throws MatrixVisitorException {
>         final int rows    = getRowDimension();
>         final int columns = getColumnDimension();
>         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);
>         for (int i = 0; i < rows; ++i) {
>             final double[] rowI = data[i];
>             for (int j = 0; j < columns; ++j) {
>                 rowI[j] = visitor.visit(i, j, rowI[j]);
>             }
>         }
>         return visitor.end();
>     }
> 
>     
>     @Override
>     public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)
>         throws MatrixVisitorException {
>         final int rows    = getRowDimension();
>         final int columns = getColumnDimension();
>         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);
>         for (int i = 0; i < rows; ++i) {
>             final double[] rowI = data[i];
>             for (int j = 0; j < columns; ++j) {
>                 visitor.visit(i, j, rowI[j]);
>             }
>         }
>         return visitor.end();
>     }
> 
>     
>     @Override
>     public double walkInRowOrder(final RealMatrixChangingVisitor visitor,
>                                  final int startRow, final int endRow,
>                                  final int startColumn, final int endColumn)
>         throws MatrixIndexException, MatrixVisitorException {
>         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
>         visitor.start(getRowDimension(), getColumnDimension(),
>                       startRow, endRow, startColumn, endColumn);
>         for (int i = startRow; i <= endRow; ++i) {
>             final double[] rowI = data[i];
>             for (int j = startColumn; j <= endColumn; ++j) {
>                 rowI[j] = visitor.visit(i, j, rowI[j]);
>             }
>         }
>         return visitor.end();
>     }
> 
>     
>     @Override
>     public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,
>                                  final int startRow, final int endRow,
>                                  final int startColumn, final int endColumn)
>         throws MatrixIndexException, MatrixVisitorException {
>         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
>         visitor.start(getRowDimension(), getColumnDimension(),
>                       startRow, endRow, startColumn, endColumn);
>         for (int i = startRow; i <= endRow; ++i) {
>             final double[] rowI = data[i];
>             for (int j = startColumn; j <= endColumn; ++j) {
>                 visitor.visit(i, j, rowI[j]);
>             }
>         }
>         return visitor.end();
>     }
> 
>     
>     @Override
>     public double walkInColumnOrder(final RealMatrixChangingVisitor visitor)
>         throws MatrixVisitorException {
>         final int rows    = getRowDimension();
>         final int columns = getColumnDimension();
>         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);
>         for (int j = 0; j < columns; ++j) {
>             for (int i = 0; i < rows; ++i) {
>                 final double[] rowI = data[i];
>                 rowI[j] = visitor.visit(i, j, rowI[j]);
>             }
>         }
>         return visitor.end();
>     }
> 
>     
>     @Override
>     public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor)
>         throws MatrixVisitorException {
>         final int rows    = getRowDimension();
>         final int columns = getColumnDimension();
>         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);
>         for (int j = 0; j < columns; ++j) {
>             for (int i = 0; i < rows; ++i) {
>                 visitor.visit(i, j, data[i][j]);
>             }
>         }
>         return visitor.end();
>     }
> 
>     
>     @Override
>     public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,
>                                     final int startRow, final int endRow,
>                                     final int startColumn, final int endColumn)
>         throws MatrixIndexException, MatrixVisitorException {
>         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
>         visitor.start(getRowDimension(), getColumnDimension(),
>                       startRow, endRow, startColumn, endColumn);
>         for (int j = startColumn; j <= endColumn; ++j) {
>             for (int i = startRow; i <= endRow; ++i) {
>                 final double[] rowI = data[i];
>                 rowI[j] = visitor.visit(i, j, rowI[j]);
>             }
>         }
>         return visitor.end();
>     }
> 
>     
>     @Override
>     public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,
>                                     final int startRow, final int endRow,
>                                     final int startColumn, final int endColumn)
>         throws MatrixIndexException, MatrixVisitorException {
>         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
>         visitor.start(getRowDimension(), getColumnDimension(),
>                       startRow, endRow, startColumn, endColumn);
>         for (int j = startColumn; j <= endColumn; ++j) {
>             for (int i = startRow; i <= endRow; ++i) {
>                 visitor.visit(i, j, data[i][j]);
>             }
>         }
>         return visitor.end();
>     }
> 
>     
> 
> 
> 
> 
>     private double[][] copyOut() {
>         final int nRows = this.getRowDimension();
>         final double[][] out = new double[nRows][this.getColumnDimension()];
>         
>         for (int i = 0; i < nRows; i++) {
>             System.arraycopy(data[i], 0, out[i], 0, data[i].length);
>         }
>         return out;
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     private void copyIn(final double[][] in) {
>         setSubMatrix(in, 0, 0);
>     }
> 
> }
