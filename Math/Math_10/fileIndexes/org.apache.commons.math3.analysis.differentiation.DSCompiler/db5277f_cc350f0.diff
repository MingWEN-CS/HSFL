1338a1339,1616
>     public void cosh(final double[] operand, final int operandOffset,
>                      final double[] result, final int resultOffset) {
> 
>         
>         double[] function = new double[1 + order];
>         function[0] = FastMath.cosh(operand[operandOffset]);
>         if (order > 0) {
>             function[1] = FastMath.sinh(operand[operandOffset]);
>             for (int i = 2; i <= order; ++i) {
>                 function[i] = function[i - 2];
>             }
>         }
> 
>         
>         compose(operand, operandOffset, function, result, resultOffset);
> 
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
>     public void sinh(final double[] operand, final int operandOffset,
>                      final double[] result, final int resultOffset) {
> 
>         
>         double[] function = new double[1 + order];
>         function[0] = FastMath.sinh(operand[operandOffset]);
>         if (order > 0) {
>             function[1] = FastMath.cosh(operand[operandOffset]);
>             for (int i = 2; i <= order; ++i) {
>                 function[i] = function[i - 2];
>             }
>         }
> 
>         
>         compose(operand, operandOffset, function, result, resultOffset);
> 
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
>     public void tanh(final double[] operand, final int operandOffset,
>                      final double[] result, final int resultOffset) {
> 
>         
>         final double[] function = new double[1 + order];
>         final double t = FastMath.tanh(operand[operandOffset]);
>         function[0] = t;
> 
>         if (order > 0) {
> 
>             
>             
>             
>             
>             
>             
>             
>             final double[] p = new double[order + 2];
>             p[1] = 1;
>             final double t2 = t * t;
>             for (int n = 1; n <= order; ++n) {
> 
>                 
>                 double v = 0;
>                 p[n + 1] = -n * p[n];
>                 for (int k = n + 1; k >= 0; k -= 2) {
>                     v = v * t2 + p[k];
>                     if (k > 2) {
>                         p[k - 2] = (k - 1) * p[k - 1] - (k - 3) * p[k - 3];
>                     } else if (k == 2) {
>                         p[0] = p[1];
>                     }
>                 }
>                 if ((n & 0x1) == 0) {
>                     v *= t;
>                 }
> 
>                 function[n] = v;
> 
>             }
>         }
> 
>         
>         compose(operand, operandOffset, function, result, resultOffset);
> 
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
>     public void acosh(final double[] operand, final int operandOffset,
>                      final double[] result, final int resultOffset) {
> 
>         
>         double[] function = new double[1 + order];
>         final double x = operand[operandOffset];
>         function[0] = FastMath.acosh(x);
>         if (order > 0) {
>             
>             
>             
>             
>             
>             
>             
>             final double[] p = new double[order];
>             p[0] = 1;
>             final double x2  = x * x;
>             final double f   = 1.0 / (x2 - 1);
>             double coeff = FastMath.sqrt(f);
>             function[1] = coeff * p[0];
>             for (int n = 2; n <= order; ++n) {
> 
>                 
>                 double v = 0;
>                 p[n - 1] = (1 - n) * p[n - 2];
>                 for (int k = n - 1; k >= 0; k -= 2) {
>                     v = v * x2 + p[k];
>                     if (k > 2) {
>                         p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];
>                     } else if (k == 2) {
>                         p[0] = -p[1];
>                     }
>                 }
>                 if ((n & 0x1) == 0) {
>                     v *= x;
>                 }
> 
>                 coeff *= f;
>                 function[n] = coeff * v;
> 
>             }
>         }
> 
>         
>         compose(operand, operandOffset, function, result, resultOffset);
> 
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
>     public void asinh(final double[] operand, final int operandOffset,
>                      final double[] result, final int resultOffset) {
> 
>         
>         double[] function = new double[1 + order];
>         final double x = operand[operandOffset];
>         function[0] = FastMath.asinh(x);
>         if (order > 0) {
>             
>             
>             
>             
>             
>             
>             
>             final double[] p = new double[order];
>             p[0] = 1;
>             final double x2    = x * x;
>             final double f     = 1.0 / (1 + x2);
>             double coeff = FastMath.sqrt(f);
>             function[1] = coeff * p[0];
>             for (int n = 2; n <= order; ++n) {
> 
>                 
>                 double v = 0;
>                 p[n - 1] = (1 - n) * p[n - 2];
>                 for (int k = n - 1; k >= 0; k -= 2) {
>                     v = v * x2 + p[k];
>                     if (k > 2) {
>                         p[k - 2] = (k - 1) * p[k - 1] + (k - 2 * n) * p[k - 3];
>                     } else if (k == 2) {
>                         p[0] = p[1];
>                     }
>                 }
>                 if ((n & 0x1) == 0) {
>                     v *= x;
>                 }
> 
>                 coeff *= f;
>                 function[n] = coeff * v;
> 
>             }
>         }
> 
>         
>         compose(operand, operandOffset, function, result, resultOffset);
> 
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
>     public void atanh(final double[] operand, final int operandOffset,
>                       final double[] result, final int resultOffset) {
> 
>         
>         double[] function = new double[1 + order];
>         final double x = operand[operandOffset];
>         function[0] = FastMath.atanh(x);
>         if (order > 0) {
>             
>             
>             
>             
>             
>             
>             
>             final double[] q = new double[order];
>             q[0] = 1;
>             final double x2 = x * x;
>             final double f  = 1.0 / (1 - x2);
>             double coeff = f;
>             function[1] = coeff * q[0];
>             for (int n = 2; n <= order; ++n) {
> 
>                 
>                 double v = 0;
>                 q[n - 1] = n * q[n - 2];
>                 for (int k = n - 1; k >= 0; k -= 2) {
>                     v = v * x2 + q[k];
>                     if (k > 2) {
>                         q[k - 2] = (k - 1) * q[k - 1] + (2 * n - k + 1) * q[k - 3];
>                     } else if (k == 2) {
>                         q[0] = q[1];
>                     }
>                 }
>                 if ((n & 0x1) == 0) {
>                     v *= x;
>                 }
> 
>                 coeff *= f;
>                 function[n] = coeff * v;
> 
>             }
>         }
> 
>         
>         compose(operand, operandOffset, function, result, resultOffset);
> 
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
