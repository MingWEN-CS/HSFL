















package org.apache.commons.math.distribution;

import java.io.Serializable;

import org.apache.commons.math.FunctionEvaluationException;
import org.apache.commons.math.MathException;
import org.apache.commons.math.MathRuntimeException;
import org.apache.commons.math.random.RandomDataImpl;









public abstract class AbstractIntegerDistribution extends AbstractDistribution
    implements IntegerDistribution, Serializable {

    
    private static final String WRONG_ORDER_ENDPOINTS_MESSAGE =
        "lower endpoint ({0}) must be less than or equal to upper endpoint ({1})";

    
    private static final String OUT_OF_RANGE_POINT =
        "{0} out of [{1}, {2}] range";

    
    private static final long serialVersionUID = -1146319659338487221L;

    



    protected final RandomDataImpl randomData = new RandomDataImpl();

    


    protected AbstractIntegerDistribution() {
        super();
    }

    














    public double cumulativeProbability(double x) throws MathException {
        return cumulativeProbability((int) Math.floor(x));
    }

    












    @Override
    public double cumulativeProbability(double x0, double x1)
        throws MathException {
        if (x0 > x1) {
            throw MathRuntimeException.createIllegalArgumentException(
                  WRONG_ORDER_ENDPOINTS_MESSAGE, x0, x1);
        }
        if (Math.floor(x0) < x0) {
            return cumulativeProbability(((int) Math.floor(x0)) + 1,
               (int) Math.floor(x1)); 
        } else { 
            return cumulativeProbability((int) Math.floor(x0),
                (int) Math.floor(x1));
        }
    }

    










    public abstract double cumulativeProbability(int x) throws MathException;

    









    public double probability(double x) {
        double fl = Math.floor(x);
        if (fl == x) {
            return this.probability((int) x);
        } else {
            return 0;
        }
    }

    










    public double cumulativeProbability(int x0, int x1) throws MathException {
        if (x0 > x1) {
            throw MathRuntimeException.createIllegalArgumentException(
                  WRONG_ORDER_ENDPOINTS_MESSAGE, x0, x1);
        }
        return cumulativeProbability(x1) - cumulativeProbability(x0 - 1);
    }

    










    public int inverseCumulativeProbability(final double p) throws MathException{
        if (p < 0.0 || p > 1.0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  OUT_OF_RANGE_POINT, p, 0.0, 1.0);
        }

        
        
        int x0 = getDomainLowerBound(p);
        int x1 = getDomainUpperBound(p);
        double pm;
        while (x0 < x1) {
            int xm = x0 + (x1 - x0) / 2;
            pm = checkedCumulativeProbability(xm);
            if (pm > p) {
                
                if (xm == x1) {
                    
                    
                    --x1;
                } else {
                    
                    x1 = xm;
                }
            } else {
                
                if (xm == x0) {
                    
                    
                    ++x0;
                } else {
                    
                    x0 = xm;
                }
            }
        }

        
        pm = checkedCumulativeProbability(x0);
        while (pm > p) {
            --x0;
            pm = checkedCumulativeProbability(x0);
        }

        return x0;
    }

    





    public void reseedRandomGenerator(long seed) {
        randomData.reSeed(seed);
    }

    








    public int sample() throws MathException {
        return randomData.nextInversionDeviate(this);
    }

    









    public int[] sample(int sampleSize) throws MathException {
        if (sampleSize <= 0) {
            MathRuntimeException.createIllegalArgumentException("Sample size must be positive");
        }
        int[] out = new int[sampleSize];
        for (int i = 0; i < sampleSize; i++) {
            out[i] = sample();
        }
        return out;
    }

    









    private double checkedCumulativeProbability(int argument) throws FunctionEvaluationException {
        double result = Double.NaN;
        try {
            result = cumulativeProbability(argument);
        } catch (MathException ex) {
            throw new FunctionEvaluationException(ex, argument, ex.getPattern(), ex.getArguments());
        }
        if (Double.isNaN(result)) {
            throw new FunctionEvaluationException(argument,
                "Discrete cumulative probability function returned NaN for argument {0}", argument);
        }
        return result;
    }

    








    protected abstract int getDomainLowerBound(double p);

    








    protected abstract int getDomainUpperBound(double p);
}
