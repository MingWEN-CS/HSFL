1a2,562
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> package org.apache.commons.math.geometry.euclidean.threed;
> 
> import java.io.Serializable;
> 
> import org.apache.commons.math.exception.MathArithmeticException;
> import org.apache.commons.math.exception.util.LocalizedFormats;
> import org.apache.commons.math.util.MathUtils;
> import org.apache.commons.math.util.FastMath;
> 
> 
> 
> 
> 
> 
> 
> public class Vector3D implements Serializable {
>   
>   public static final Vector3D ZERO   = new Vector3D(0, 0, 0);
> 
>   
>   public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);
> 
>   
>   public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);
> 
>   
>   public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);
> 
>   
>   public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);
> 
>   
>   public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);
> 
>   
>   public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);
> 
>   
>   
>   public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);
>   
> 
>   
>   public static final Vector3D POSITIVE_INFINITY =
>       new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
> 
>   
>   public static final Vector3D NEGATIVE_INFINITY =
>       new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
> 
>   
>   private static final Vector3DFormat DEFAULT_FORMAT =
>       Vector3DFormat.getInstance();
> 
>   
>   private static final long serialVersionUID = 5133268763396045979L;
> 
>   
>   private final double x;
> 
>   
>   private final double y;
> 
>   
>   private final double z;
> 
>   
> 
> 
> 
> 
> 
> 
> 
> 
>   public Vector3D(double x, double y, double z) {
>     this.x = x;
>     this.y = y;
>     this.z = z;
>   }
> 
>   
> 
> 
> 
> 
> 
> 
> 
>   public Vector3D(double alpha, double delta) {
>     double cosDelta = FastMath.cos(delta);
>     this.x = FastMath.cos(alpha) * cosDelta;
>     this.y = FastMath.sin(alpha) * cosDelta;
>     this.z = FastMath.sin(delta);
>   }
> 
>   
> 
> 
> 
> 
> 
>   public Vector3D(double a, Vector3D u) {
>     this.x = a * u.x;
>     this.y = a * u.y;
>     this.z = a * u.z;
>   }
> 
>   
> 
> 
> 
> 
> 
> 
> 
>   public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {
>     this.x = a1 * u1.x + a2 * u2.x;
>     this.y = a1 * u1.y + a2 * u2.y;
>     this.z = a1 * u1.z + a2 * u2.z;
>   }
> 
>   
> 
> 
> 
> 
> 
> 
> 
> 
> 
>   public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,
>                   double a3, Vector3D u3) {
>     this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x;
>     this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y;
>     this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z;
>   }
> 
>   
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>   public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,
>                   double a3, Vector3D u3, double a4, Vector3D u4) {
>     this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;
>     this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y + a4 * u4.y;
>     this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z + a4 * u4.z;
>   }
> 
>   
> 
> 
> 
>   public double getX() {
>     return x;
>   }
> 
>   
> 
> 
> 
>   public double getY() {
>     return y;
>   }
> 
>   
> 
> 
> 
>   public double getZ() {
>     return z;
>   }
> 
>   
> 
> 
>   public double getNorm1() {
>     return FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);
>   }
> 
>   
> 
> 
>   public double getNorm() {
>     return FastMath.sqrt (x * x + y * y + z * z);
>   }
> 
>   
> 
> 
>   public double getNormSq() {
>     return x * x + y * y + z * z;
>   }
> 
>   
> 
> 
>   public double getNormInf() {
>     return FastMath.max(FastMath.max(FastMath.abs(x), FastMath.abs(y)), FastMath.abs(z));
>   }
> 
>   
> 
> 
> 
>   public double getAlpha() {
>     return FastMath.atan2(y, x);
>   }
> 
>   
> 
> 
> 
>   public double getDelta() {
>     return FastMath.asin(z / getNorm());
>   }
> 
>   
> 
> 
> 
>   public Vector3D add(Vector3D v) {
>     return new Vector3D(x + v.x, y + v.y, z + v.z);
>   }
> 
>   
> 
> 
> 
> 
>   public Vector3D add(double factor, Vector3D v) {
>     return new Vector3D(x + factor * v.x, y + factor * v.y, z + factor * v.z);
>   }
> 
>   
> 
> 
> 
>   public Vector3D subtract(Vector3D v) {
>     return new Vector3D(x - v.x, y - v.y, z - v.z);
>   }
> 
>   
> 
> 
> 
> 
>   public Vector3D subtract(double factor, Vector3D v) {
>     return new Vector3D(x - factor * v.x, y - factor * v.y, z - factor * v.z);
>   }
> 
>   
> 
> 
> 
>   public Vector3D normalize() {
>     double s = getNorm();
>     if (s == 0) {
>       throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);
>     }
>     return scalarMultiply(1 / s);
>   }
> 
>   
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>   public Vector3D orthogonal() {
> 
>     double threshold = 0.6 * getNorm();
>     if (threshold == 0) {
>       throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
>     }
> 
>     if ((x >= -threshold) && (x <= threshold)) {
>       double inverse  = 1 / FastMath.sqrt(y * y + z * z);
>       return new Vector3D(0, inverse * z, -inverse * y);
>     } else if ((y >= -threshold) && (y <= threshold)) {
>       double inverse  = 1 / FastMath.sqrt(x * x + z * z);
>       return new Vector3D(-inverse * z, 0, inverse * x);
>     }
>     double inverse  = 1 / FastMath.sqrt(x * x + y * y);
>     return new Vector3D(inverse * y, -inverse * x, 0);
> 
>   }
> 
>   
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>   public static double angle(Vector3D v1, Vector3D v2) {
> 
>     double normProduct = v1.getNorm() * v2.getNorm();
>     if (normProduct == 0) {
>       throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
>     }
> 
>     double dot = dotProduct(v1, v2);
>     double threshold = normProduct * 0.9999;
>     if ((dot < -threshold) || (dot > threshold)) {
>       
>       Vector3D v3 = crossProduct(v1, v2);
>       if (dot >= 0) {
>         return FastMath.asin(v3.getNorm() / normProduct);
>       }
>       return FastMath.PI - FastMath.asin(v3.getNorm() / normProduct);
>     }
> 
>     
>     return FastMath.acos(dot / normProduct);
> 
>   }
> 
>   
> 
> 
>   public Vector3D negate() {
>     return new Vector3D(-x, -y, -z);
>   }
> 
>   
> 
> 
> 
>   public Vector3D scalarMultiply(double a) {
>     return new Vector3D(a * x, a * y, a * z);
>   }
> 
>   
> 
> 
> 
>   public boolean isNaN() {
>       return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);
>   }
> 
>   
> 
> 
> 
> 
> 
>   public boolean isInfinite() {
>       return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));
>   }
> 
>   
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>   @Override
>   public boolean equals(Object other) {
> 
>     if (this == other) {
>       return true;
>     }
> 
>     if (other instanceof Vector3D) {
>       final Vector3D rhs = (Vector3D)other;
>       if (rhs.isNaN()) {
>           return this.isNaN();
>       }
> 
>       return (x == rhs.x) && (y == rhs.y) && (z == rhs.z);
>     }
>     return false;
>   }
> 
>   
> 
> 
> 
> 
> 
> 
>   @Override
>   public int hashCode() {
>       if (isNaN()) {
>           return 8;
>       }
>       return 31 * (23 * MathUtils.hash(x) +  19 * MathUtils.hash(y) +  MathUtils.hash(z));
>   }
> 
>   
> 
> 
> 
> 
>   public static double dotProduct(Vector3D v1, Vector3D v2) {
>     return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
>   }
> 
>   
> 
> 
> 
> 
>   public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
> 
>       final double n1 = v1.getNormSq();
>       final double n2 = v2.getNormSq();
>       if ((n1 * n2) < MathUtils.SAFE_MIN) {
>           return ZERO;
>       }
> 
>       
>       
>       final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;
>       final double x1    = FastMath.scalb(v1.x, -deltaExp);
>       final double y1    = FastMath.scalb(v1.y, -deltaExp);
>       final double z1    = FastMath.scalb(v1.z, -deltaExp);
>       final double x2    = FastMath.scalb(v2.x,  deltaExp);
>       final double y2    = FastMath.scalb(v2.y,  deltaExp);
>       final double z2    = FastMath.scalb(v2.z,  deltaExp);
> 
>       
>       
>       
>       
>       
> 
>       
>       final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);
>       final double rho   = FastMath.rint(256 * ratio) / 256;
> 
>       final double x3 = x1 - rho * x2;
>       final double y3 = y1 - rho * y2;
>       final double z3 = z1 - rho * z2;
> 
>       
>       return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);
> 
>   }
> 
>   
> 
> 
> 
> 
> 
> 
> 
>   public static double distance1(Vector3D v1, Vector3D v2) {
>     final double dx = FastMath.abs(v2.x - v1.x);
>     final double dy = FastMath.abs(v2.y - v1.y);
>     final double dz = FastMath.abs(v2.z - v1.z);
>     return dx + dy + dz;
>   }
> 
>   
> 
> 
> 
> 
> 
> 
> 
>   public static double distance(Vector3D v1, Vector3D v2) {
>     final double dx = v2.x - v1.x;
>     final double dy = v2.y - v1.y;
>     final double dz = v2.z - v1.z;
>     return FastMath.sqrt(dx * dx + dy * dy + dz * dz);
>   }
> 
>   
> 
> 
> 
> 
> 
> 
> 
>   public static double distanceInf(Vector3D v1, Vector3D v2) {
>     final double dx = FastMath.abs(v2.x - v1.x);
>     final double dy = FastMath.abs(v2.y - v1.y);
>     final double dz = FastMath.abs(v2.z - v1.z);
>     return FastMath.max(FastMath.max(dx, dy), dz);
>   }
> 
>   
> 
> 
> 
> 
> 
> 
> 
>   public static double distanceSq(Vector3D v1, Vector3D v2) {
>     final double dx = v2.x - v1.x;
>     final double dy = v2.y - v1.y;
>     final double dz = v2.z - v1.z;
>     return dx * dx + dy * dy + dz * dz;
>   }
> 
>   
> 
> 
>   @Override
>   public String toString() {
>       return DEFAULT_FORMAT.format(this);
>   }
> 
> }
