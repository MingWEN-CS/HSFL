26d25
< import java.io.Serializable;
31a31,33
> import org.apache.commons.math3.distribution.AbstractRealDistribution;
> import org.apache.commons.math3.distribution.NormalDistribution;
> import org.apache.commons.math3.distribution.RealDistribution;
32a35
> import org.apache.commons.math3.exception.MathInternalError;
33a37
> import org.apache.commons.math3.exception.OutOfRangeException;
85c89,102
< public class EmpiricalDistribution implements Serializable {
---
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> public class EmpiricalDistribution extends AbstractRealDistribution {
196,197c213
< 
<     public void load(double[] in) throws NullArgumentException, MathIllegalStateException {
---
>     public void load(double[] in) throws NullArgumentException {
203,204c219,221
<         } catch (IOException e) {
<             throw new MathIllegalStateException(e, LocalizedFormats.SIMPLE_MESSAGE, e.getLocalizedMessage());
---
>         } catch (IOException ex) {
>             
>             throw new MathInternalError();
432c449
<                 FastMath.max((int) FastMath.ceil((value- min) / delta) - 1, 0),
---
>                 FastMath.max((int) FastMath.ceil((value - min) / delta) - 1, 0),
434c451
<         }
---
>     }
516,518c533,534
<         binUpperBounds[0] = min + delta;
<         for (int i = 1; i < binCount - 1; i++) {
<             binUpperBounds[i] = binUpperBounds[i-1] + delta;
---
>         for (int i = 0; i < binCount - 1; i++) {
>             binUpperBounds[i] = min + delta * (i + 1);
558a575,833
>     }
> 
>     
> 
>     
> 
> 
> 
>     public double probability(double x) {
>         return 0;
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public double density(double x) {
>         if (x < min || x > max) {
>             return 0d;
>         }
>         final int binIndex = findBin(x);
>         final RealDistribution kernel = getKernel(binStats.get(binIndex));
>         return kernel.density(x) * pB(binIndex) / kB(binIndex);
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public double cumulativeProbability(double x) {
>         if (x < min) {
>             return 0d;
>         } else if (x >= max) {
>             return 1d;
>         }
>         final int binIndex = findBin(x);
>         final double pBminus = pBminus(binIndex);
>         final double pB = pB(binIndex);
>         final double[] binBounds = getUpperBounds();
>         final double kB = kB(binIndex);
>         final double lower = binIndex == 0 ? min : binBounds[binIndex - 1];
>         final RealDistribution kernel = k(x);
>         final double withinBinCum =
>             (kernel.cumulativeProbability(x) -  kernel.cumulativeProbability(lower)) / kB;
>         return pBminus + pB * withinBinCum;
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public double inverseCumulativeProbability(final double p) throws OutOfRangeException {
>         if (p < 0.0 || p > 1.0) {
>             throw new OutOfRangeException(p, 0, 1);
>         }
> 
>         if (p == 0.0) {
>             return getSupportLowerBound();
>         }
> 
>         if (p == 1.0) {
>             return getSupportUpperBound();
>         }
> 
>         int i = 0;
>         while (cumBinP(i) < p) {
>             i++;
>         }
> 
>         final RealDistribution kernel = getKernel(binStats.get(i));
>         final double kB = kB(i);
>         final double[] binBounds = getUpperBounds();
>         final double lower = i == 0 ? min : binBounds[i - 1];
>         final double kBminus = kernel.cumulativeProbability(lower);
>         final double pB = pB(i);
>         final double pBminus = pBminus(i);
>         final double pCrit = p - pBminus;
>         if (pCrit <= 0) {
>             return lower;
>         }
>         return kernel.inverseCumulativeProbability(kBminus + pCrit * kB / pB);
>     }
> 
>     
> 
> 
> 
>     public double getNumericalMean() {
>        return sampleStats.getMean();
>     }
> 
>     
> 
> 
> 
>     public double getNumericalVariance() {
>         return sampleStats.getVariance();
>     }
> 
>     
> 
> 
> 
>     public double getSupportLowerBound() {
>        return min;
>     }
> 
>     
> 
> 
> 
>     public double getSupportUpperBound() {
>         return max;
>     }
> 
>     
> 
> 
> 
>     public boolean isSupportLowerBoundInclusive() {
>         return true;
>     }
> 
>     
> 
> 
> 
>     public boolean isSupportUpperBoundInclusive() {
>         return true;
>     }
> 
>     
> 
> 
> 
>     public boolean isSupportConnected() {
>         return true;
>     }
> 
>     
> 
> 
> 
>     @Override
>     public double sample() {
>         return getNextValue();
>     }
> 
>     
> 
> 
> 
>     @Override
>     public void reseedRandomGenerator(long seed) {
>         randomData.reSeed(seed);
>     }
> 
>     
> 
> 
> 
> 
> 
>     private double pB(int i) {
>         return i == 0 ? upperBounds[0] :
>             upperBounds[i] - upperBounds[i - 1];
>     }
> 
>     
> 
> 
> 
> 
> 
>     private double pBminus(int i) {
>         return i == 0 ? 0 : upperBounds[i - 1];
>     }
> 
>     
> 
> 
> 
> 
> 
> 
>     @SuppressWarnings("deprecation")
>     private double kB(int i) {
>         final double[] binBounds = getUpperBounds();
>         final RealDistribution kernel = getKernel(binStats.get(i));
>         return i == 0 ? kernel.cumulativeProbability(min, binBounds[0]) :
>             kernel.cumulativeProbability(binBounds[i - 1], binBounds[i]);
>     }
> 
>     
> 
> 
> 
> 
> 
>     private RealDistribution k(double x) {
>         final int binIndex = findBin(x);
>         return getKernel(binStats.get(binIndex));
>     }
> 
>     
> 
> 
> 
> 
> 
>     private double cumBinP(int binIndex) {
>         return upperBounds[binIndex];
>     }
> 
>     
> 
> 
> 
> 
> 
>     private RealDistribution getKernel(SummaryStatistics bStats) {
>         
>         return new NormalDistribution(
>                 bStats.getMean(), bStats.getStandardDeviation());
