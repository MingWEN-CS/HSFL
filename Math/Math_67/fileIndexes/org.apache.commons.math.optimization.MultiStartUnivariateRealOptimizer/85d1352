
















package org.apache.commons.math.optimization;

import java.util.Arrays;

import org.apache.commons.math.ConvergenceException;
import org.apache.commons.math.FunctionEvaluationException;
import org.apache.commons.math.MathRuntimeException;
import org.apache.commons.math.analysis.UnivariateRealFunction;
import org.apache.commons.math.random.RandomGenerator;












public class MultiStartUnivariateRealOptimizer implements UnivariateRealOptimizer {

    
    private static final long serialVersionUID = 5983375963110961019L;

    
    private final UnivariateRealOptimizer optimizer;

    
    private int maxIterations;

    
    private int maxEvaluations;

    
    private int totalIterations;

    
    private int totalEvaluations;

    
    private int starts;

    
    private RandomGenerator generator;

    
    private double[] optima;

    







    public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer,
                                             final int starts,
                                             final RandomGenerator generator) {
        this.optimizer        = optimizer;
        this.totalIterations  = 0;
        this.starts           = starts;
        this.generator        = generator;
        this.optima           = null;
        setMaximalIterationCount(Integer.MAX_VALUE);
        setMaxEvaluations(Integer.MAX_VALUE);
    }

    
    public double getFunctionValue() {
        return optimizer.getFunctionValue();
    }

    
    public double getResult() {
        return optimizer.getResult();
    }

    
    public double getAbsoluteAccuracy() {
        return optimizer.getAbsoluteAccuracy();
    }

    
    public int getIterationCount() {
        return totalIterations;
    }

    
    public int getMaximalIterationCount() {
        return maxIterations;
    }

    
    public int getMaxEvaluations() {
        return maxEvaluations;
    }

    
    public int getEvaluations() {
        return totalEvaluations;
    }

    
    public double getRelativeAccuracy() {
        return optimizer.getRelativeAccuracy();
    }

    
    public void resetAbsoluteAccuracy() {
        optimizer.resetAbsoluteAccuracy();
    }

    
    public void resetMaximalIterationCount() {
        optimizer.resetMaximalIterationCount();
    }

    
    public void resetRelativeAccuracy() {
        optimizer.resetRelativeAccuracy();
    }

    
    public void setAbsoluteAccuracy(double accuracy) {
        optimizer.setAbsoluteAccuracy(accuracy);
    }

    
    public void setMaximalIterationCount(int count) {
        this.maxIterations = count;
    }

    
    public void setMaxEvaluations(int maxEvaluations) {
        this.maxEvaluations = maxEvaluations;
    }

    
    public void setRelativeAccuracy(double accuracy) {
        optimizer.setRelativeAccuracy(accuracy);
    }

    

























    public double[] getOptima() throws IllegalStateException {
        if (optima == null) {
            throw MathRuntimeException.createIllegalStateException("no optimum computed yet");
        }
        return optima.clone();
    }

    
    public double optimize(final UnivariateRealFunction f, final GoalType goalType,
                           final double min, final double max)
        throws ConvergenceException,
            FunctionEvaluationException {

        optima           = new double[starts];
        totalIterations  = 0;
        totalEvaluations = 0;

        
        for (int i = 0; i < starts; ++i) {

            try {
                optimizer.setMaximalIterationCount(maxIterations - totalIterations);
                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);
                final double bound1 = min + generator.nextDouble() * (max - min);
                final double bound2 = min + generator.nextDouble() * (max - min);
                optima[i] = optimizer.optimize(f, goalType,
                                               Math.min(bound1, bound2),
                                               Math.max(bound1, bound2));
            } catch (FunctionEvaluationException fee) {
                optima[i] = Double.NaN;
            } catch (ConvergenceException ce) {
                optima[i] = Double.NaN;
            }

            totalIterations  += optimizer.getIterationCount();
            totalEvaluations += optimizer.getEvaluations();

        }

        
        int lastNaN = optima.length;
        for (int i = 0; i < lastNaN; ++i) {
            if (Double.isNaN(optima[i])) {
                optima[i] = optima[--lastNaN];
                optima[lastNaN + 1] = Double.NaN;
            }
        }
        Arrays.sort(optima, 0, lastNaN);
        if (goalType == GoalType.MAXIMIZE) {
            for (int i = 0, j = lastNaN - 1; i < j; ++i, --j) {
                double tmp = optima[i];
                optima[i] = optima[j];
                optima[j] = tmp;
            }
        }

        if (Double.isNaN(optima[0])) {
            throw new OptimizationException(
                    "none of the {0} start points lead to convergence",
                    starts);
        }

        
        return optima[0];

    }

    
    public double optimize(final UnivariateRealFunction f, final GoalType goalType,
                           final double min, final double max, final double startValue)
            throws ConvergenceException, FunctionEvaluationException {
        return optimize(f, goalType, min, max);
    }

}
