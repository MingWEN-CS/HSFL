
















package org.apache.commons.math.ode.sampling;

import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;

import org.apache.commons.math.MathRuntimeException;
import org.apache.commons.math.exception.MathUserException;


















public abstract class AbstractStepInterpolator
  implements StepInterpolator {

  
  protected double previousTime;

  
  protected double currentTime;

  
  protected double h;

  
  protected double[] currentState;

  
  protected double interpolatedTime;

  
  protected double[] interpolatedState;

  
  protected double[] interpolatedDerivatives;

  
  private boolean finalized;

  
  private boolean forward;

  
  private boolean dirtyState;


  










  protected AbstractStepInterpolator() {
    previousTime            = Double.NaN;
    currentTime             = Double.NaN;
    h                       = Double.NaN;
    interpolatedTime        = Double.NaN;
    currentState            = null;
    interpolatedState       = null;
    interpolatedDerivatives = null;
    finalized               = false;
    this.forward            = true;
    this.dirtyState         = true;
  }

  




  protected AbstractStepInterpolator(final double[] y, final boolean forward) {

    previousTime      = Double.NaN;
    currentTime       = Double.NaN;
    h                 = Double.NaN;
    interpolatedTime  = Double.NaN;

    currentState            = y;
    interpolatedState       = new double[y.length];
    interpolatedDerivatives = new double[y.length];

    finalized         = false;
    this.forward      = forward;
    this.dirtyState   = true;

  }

  
















  protected AbstractStepInterpolator(final AbstractStepInterpolator interpolator) {

    previousTime      = interpolator.previousTime;
    currentTime       = interpolator.currentTime;
    h                 = interpolator.h;
    interpolatedTime  = interpolator.interpolatedTime;

    if (interpolator.currentState != null) {
      currentState            = interpolator.currentState.clone();
      interpolatedState       = interpolator.interpolatedState.clone();
      interpolatedDerivatives = interpolator.interpolatedDerivatives.clone();
    } else {
      currentState            = null;
      interpolatedState       = null;
      interpolatedDerivatives = null;
    }

    finalized  = interpolator.finalized;
    forward    = interpolator.forward;
    dirtyState = interpolator.dirtyState;

  }

  




  protected void reinitialize(final double[] y, final boolean isForward) {

    previousTime      = Double.NaN;
    currentTime       = Double.NaN;
    h                 = Double.NaN;
    interpolatedTime  = Double.NaN;

    currentState            = y;
    interpolatedState       = new double[y.length];
    interpolatedDerivatives = new double[y.length];

    finalized         = false;
    this.forward      = isForward;
    this.dirtyState   = true;

  }

  
   public StepInterpolator copy() throws MathUserException {

     
     finalizeStep();

     
     return doCopy();

   }

   






   protected abstract StepInterpolator doCopy();

  



  public void shift() {
    previousTime = currentTime;
  }

  


  public void storeTime(final double t) {

    currentTime = t;
    h           = currentTime - previousTime;
    setInterpolatedTime(t);

    
    finalized  = false;

  }

  
  public double getPreviousTime() {
    return previousTime;
  }

  
  public double getCurrentTime() {
    return currentTime;
  }

  
  public double getInterpolatedTime() {
    return interpolatedTime;
  }

  
  public void setInterpolatedTime(final double time) {
      interpolatedTime = time;
      dirtyState       = true;
  }

  
  public boolean isForward() {
    return forward;
  }

  









  protected abstract void computeInterpolatedStateAndDerivatives(double theta,
                                                                 double oneMinusThetaH)
    throws MathUserException;

  
  public double[] getInterpolatedState() throws MathUserException {

      
      if (dirtyState) {
          final double oneMinusThetaH = currentTime - interpolatedTime;
          final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;
          computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);
          dirtyState = false;
      }

      return interpolatedState;

  }

  
  public double[] getInterpolatedDerivatives() throws MathUserException {

      
      if (dirtyState) {
          final double oneMinusThetaH = currentTime - interpolatedTime;
          final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;
          computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);
          dirtyState = false;
      }

      return interpolatedDerivatives;

  }

  








































  public final void finalizeStep()
    throws MathUserException {
    if (! finalized) {
      doFinalize();
      finalized = true;
    }
  }

  





  protected void doFinalize()
    throws MathUserException {
  }

  
  public abstract void writeExternal(ObjectOutput out)
    throws IOException;

  
  public abstract void readExternal(ObjectInput in)
    throws IOException, ClassNotFoundException;

  





  protected void writeBaseExternal(final ObjectOutput out)
    throws IOException {

    if (currentState == null) {
        out.writeInt(-1);
    } else {
        out.writeInt(currentState.length);
    }
    out.writeDouble(previousTime);
    out.writeDouble(currentTime);
    out.writeDouble(h);
    out.writeBoolean(forward);

    if (currentState != null) {
        for (int i = 0; i < currentState.length; ++i) {
            out.writeDouble(currentState[i]);
        }
    }

    out.writeDouble(interpolatedTime);

    
    

    
    try {
      finalizeStep();
    } catch (MathUserException e) {
      throw MathRuntimeException.createIOException(e);
    }

  }

  








  protected double readBaseExternal(final ObjectInput in)
    throws IOException {

    final int dimension = in.readInt();
    previousTime  = in.readDouble();
    currentTime   = in.readDouble();
    h             = in.readDouble();
    forward       = in.readBoolean();
    dirtyState    = true;

    if (dimension < 0) {
        currentState = null;
    } else {
        currentState  = new double[dimension];
        for (int i = 0; i < currentState.length; ++i) {
            currentState[i] = in.readDouble();
        }
    }

    
    interpolatedTime        = Double.NaN;
    interpolatedState       = (dimension < 0) ? null : new double[dimension];
    interpolatedDerivatives = (dimension < 0) ? null : new double[dimension];

    finalized = true;

    return in.readDouble();

  }

}
