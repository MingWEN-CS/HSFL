
















package org.apache.commons.math.ode.sampling;

import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.IOException;

import org.apache.commons.math.MathRuntimeException;
import org.apache.commons.math.ode.DerivativeException;
import org.apache.commons.math.ode.FirstOrderIntegrator;
import org.apache.commons.math.ode.SecondOrderIntegrator;
import org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator;


















public abstract class AbstractStepInterpolator
  implements StepInterpolator {

  
  protected double previousTime;

  
  protected double currentTime;

  
  protected double h;

  
  protected double[] currentState;

  
  protected double interpolatedTime;

  
  protected double[] interpolatedState;

  
  protected double[] interpolatedDerivatives;

  
  private boolean finalized;

  
  private boolean forward;

  









  protected AbstractStepInterpolator() {
    previousTime            = Double.NaN;
    currentTime             = Double.NaN;
    h                       = Double.NaN;
    interpolatedTime        = Double.NaN;
    currentState            = null;
    interpolatedState       = null;
    interpolatedDerivatives = null;
    finalized               = false;
    this.forward            = true;
  }

  




  protected AbstractStepInterpolator(final double[] y, final boolean forward) {

    previousTime      = Double.NaN;
    currentTime       = Double.NaN;
    h                 = Double.NaN;
    interpolatedTime  = Double.NaN;

    currentState            = y;
    interpolatedState       = new double[y.length];
    interpolatedDerivatives = new double[y.length];

    finalized         = false;
    this.forward      = forward;

  }

  
















  protected AbstractStepInterpolator(final AbstractStepInterpolator interpolator) {

    previousTime      = interpolator.previousTime;
    currentTime       = interpolator.currentTime;
    h                 = interpolator.h;
    interpolatedTime  = interpolator.interpolatedTime;

    if (interpolator.currentState != null) {
      currentState            = interpolator.currentState.clone();
      interpolatedState       = interpolator.interpolatedState.clone();
      interpolatedDerivatives = interpolator.interpolatedDerivatives.clone();
    } else {
      currentState            = null;
      interpolatedState       = null;
      interpolatedDerivatives = null;
    }

    finalized = interpolator.finalized;
    forward   = interpolator.forward;

  }

  




  protected void reinitialize(final double[] y, final boolean forward) {

    previousTime      = Double.NaN;
    currentTime       = Double.NaN;
    h                 = Double.NaN;
    interpolatedTime  = Double.NaN;

    currentState            = y;
    interpolatedState       = new double[y.length];
    interpolatedDerivatives = new double[y.length];

    finalized         = false;
    this.forward      = forward;

  }

  
   public StepInterpolator copy() throws DerivativeException {

     
     finalizeStep();

     
     return doCopy();

   }

   






   protected abstract StepInterpolator doCopy();

  



  public void shift() {
    previousTime = currentTime;
  }

  


  public void storeTime(final double t) {

    currentTime      = t;
    h                = currentTime - previousTime;
    interpolatedTime = t;
    System.arraycopy(currentState, 0, interpolatedState, 0,
                     currentState.length);

    
    finalized = false;

  }

  
  public double getPreviousTime() {
    return previousTime;
  }
    
  
  public double getCurrentTime() {
    return currentTime;
  }
    
  
  public double getInterpolatedTime() {
    return interpolatedTime;
  }
    
  
  public void setInterpolatedTime(final double time)
      throws DerivativeException {
      interpolatedTime = time;
      final double oneMinusThetaH = currentTime - interpolatedTime;
      final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;
      computeInterpolatedState(theta, oneMinusThetaH);
  }

  
  public boolean isForward() {
    return forward;
  }

  









  protected abstract void computeInterpolatedState(double theta,
                                                   double oneMinusThetaH)
    throws DerivativeException;
    
  
  public double[] getInterpolatedState() {
    return interpolatedState;
  }

  
  public double[] getInterpolatedDerivatives() {
    return interpolatedDerivatives;
  }

  









































  public final void finalizeStep()
    throws DerivativeException {
    if (! finalized) {
      doFinalize();
      finalized = true;
    }
  }

  





  protected void doFinalize()
    throws DerivativeException {
  }

  
  public abstract void writeExternal(ObjectOutput out)
    throws IOException;

  
  public abstract void readExternal(ObjectInput in)
    throws IOException;

  





  protected void writeBaseExternal(final ObjectOutput out)
    throws IOException {

    out.writeInt(currentState.length);
    out.writeDouble(previousTime);
    out.writeDouble(currentTime);
    out.writeDouble(h);
    out.writeBoolean(forward);

    for (int i = 0; i < currentState.length; ++i) {
      out.writeDouble(currentState[i]);
    }

    out.writeDouble(interpolatedTime);

    
    

    
    try {
      finalizeStep();
    } catch (DerivativeException e) {
      throw MathRuntimeException.createIOException(e);
    }

  }

  








  protected double readBaseExternal(final ObjectInput in)
    throws IOException {

    final int dimension = in.readInt();
    previousTime  = in.readDouble();
    currentTime   = in.readDouble();
    h             = in.readDouble();
    forward       = in.readBoolean();

    currentState  = new double[dimension];
    for (int i = 0; i < currentState.length; ++i) {
      currentState[i] = in.readDouble();
    }

    
    interpolatedTime        = Double.NaN;
    interpolatedState       = new double[dimension];
    interpolatedDerivatives = new double[dimension];

    finalized = true;

    return in.readDouble();

  }

}
