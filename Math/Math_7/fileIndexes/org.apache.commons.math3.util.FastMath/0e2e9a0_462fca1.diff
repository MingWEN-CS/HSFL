19,20d18
< import org.apache.commons.math.exception.DimensionMismatchException;
< 
124c122
<                     expint(i, tmp);
---
>                     FastMathCalc.expint(i, tmp);
130c128
<                         splitReciprocal(tmp, recip);
---
>                         FastMathCalc.splitReciprocal(tmp, recip);
3170c3168
<                       slowexp(i/1024.0, tmp); 
---
>                       FastMathCalc.slowexp(i/1024.0, tmp); 
5234,5258d5231
<     
<     private static final double FACT[] = new double[] 
<         {
<         +1.0d,                        
<         +1.0d,                        
<         +2.0d,                        
<         +6.0d,                        
<         +24.0d,                       
<         +120.0d,                      
<         +720.0d,                      
<         +5040.0d,                     
<         +40320.0d,                    
<         +362880.0d,                   
<         +3628800.0d,                  
<         +39916800.0d,                 
<         +479001600.0d,                
<         +6227020800.0d,               
<         +87178291200.0d,              
<         +1307674368000.0d,            
<         +20922789888000.0d,           
<         +355687428096000.0d,          
<         +6402373705728000.0d,         
<         +121645100408832000.0d,       
<         };
< 
5273c5246
<                       LN_MANT[i] = slowLog(d);
---
>                       LN_MANT[i] = FastMathCalc.slowLog(d);
6313,6332d6285
<     private static final double LN_SPLIT_COEF[][] = {
<         {2.0, 0.0},
<         {0.6666666269302368, 3.9736429850260626E-8},
<         {0.3999999761581421, 2.3841857910019882E-8},
<         {0.2857142686843872, 1.7029898543501842E-8},
<         {0.2222222089767456, 1.3245471311735498E-8},
<         {0.1818181574344635, 2.4384203044354907E-8},
<         {0.1538461446762085, 9.140260083262505E-9},
<         {0.13333332538604736, 9.220590270857665E-9},
<         {0.11764700710773468, 1.2393345855018391E-8},
<         {0.10526403784751892, 8.251545029714408E-9},
<         {0.0952233225107193, 1.2675934823758863E-8},
<         {0.08713622391223907, 1.1430250008909141E-8},
<         {0.07842259109020233, 2.404307984052299E-9},
<         {0.08371849358081818, 1.176342548272881E-8},
<         {0.030589580535888672, 1.2958646899018938E-9},
<         {0.14982303977012634, 1.225743062930824E-8},
<     };
< 
<     
6542,6585c6495,6505
<         printarray("EXP_INT_TABLE_A", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A);
<         printarray("EXP_INT_TABLE_B", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);
<         printarray("EXP_FRAC_TABLE_A", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);
<         printarray("EXP_FRAC_TABLE_B", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B);
<         printarray("LN_MANT",LN_MANT_LEN, lnMant.LN_MANT);
<         printarray("SINE_TABLE_A", SINE_TABLE_LEN, SINE_TABLE_A);
<         printarray("SINE_TABLE_B", SINE_TABLE_LEN, SINE_TABLE_B);
<         printarray("COSINE_TABLE_A", SINE_TABLE_LEN, COSINE_TABLE_A);
<         printarray("COSINE_TABLE_B", SINE_TABLE_LEN, COSINE_TABLE_B);
<         printarray("TANGENT_TABLE_A", SINE_TABLE_LEN, TANGENT_TABLE_A);
<         printarray("TANGENT_TABLE_B", SINE_TABLE_LEN, TANGENT_TABLE_B);
<     }
< 
<     private static void printarray(String string, int expectedLen, double[][] array2d) {
<         System.out.println(string);
<         checkLen(expectedLen, array2d.length);
<         System.out.println("    { ");
<         int i = 0;
<         for(double array[] : array2d) {
<             System.out.print("        {");
<             for(double d : array) { 
<                 String ds = d >= 0 ? "+"+Double.toString(d)+"d," : Double.toString(d)+"d,";
<                 System.out.printf("%-25.25s",ds); 
<             }
<             System.out.println("}, 
<         }
<         System.out.println("    };");
<     }
< 
<     private static void printarray(String string, int expectedLen, double[] array) {
<         System.out.println(string+"=");
<         checkLen(expectedLen, array.length);
<         System.out.println("    {");
<         for(double d : array){
<             String ds = d!=d ? "Double.NaN," : d >= 0 ? "+"+Double.toString(d)+"d," : Double.toString(d)+"d,";
<             System.out.printf("        %s%n",ds); 
<         }
<         System.out.println("    };");
<     }
< 
<     private static void checkLen(int expectedLen, int actual) {
<         if (expectedLen != actual) {
<             throw new DimensionMismatchException(actual, expectedLen);
<         }
---
>         FastMathCalc.printarray("EXP_INT_TABLE_A", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A);
>         FastMathCalc.printarray("EXP_INT_TABLE_B", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);
>         FastMathCalc.printarray("EXP_FRAC_TABLE_A", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);
>         FastMathCalc.printarray("EXP_FRAC_TABLE_B", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B);
>         FastMathCalc.printarray("LN_MANT",LN_MANT_LEN, lnMant.LN_MANT);
>         FastMathCalc.printarray("SINE_TABLE_A", SINE_TABLE_LEN, SINE_TABLE_A);
>         FastMathCalc.printarray("SINE_TABLE_B", SINE_TABLE_LEN, SINE_TABLE_B);
>         FastMathCalc.printarray("COSINE_TABLE_A", SINE_TABLE_LEN, COSINE_TABLE_A);
>         FastMathCalc.printarray("COSINE_TABLE_B", SINE_TABLE_LEN, COSINE_TABLE_B);
>         FastMathCalc.printarray("TANGENT_TABLE_A", SINE_TABLE_LEN, TANGENT_TABLE_A);
>         FastMathCalc.printarray("TANGENT_TABLE_B", SINE_TABLE_LEN, TANGENT_TABLE_B);
7342,7586d7261
< 
<     private static double slowexp(final double x, final double result[]) {
<         final double xs[] = new double[2];
<         final double ys[] = new double[2];
<         final double facts[] = new double[2];
<         final double as[] = new double[2];
<         split(x, xs);
<         ys[0] = ys[1] = 0.0;
< 
<         for (int i = FACT.length-1; i >= 0; i--) {
<             splitMult(xs, ys, as);
<             ys[0] = as[0];
<             ys[1] = as[1];
< 
<             split(FACT[i], as);
<             splitReciprocal(as, facts);
< 
<             splitAdd(ys, facts, as);
<             ys[0] = as[0];
<             ys[1] = as[1];
<         }
< 
<         if (result != null) {
<             result[0] = ys[0];
<             result[1] = ys[1];
<         }
< 
<         return ys[0] + ys[1];
<     }
< 
<     
< 
< 
< 
< 
<     private static void split(final double d, final double split[]) {
<         if (d < 8e298 && d > -8e298) {
<             final double a = d * HEX_40000000;
<             split[0] = (d + a) - a;
<             split[1] = d - split[0];
<         } else {
<             final double a = d * 9.31322574615478515625E-10;
<             split[0] = (d + a - d) * HEX_40000000;
<             split[1] = d - split[0];
<         }
<     }
< 
<     
< 
< 
< 
<     private static void resplit(final double a[]) {
<         final double c = a[0] + a[1];
<         final double d = -(c - a[0] - a[1]);
< 
<         if (c < 8e298 && c > -8e298) { 
<             double z = c * HEX_40000000;
<             a[0] = (c + z) - z;
<             a[1] = c - a[0] + d;
<         } else {
<             double z = c * 9.31322574615478515625E-10;
<             a[0] = (c + z - c) * HEX_40000000;
<             a[1] = c - a[0] + d;
<         }
<     }
< 
<     
< 
< 
< 
< 
<     private static void splitMult(double a[], double b[], double ans[]) {
<         ans[0] = a[0] * b[0];
<         ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];
< 
<         
<         resplit(ans);
<     }
< 
<     
< 
< 
< 
< 
<     private static void splitAdd(final double a[], final double b[], final double ans[]) {
<         ans[0] = a[0] + b[0];
<         ans[1] = a[1] + b[1];
< 
<         resplit(ans);
<     }
< 
<     
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
<     private static void splitReciprocal(final double in[], final double result[]) {
<         final double b = 1.0/4194304.0;
<         final double a = 1.0 - b;
< 
<         if (in[0] == 0.0) {
<             in[0] = in[1];
<             in[1] = 0.0;
<         }
< 
<         result[0] = a / in[0];
<         result[1] = (b*in[0]-a*in[1]) / (in[0]*in[0] + in[0]*in[1]);
< 
<         if (result[1] != result[1]) { 
<             result[1] = 0.0;
<         }
< 
<         
<         resplit(result);
< 
<         for (int i = 0; i < 2; i++) {
<             
<             double err = 1.0 - result[0] * in[0] - result[0] * in[1] -
<             result[1] * in[0] - result[1] * in[1];
<             
<             err = err * (result[0] + result[1]);
<             
<             result[1] += err;
<         }
<     }
< 
<     
< 
< 
< 
< 
<     private static void quadMult(final double a[], final double b[], final double result[]) {
<         final double xs[] = new double[2];
<         final double ys[] = new double[2];
<         final double zs[] = new double[2];
< 
<         
<         split(a[0], xs);
<         split(b[0], ys);
<         splitMult(xs, ys, zs);
< 
<         result[0] = zs[0];
<         result[1] = zs[1];
< 
<         
<         split(b[1], ys);
<         splitMult(xs, ys, zs);
< 
<         double tmp = result[0] + zs[0];
<         result[1] = result[1] - (tmp - result[0] - zs[0]);
<         result[0] = tmp;
<         tmp = result[0] + zs[1];
<         result[1] = result[1] - (tmp - result[0] - zs[1]);
<         result[0] = tmp;
< 
<         
<         split(a[1], xs);
<         split(b[0], ys);
<         splitMult(xs, ys, zs);
< 
<         tmp = result[0] + zs[0];
<         result[1] = result[1] - (tmp - result[0] - zs[0]);
<         result[0] = tmp;
<         tmp = result[0] + zs[1];
<         result[1] = result[1] - (tmp - result[0] - zs[1]);
<         result[0] = tmp;
< 
<         
<         split(a[1], xs);
<         split(b[1], ys);
<         splitMult(xs, ys, zs);
< 
<         tmp = result[0] + zs[0];
<         result[1] = result[1] - (tmp - result[0] - zs[0]);
<         result[0] = tmp;
<         tmp = result[0] + zs[1];
<         result[1] = result[1] - (tmp - result[0] - zs[1]);
<         result[0] = tmp;
<     }
< 
<     
< 
< 
< 
< 
<     private static double expint(int p, final double result[]) {
<         
<         final double xs[] = new double[2];
<         final double as[] = new double[2];
<         final double ys[] = new double[2];
<         
<         
<         
<         
<         
<         
< 
<         
<         xs[0] = 2.718281828459045;
<         xs[1] = 1.4456468917292502E-16;
< 
<         split(1.0, ys);
< 
<         while (p > 0) {
<             if ((p & 1) != 0) {
<                 quadMult(ys, xs, as);
<                 ys[0] = as[0]; ys[1] = as[1];
<             }
< 
<             quadMult(xs, xs, as);
<             xs[0] = as[0]; xs[1] = as[1];
< 
<             p >>= 1;
<         }
< 
<         if (result != null) {
<             result[0] = ys[0];
<             result[1] = ys[1];
< 
<             resplit(result);
<         }
< 
<         return ys[0] + ys[1];
<     }
< 
< 
<     
< 
< 
< 
< 
< 
8051,8298d7725
<     
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
<     private static double[] slowLog(double xi) {
<         double x[] = new double[2];
<         double x2[] = new double[2];
<         double y[] = new double[2];
<         double a[] = new double[2];
< 
<         split(xi, x);
< 
<         
<         x[0] += 1.0;
<         resplit(x);
<         splitReciprocal(x, a);
<         x[0] -= 2.0;
<         resplit(x);
<         splitMult(x, a, y);
<         x[0] = y[0];
<         x[1] = y[1];
< 
<         
<         splitMult(x, x, x2);
< 
< 
<         
<         
< 
<         y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];
<         y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];
< 
<         for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {
<             splitMult(y, x2, a);
<             y[0] = a[0];
<             y[1] = a[1];
<             splitAdd(y, LN_SPLIT_COEF[i], a);
<             y[0] = a[0];
<             y[1] = a[1];
<         }
< 
<         splitMult(y, x, a);
<         y[0] = a[0];
<         y[1] = a[1];
< 
<         return y;
<     }
< 
<     
< 
< 
< 
< 
< 
< 
< 
<     private static double slowSin(final double x, final double result[]) {
<         final double xs[] = new double[2];
<         final double ys[] = new double[2];
<         final double facts[] = new double[2];
<         final double as[] = new double[2];
<         split(x, xs);
<         ys[0] = ys[1] = 0.0;
< 
<         for (int i = FACT.length-1; i >= 0; i--) {
<             splitMult(xs, ys, as);
<             ys[0] = as[0]; ys[1] = as[1];
< 
<             if ( (i & 1) == 0) { 
<                 continue;
<             }
< 
<             split(FACT[i], as);
<             splitReciprocal(as, facts);
< 
<             if ( (i & 2) != 0 ) { 
<                 facts[0] = -facts[0];
<                 facts[1] = -facts[1];
<             }
< 
<             splitAdd(ys, facts, as);
<             ys[0] = as[0]; ys[1] = as[1];
<         }
< 
<         if (result != null) {
<             result[0] = ys[0];
<             result[1] = ys[1];
<         }
< 
<         return ys[0] + ys[1];
<     }
< 
<     
< 
< 
< 
< 
< 
< 
< 
<     private static double slowCos(final double x, final double result[]) {
< 
<         final double xs[] = new double[2];
<         final double ys[] = new double[2];
<         final double facts[] = new double[2];
<         final double as[] = new double[2];
<         split(x, xs);
<         ys[0] = ys[1] = 0.0;
< 
<         for (int i = FACT.length-1; i >= 0; i--) {
<             splitMult(xs, ys, as);
<             ys[0] = as[0]; ys[1] = as[1];
< 
<             if ( (i & 1) != 0) { 
<                 continue;
<             }
< 
<             split(FACT[i], as);
<             splitReciprocal(as, facts);
< 
<             if ( (i & 2) != 0 ) { 
<                 facts[0] = -facts[0];
<                 facts[1] = -facts[1];
<             }
< 
<             splitAdd(ys, facts, as);
<             ys[0] = as[0]; ys[1] = as[1];
<         }
< 
<         if (result != null) {
<             result[0] = ys[0];
<             result[1] = ys[1];
<         }
< 
<         return ys[0] + ys[1];
<     }
< 
<     
< 
<     @SuppressWarnings("unused")
<     private static void buildSinCosTables() {
<         final double result[] = new double[2];
< 
<         
<         for (int i = 0; i < 7; i++) {
<             double x = i / 8.0;
< 
<             slowSin(x, result);
<             SINE_TABLE_A[i] = result[0];
<             SINE_TABLE_B[i] = result[1];
< 
<             slowCos(x, result);
<             COSINE_TABLE_A[i] = result[0];
<             COSINE_TABLE_B[i] = result[1];
<         }
< 
<         
<         for (int i = 7; i < SINE_TABLE_LEN; i++) {
<             double xs[] = new double[2];
<             double ys[] = new double[2];
<             double as[] = new double[2];
<             double bs[] = new double[2];
<             double temps[] = new double[2];
< 
<             if ( (i & 1) == 0) {
<                 
<                 xs[0] = SINE_TABLE_A[i/2];
<                 xs[1] = SINE_TABLE_B[i/2];
<                 ys[0] = COSINE_TABLE_A[i/2];
<                 ys[1] = COSINE_TABLE_B[i/2];
< 
<                 
<                 splitMult(xs, ys, result);
<                 SINE_TABLE_A[i] = result[0] * 2.0;
<                 SINE_TABLE_B[i] = result[1] * 2.0;
< 
<                 
<                 splitMult(ys, ys, as);
<                 splitMult(xs, xs, temps);
<                 temps[0] = -temps[0];
<                 temps[1] = -temps[1];
<                 splitAdd(as, temps, result);
<                 COSINE_TABLE_A[i] = result[0];
<                 COSINE_TABLE_B[i] = result[1];
<             } else {
<                 xs[0] = SINE_TABLE_A[i/2];
<                 xs[1] = SINE_TABLE_B[i/2];
<                 ys[0] = COSINE_TABLE_A[i/2];
<                 ys[1] = COSINE_TABLE_B[i/2];
<                 as[0] = SINE_TABLE_A[i/2+1];
<                 as[1] = SINE_TABLE_B[i/2+1];
<                 bs[0] = COSINE_TABLE_A[i/2+1];
<                 bs[1] = COSINE_TABLE_B[i/2+1];
< 
<                 
<                 splitMult(xs, bs, temps);
<                 splitMult(ys, as, result);
<                 splitAdd(result, temps, result);
<                 SINE_TABLE_A[i] = result[0];
<                 SINE_TABLE_B[i] = result[1];
< 
<                 
<                 splitMult(ys, bs, result);
<                 splitMult(xs, as, temps);
<                 temps[0] = -temps[0];
<                 temps[1] = -temps[1];
<                 splitAdd(result, temps, result);
<                 COSINE_TABLE_A[i] = result[0];
<                 COSINE_TABLE_B[i] = result[1];
<             }
<         }
< 
<         
<         for (int i = 0; i < SINE_TABLE_LEN; i++) {
<             double xs[] = new double[2];
<             double ys[] = new double[2];
<             double as[] = new double[2];
< 
<             as[0] = COSINE_TABLE_A[i];
<             as[1] = COSINE_TABLE_B[i];
< 
<             splitReciprocal(as, ys);
< 
<             xs[0] = SINE_TABLE_A[i];
<             xs[1] = SINE_TABLE_B[i];
< 
<             splitMult(xs, ys, as);
< 
<             TANGENT_TABLE_A[i] = as[0];
<             TANGENT_TABLE_B[i] = as[1];
<         }
< 
<     }
