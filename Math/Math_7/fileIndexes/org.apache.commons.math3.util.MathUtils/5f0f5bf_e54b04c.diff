2610a2611,2670
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public static double linearCombination(final double[] a, final double[] b) {
>         final int len = a.length;
>         if (len != b.length) {
>             throw new DimensionMismatchException(len, b.length);
>         }
> 
>         final double[] prodHigh = new double[len];
>         double prodLowSum = 0;
> 
>         for (int i = 0; i < len; i++) {
>             final double ai = a[i];
>             final double ca = SPLIT_FACTOR * ai;
>             final double aHigh = ca - (ca - ai);
>             final double aLow = ai - aHigh;
> 
>             final double bi = b[i];
>             final double cb = SPLIT_FACTOR * bi;
>             final double bHigh = cb - (cb - bi);
>             final double bLow = bi - bHigh;
>             prodHigh[i] = ai * bi;
>             final double prodLow = aLow * bLow - (((prodHigh[i] -
>                                                     aHigh * bHigh) -
>                                                    aLow * bHigh) -
>                                                   aHigh * bLow);
>             prodLowSum += prodLow;
>         }
> 
>         final int lenMinusOne = len - 1;
>         final double[] sHigh = new double[lenMinusOne];
> 
>         sHigh[0] = prodHigh[0] + prodHigh[1];
>         double sPrime = sHigh[0] - prodHigh[1];
>         double sLowSum = (prodHigh[1] - (sHigh[0] - sPrime)) + (prodHigh[0] - sPrime);
> 
>         for (int i = 1; i < lenMinusOne; i++) {
>             final int prev = i - 1;
>             final int next = i + 1;
>             sHigh[i] = sHigh[prev] + prodHigh[next];
>             sPrime = sHigh[i] - prodHigh[next];
>             sLowSum += (prodHigh[next] - (sHigh[i] - sPrime)) + (sHigh[prev] - sPrime);
>         }
> 
>         return sHigh[lenMinusOne - 1] + (prodLowSum + sLowSum);
>     }
