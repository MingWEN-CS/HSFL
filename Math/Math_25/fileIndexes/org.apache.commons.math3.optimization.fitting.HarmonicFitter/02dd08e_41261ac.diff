19a20,22
> import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;
> import org.apache.commons.math.analysis.function.HarmonicOscillator;
> import org.apache.commons.math.exception.ZeroException;
22,24d24
< import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;
< import org.apache.commons.math.optimization.OptimizationException;
< import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;
36d35
< public class HarmonicFitter {
38,39d36
<     
<     private final CurveFitter fitter;
41,42d37
<     
<     private double[] parameters;
43a39
> public class HarmonicFitter extends CurveFitter {
46a43
> 
48,49c45
<         this.fitter = new CurveFitter(optimizer);
<         parameters  = null;
---
>         super(optimizer);
59,62c55,61
<     public HarmonicFitter(final DifferentiableMultivariateVectorialOptimizer optimizer,
<                           final double[] initialGuess) {
<         this.fitter     = new CurveFitter(optimizer);
<         this.parameters = initialGuess.clone();
---
> 
> 
> 
> 
> 
>     public double[] fit(double[] initialGuess) {
>         return fit(new HarmonicOscillator.Parametric(), initialGuess);
71,72c70,76
<     public void addObservedPoint(double weight, double x, double y) {
<         fitter.addObservedPoint(weight, x, y);
---
> 
> 
> 
> 
> 
>     public double[] fit() {
>         return fit((new ParameterGuesser(getObservations())).guess());
83c87,187
<     public HarmonicFunction fit() throws OptimizationException {
---
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public static class ParameterGuesser {
>         
>         private final WeightedObservedPoint[] observations;
>         
>         private double a;
>         
>         private double omega;
>         
>         private double phi;
> 
85,86c189,194
<         if (parameters == null) {
<             final WeightedObservedPoint[] observations = fitter.getObservations();
---
> 
> 
> 
> 
> 
>         public ParameterGuesser(WeightedObservedPoint[] observations) {
92,98c200
<             HarmonicCoefficientsGuesser guesser = new HarmonicCoefficientsGuesser(observations);
<             guesser.guess();
<             parameters = new double[] {
<                 guesser.getGuessedAmplitude(),
<                 guesser.getGuessedPulsation(),
<                 guesser.getGuessedPhase()
<             };
---
>             this.observations = observations.clone();
101,103c203,204
<         double[] fitted = fitter.fit(new ParametricHarmonicFunction(), parameters);
<         return new HarmonicFunction(fitted[0], fitted[1], fitted[2]);
<     }
---
>         
> 
105,106c206,218
<     
<     private static class ParametricHarmonicFunction implements ParametricUnivariateRealFunction {
---
> 
> 
> 
> 
> 
> 
> 
>         public double[] guess() {
>             sortObservations();
>             guessAOmega();
>             guessPhi();
>             return new double[] { a, omega, phi };
>         }
109,113c221,244
<         public double value(double x, double[] parameters) {
<             final double a     = parameters[0];
<             final double omega = parameters[1];
<             final double phi   = parameters[2];
<             return a * FastMath.cos(omega * x + phi);
---
> 
> 
>         private void sortObservations() {
>             
>             
>             
>             WeightedObservedPoint curr = observations[0];
>             for (int j = 1; j < observations.length; ++j) {
>                 WeightedObservedPoint prec = curr;
>                 curr = observations[j];
>                 if (curr.getX() < prec.getX()) {
>                     
>                     int i = j - 1;
>                     WeightedObservedPoint mI = observations[i];
>                     while ((i >= 0) && (curr.getX() < mI.getX())) {
>                         observations[i + 1] = mI;
>                         if (i-- != 0) {
>                             mI = observations[i];
>                         }
>                     }
>                     observations[i + 1] = curr;
>                     curr = observations[j];
>                 }
>             }
117,124c248,312
<         public double[] gradient(double x, double[] parameters) {
<             final double a     = parameters[0];
<             final double omega = parameters[1];
<             final double phi   = parameters[2];
<             final double alpha = omega * x + phi;
<             final double cosAlpha = FastMath.cos(alpha);
<             final double sinAlpha = FastMath.sin(alpha);
<             return new double[] { cosAlpha, -a * x * sinAlpha, -a * sinAlpha };
---
> 
> 
> 
> 
> 
> 
>         private void guessAOmega() {
>             
>             double sx2 = 0;
>             double sy2 = 0;
>             double sxy = 0;
>             double sxz = 0;
>             double syz = 0;
> 
>             double currentX = observations[0].getX();
>             double currentY = observations[0].getY();
>             double f2Integral = 0;
>             double fPrime2Integral = 0;
>             final double startX = currentX;
>             for (int i = 1; i < observations.length; ++i) {
>                 
>                 final double previousX = currentX;
>                 final double previousY = currentY;
>                 currentX = observations[i].getX();
>                 currentY = observations[i].getY();
> 
>                 
>                 
>                 final double dx = currentX - previousX;
>                 final double dy = currentY - previousY;
>                 final double f2StepIntegral =
>                     dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
>                 final double fPrime2StepIntegral = dy * dy / dx;
> 
>                 final double x = currentX - startX;
>                 f2Integral += f2StepIntegral;
>                 fPrime2Integral += fPrime2StepIntegral;
> 
>                 sx2 += x * x;
>                 sy2 += f2Integral * f2Integral;
>                 sxy += x * f2Integral;
>                 sxz += x * fPrime2Integral;
>                 syz += f2Integral * fPrime2Integral;
>             }
> 
>             
>             double c1 = sy2 * sxz - sxy * syz;
>             double c2 = sxy * sxz - sx2 * syz;
>             double c3 = sx2 * sy2 - sxy * sxy;
>             if ((c1 / c2 < 0) || (c2 / c3 < 0)) {
>                 a = 0;
> 
>                 
>                 
>                 final double range = observations[observations.length - 1].getX() -
>                     observations[0].getX();
> 
>                 if (range == 0) {
>                     throw new ZeroException();
>                 }
>                 omega = 2 * Math.PI / range;
>             } else {
>                 a = FastMath.sqrt(c1 / c2);
>                 omega = FastMath.sqrt(c2 / c3);
>             }
127c315,316
<     }
---
>         
> 
128a318,342
>         private void guessPhi() {
>             
>             double fcMean = 0;
>             double fsMean = 0;
> 
>             double currentX = observations[0].getX();
>             double currentY = observations[0].getY();
>             for (int i = 1; i < observations.length; ++i) {
>                 
>                 final double previousX = currentX;
>                 final double previousY = currentY;
>                 currentX = observations[i].getX();
>                 currentY = observations[i].getY();
>                 final double currentYPrime = (currentY - previousY) / (currentX - previousX);
> 
>                 double omegaX = omega * currentX;
>                 double cosine = FastMath.cos(omegaX);
>                 double sine = FastMath.sin(omegaX);
>                 fcMean += omega * currentY * cosine - currentYPrime * sine;
>                 fsMean += omega * currentY * sine + currentYPrime * cosine;
>             }
> 
>             phi = FastMath.atan2(-fsMean, fcMean);
>         }
>     }
