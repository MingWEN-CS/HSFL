
















package org.apache.commons.math.optimization.fitting;

import org.apache.commons.math.exception.NumberIsTooSmallException;
import org.apache.commons.math.exception.util.LocalizedFormats;
import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;
import org.apache.commons.math.optimization.OptimizationException;
import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;
import org.apache.commons.math.util.FastMath;










public class HarmonicFitter {

    
    private final CurveFitter fitter;

    
    private double[] parameters;

    


    public HarmonicFitter(final DifferentiableMultivariateVectorialOptimizer optimizer) {
        this.fitter = new CurveFitter(optimizer);
        parameters  = null;
    }

    






    public HarmonicFitter(final DifferentiableMultivariateVectorialOptimizer optimizer,
                          final double[] initialGuess) {
        this.fitter     = new CurveFitter(optimizer);
        this.parameters = initialGuess.clone();
    }

    





    public void addObservedPoint(double weight, double x, double y) {
        fitter.addObservedPoint(weight, x, y);
    }

    







    public HarmonicFunction fit() throws OptimizationException {
        
        if (parameters == null) {
            final WeightedObservedPoint[] observations = fitter.getObservations();
            if (observations.length < 4) {
                throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,
                                                    observations.length, 4, true);
            }

            HarmonicCoefficientsGuesser guesser = new HarmonicCoefficientsGuesser(observations);
            guesser.guess();
            parameters = new double[] {
                guesser.getGuessedAmplitude(),
                guesser.getGuessedPulsation(),
                guesser.getGuessedPhase()
            };
        }

        double[] fitted = fitter.fit(new ParametricHarmonicFunction(), parameters);
        return new HarmonicFunction(fitted[0], fitted[1], fitted[2]);
    }

    
    private static class ParametricHarmonicFunction implements ParametricUnivariateRealFunction {

        
        public double value(double x, double[] parameters) {
            final double a     = parameters[0];
            final double omega = parameters[1];
            final double phi   = parameters[2];
            return a * FastMath.cos(omega * x + phi);
        }

        
        public double[] gradient(double x, double[] parameters) {
            final double a     = parameters[0];
            final double omega = parameters[1];
            final double phi   = parameters[2];
            final double alpha = omega * x + phi;
            final double cosAlpha = FastMath.cos(alpha);
            final double sinAlpha = FastMath.sin(alpha);
            return new double[] { cosAlpha, -a * x * sinAlpha, -a * sinAlpha };
        }

    }

}
