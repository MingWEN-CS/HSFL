21a22
> import java.util.Arrays;
6137a6139,6300
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {
>         if(s == null || t == null) {
>             throw new IllegalArgumentException("String must not be null");
>         }
>         if(threshold < 0) {
>             throw new IllegalArgumentException("Threshold must not be negative");
>         }
> 
>         
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>         int n = s.length(); 
>         int m = t.length(); 
> 
>         
>         if(n == 0) {
>             return m <= threshold? m : -1;
>         } else if(m == 0) {
>             return n <= threshold? n : -1;
>         }
> 
>         if(n > m) {
>             
>             CharSequence tmp = s;
>             s = t;
>             t = tmp;
>             n = m;
>             m = t.length();
>         }
> 
>         int p[] = new int[n+1]; 
>         int d[] = new int[n+1]; 
>         int _d[]; 
> 
>         
>         int boundary = Math.min(n, threshold) + 1;
>         for(int i = 0; i < boundary; i++) {
>             p[i] = i;
>         }
>         
>         
>         Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);
>         Arrays.fill(d, Integer.MAX_VALUE);
> 
>         
>         for(int j = 1; j <= m; j++) {
>             char t_j = t.charAt(j-1); 
>             d[0] = j;
> 
>             
>             int min = Math.max(1, j - threshold);
>             int max = Math.min(n, j + threshold);
> 
>             
>             if(min > max) {
>                 return -1;
>             }
> 
>             
>             if(min > 1) {
>                 d[min-1] = Integer.MAX_VALUE;
>             }
> 
>             
>             for(int i = min; i <= max; i++) {
>                 if(s.charAt(i-1) == t_j) {
>                     
>                     d[i] = p[i-1];
>                 } else {
>                     
>                     d[i] = 1 + Math.min(Math.min(d[i-1], p[i]), p[i-1]);
>                 }
>             }
> 
>             
>             _d = p;
>             p = d;
>             d = _d;
>         }
> 
>         
>         
>         if(p[n] <= threshold) {
>             return p[n];
>         } else {
>             return -1;
>         }
