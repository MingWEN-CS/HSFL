















package org.apache.commons.lang.text;

import java.text.Format;
import java.text.MessageFormat;
import java.text.ParsePosition;
import java.util.ArrayList;
import java.util.Locale;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.Validate;




















public class ExtendedMessageFormat extends MessageFormat {
    private static final long serialVersionUID = -2362048321261811743L;

    






    public static Format createDefaultMetaFormat() {
        return createDefaultMetaFormat(Locale.getDefault());
    }

    







    public static Format createDefaultMetaFormat(Locale locale) {
        return DefaultMetaFormatFactory.getFormat(locale);
    }

    


    private static class Parser {
        private static final String ESCAPED_QUOTE = "''";
        private static final char START_FMT = ',';
        private static final char END_FE = '}';
        private static final char START_FE = '{';
        private static final char QUOTE = '\'';

        





        private String stripFormats(String pattern) {
            StringBuffer sb = new StringBuffer(pattern.length());
            ParsePosition pos = new ParsePosition(0);
            char[] c = pattern.toCharArray();
            while (pos.getIndex() < pattern.length()) {
                switch (c[pos.getIndex()]) {
                case QUOTE:
                    appendQuotedString(pattern, pos, sb, true);
                    break;
                case START_FE:
                    int start = pos.getIndex();
                    readArgumentIndex(pattern, next(pos));
                    sb.append(c, start, pos.getIndex() - start);
                    if (c[pos.getIndex()] == START_FMT) {
                        eatFormat(pattern, next(pos));
                    }
                    if (c[pos.getIndex()] != END_FE) {
                        throw new IllegalArgumentException(
                                "Unreadable format element at position "
                                        + start);
                    }
                    
                default:
                    sb.append(c[pos.getIndex()]);
                    next(pos);
                }
            }
            return sb.toString();
        }

        







        private String insertFormats(String pattern, Format[] formats,
                Format metaFormat) {
            if (formats == null || formats.length == 0) {
                return pattern;
            }
            StringBuffer sb = new StringBuffer(pattern.length() * 2);
            ParsePosition pos = new ParsePosition(0);
            int fe = -1;
            while (pos.getIndex() < pattern.length()) {
                char c = pattern.charAt(pos.getIndex());
                switch (c) {
                case QUOTE:
                    appendQuotedString(pattern, pos, sb, false);
                    break;
                case START_FE:
                    fe++;
                    sb.append(START_FE).append(
                            readArgumentIndex(pattern, next(pos)));
                    if (formats[fe] != null) {
                        String formatName = metaFormat.format(formats[fe]);
                        if (StringUtils.isNotEmpty(formatName)) {
                            sb.append(START_FMT).append(formatName);
                        }
                    }
                    break;
                default:
                    sb.append(pattern.charAt(pos.getIndex()));
                    next(pos);
                }
            }
            return sb.toString();
        }

        






        private Format[] parseFormats(String pattern, Format metaFormat) {
            ArrayList result = new ArrayList();
            ParsePosition pos = new ParsePosition(0);
            while (pos.getIndex() < pattern.length()) {
                switch (pattern.charAt(pos.getIndex())) {
                case QUOTE:
                    getQuotedString(pattern, next(pos), true);
                    break;
                case START_FE:
                    int start = pos.getIndex();
                    readArgumentIndex(pattern, next(pos));
                    if (pattern.charAt(pos.getIndex()) == START_FMT) {
                        seekNonWs(pattern, next(pos));
                    }
                    result.add(metaFormat.parseObject(pattern, pos));
                    seekNonWs(pattern, pos);
                    if (pattern.charAt(pos.getIndex()) != END_FE) {
                        throw new IllegalArgumentException(
                                "Unreadable format element at position "
                                        + start);
                    }
                    
                default:
                    next(pos);
                }
            }
            return (Format[]) result.toArray(new Format[result.size()]);
        }

        





        private void seekNonWs(String pattern, ParsePosition pos) {
            int len = 0;
            char[] buffer = pattern.toCharArray();
            do {
                len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());
                pos.setIndex(pos.getIndex() + len);
            } while (len > 0 && pos.getIndex() < pattern.length());
        }

        





        private ParsePosition next(ParsePosition pos) {
            pos.setIndex(pos.getIndex() + 1);
            return pos;
        }

        






        private String readArgumentIndex(String pattern, ParsePosition pos) {
            int start = pos.getIndex();
            for (; pos.getIndex() < pattern.length(); next(pos)) {
                char c = pattern.charAt(pos.getIndex());
                if (c == START_FMT || c == END_FE) {
                    return pattern.substring(start, pos.getIndex());
                }
                if (!Character.isDigit(c)) {
                    throw new IllegalArgumentException(
                            "Invalid format argument index at position "
                                    + start);
                }
            }
            throw new IllegalArgumentException(
                    "Unterminated format element at position " + start);
        }

        









        private StringBuffer appendQuotedString(String pattern,
                ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {
            int start = pos.getIndex();
            char[] c = pattern.toCharArray();
            if (escapingOn && c[start] == QUOTE) {
                return appendTo == null ? null : appendTo.append(QUOTE);
            }
            int lastHold = start;
            for (int i = pos.getIndex(); i < pattern.length(); i++) {
                if (escapingOn
                        && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {
                    appendTo.append(c, lastHold, pos.getIndex() - lastHold)
                            .append(QUOTE);
                    pos.setIndex(i + ESCAPED_QUOTE.length());
                    lastHold = pos.getIndex();
                    continue;
                }
                switch (c[pos.getIndex()]) {
                case QUOTE:
                    next(pos);
                    return appendTo == null ? null : appendTo.append(c,
                            lastHold, pos.getIndex() - lastHold);
                default:
                    next(pos);
                }
            }
            throw new IllegalArgumentException(
                    "Unterminated quoted string at position " + start);
        }

        






        private void getQuotedString(String pattern, ParsePosition pos,
                boolean escapingOn) {
            appendQuotedString(pattern, pos, null, escapingOn);
        }

        





        private void eatFormat(String pattern, ParsePosition pos) {
            int start = pos.getIndex();
            int depth = 1;
            for (; pos.getIndex() < pattern.length(); next(pos)) {
                switch (pattern.charAt(pos.getIndex())) {
                case START_FE:
                    depth++;
                    break;
                case END_FE:
                    depth--;
                    if (depth == 0) {
                        return;
                    }
                    break;
                case QUOTE:
                    getQuotedString(pattern, pos, false);
                    break;
                }
            }
            throw new IllegalArgumentException(
                    "Unterminated format element at position " + start);
        }
    }

    private static final Parser PARSER = new Parser();

    private Format metaFormat;
    private String strippedPattern;

    







    public ExtendedMessageFormat(String pattern, Format metaFormat) {
        this(pattern, Locale.getDefault(), metaFormat);
    }

    








    public ExtendedMessageFormat(String pattern, Locale locale,
            Format metaFormat) {
        






        super(pattern);
        setLocale(locale);
        setMetaFormat(metaFormat);
        applyPattern(pattern);
    }

    




    public final void applyPattern(String pattern) {
        if (metaFormat == null) {
            return;
        }
        applyPatternPre(pattern);
        strippedPattern = PARSER.stripFormats(pattern);
        super.applyPattern(strippedPattern);
        setFormats(PARSER.parseFormats(pattern, metaFormat));
        applyPatternPost(pattern);
    }

    





    protected void applyPatternPre(String pattern) {
        
    }

    





    protected void applyPatternPost(String pattern) {
        
    }

    





    public String toPattern() {
        return PARSER.insertFormats(strippedPattern, getFormats(), metaFormat);
    }

    




    public synchronized Format getMetaFormat() {
        return metaFormat;
    }

    





    public synchronized void setMetaFormat(Format metaFormat) {
        Validate.notNull(metaFormat, "metaFormat is null");
        this.metaFormat = metaFormat;
    }

}
