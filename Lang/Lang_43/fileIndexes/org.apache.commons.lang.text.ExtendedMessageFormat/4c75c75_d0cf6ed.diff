22a23,24
> import java.util.Collection;
> import java.util.Iterator;
23a26
> import java.util.Map;
25d27
< import org.apache.commons.lang.StringUtils;
38a41,42
> public class ExtendedMessageFormat extends MessageFormat {
>     private static final long serialVersionUID = -2362048321261811743L;
39a44,49
>     private static final String DUMMY_PATTERN = "";
>     private static final String ESCAPED_QUOTE = "''";
>     private static final char START_FMT = ',';
>     private static final char END_FE = '}';
>     private static final char START_FE = '{';
>     private static final char QUOTE = '\'';
40a51,52
>     private String toPattern;
>     private Map registry;
41a54
>     
47,48c60,62
< public class ExtendedMessageFormat extends MessageFormat {
<     private static final long serialVersionUID = -2362048321261811743L;
---
>     public ExtendedMessageFormat(String pattern) {
>         this(pattern, Locale.getDefault());
>     }
57,58c71,72
<     public static Format createDefaultMetaFormat() {
<         return createDefaultMetaFormat(Locale.getDefault());
---
>     public ExtendedMessageFormat(String pattern, Locale locale) {
>         this(pattern, locale, null);
68,70c82,83
< 
<     public static Format createDefaultMetaFormat(Locale locale) {
<         return DefaultMetaFormatFactory.getFormat(locale);
---
>     public ExtendedMessageFormat(String pattern, Map registry) {
>         this(pattern, Locale.getDefault(), registry);
76,83d88
<     private static class Parser {
<         private static final String ESCAPED_QUOTE = "''";
<         private static final char START_FMT = ',';
<         private static final char END_FE = '}';
<         private static final char START_FE = '{';
<         private static final char QUOTE = '\'';
< 
<         
89,117c94,98
<         private String stripFormats(String pattern) {
<             StringBuffer sb = new StringBuffer(pattern.length());
<             ParsePosition pos = new ParsePosition(0);
<             char[] c = pattern.toCharArray();
<             while (pos.getIndex() < pattern.length()) {
<                 switch (c[pos.getIndex()]) {
<                 case QUOTE:
<                     appendQuotedString(pattern, pos, sb, true);
<                     break;
<                 case START_FE:
<                     int start = pos.getIndex();
<                     readArgumentIndex(pattern, next(pos));
<                     sb.append(c, start, pos.getIndex() - start);
<                     if (c[pos.getIndex()] == START_FMT) {
<                         eatFormat(pattern, next(pos));
<                     }
<                     if (c[pos.getIndex()] != END_FE) {
<                         throw new IllegalArgumentException(
<                                 "Unreadable format element at position "
<                                         + start);
<                     }
<                     
<                 default:
<                     sb.append(c[pos.getIndex()]);
<                     next(pos);
<                 }
<             }
<             return sb.toString();
<         }
---
>     public ExtendedMessageFormat(String pattern, Locale locale, Map registry) {
>         super(DUMMY_PATTERN, locale);
>         this.registry = registry;
>         applyPattern(pattern);
>     }
119c100
<         
---
>     
121a103,105
>     public String toPattern() {
>         return toPattern;
>     }
122a107
>     
127,149c112,144
<         private String insertFormats(String pattern, Format[] formats,
<                 Format metaFormat) {
<             if (formats == null || formats.length == 0) {
<                 return pattern;
<             }
<             StringBuffer sb = new StringBuffer(pattern.length() * 2);
<             ParsePosition pos = new ParsePosition(0);
<             int fe = -1;
<             while (pos.getIndex() < pattern.length()) {
<                 char c = pattern.charAt(pos.getIndex());
<                 switch (c) {
<                 case QUOTE:
<                     appendQuotedString(pattern, pos, sb, false);
<                     break;
<                 case START_FE:
<                     fe++;
<                     sb.append(START_FE).append(
<                             readArgumentIndex(pattern, next(pos)));
<                     if (formats[fe] != null) {
<                         String formatName = metaFormat.format(formats[fe]);
<                         if (StringUtils.isNotEmpty(formatName)) {
<                             sb.append(START_FMT).append(formatName);
<                         }
---
>     public final void applyPattern(String pattern) {
>         if (registry == null) {
>             super.applyPattern(pattern);
>             toPattern = super.toPattern();
>             return;
>         }
>         ArrayList foundFormats = new ArrayList();
>         ArrayList foundDescriptions = new ArrayList();
>         StringBuffer stripCustom = new StringBuffer(pattern.length());
> 
>         ParsePosition pos = new ParsePosition(0);
>         char[] c = pattern.toCharArray();
>         int fmtCount = 0;
>         while (pos.getIndex() < pattern.length()) {
>             switch (c[pos.getIndex()]) {
>             case QUOTE:
>                 appendQuotedString(pattern, pos, stripCustom, true);
>                 break;
>             case START_FE:
>                 fmtCount++;
>                 seekNonWs(pattern, pos);
>                 int start = pos.getIndex();
>                 int index = readArgumentIndex(pattern, next(pos));
>                 stripCustom.append(START_FE).append(index);
>                 seekNonWs(pattern, pos);
>                 Format format = null;
>                 String formatDescription = null;
>                 if (c[pos.getIndex()] == START_FMT) {
>                     formatDescription = parseFormatDescription(pattern,
>                             next(pos));
>                     format = getFormat(formatDescription);
>                     if (format == null) {
>                         stripCustom.append(START_FMT).append(formatDescription);
151,154d145
<                     break;
<                 default:
<                     sb.append(pattern.charAt(pos.getIndex()));
<                     next(pos);
155a147,158
>                 foundFormats.add(format);
>                 foundDescriptions.add(format == null ? null : formatDescription);
>                 Validate.isTrue(foundFormats.size() == fmtCount);
>                 Validate.isTrue(foundDescriptions.size() == fmtCount);
>                 if (c[pos.getIndex()] != END_FE) {
>                     throw new IllegalArgumentException(
>                             "Unreadable format element at position " + start);
>                 }
>                 
>             default:
>                 stripCustom.append(c[pos.getIndex()]);
>                 next(pos);
157d159
<             return sb.toString();
159,190c161,168
< 
<         
< 
< 
< 
< 
< 
< 
<         private Format[] parseFormats(String pattern, Format metaFormat) {
<             ArrayList result = new ArrayList();
<             ParsePosition pos = new ParsePosition(0);
<             while (pos.getIndex() < pattern.length()) {
<                 switch (pattern.charAt(pos.getIndex())) {
<                 case QUOTE:
<                     getQuotedString(pattern, next(pos), true);
<                     break;
<                 case START_FE:
<                     int start = pos.getIndex();
<                     readArgumentIndex(pattern, next(pos));
<                     if (pattern.charAt(pos.getIndex()) == START_FMT) {
<                         seekNonWs(pattern, next(pos));
<                     }
<                     result.add(metaFormat.parseObject(pattern, pos));
<                     seekNonWs(pattern, pos);
<                     if (pattern.charAt(pos.getIndex()) != END_FE) {
<                         throw new IllegalArgumentException(
<                                 "Unreadable format element at position "
<                                         + start);
<                     }
<                     
<                 default:
<                     next(pos);
---
>         super.applyPattern(stripCustom.toString());
>         toPattern = insertFormats(super.toPattern(), foundDescriptions);
>         if (containsElements(foundFormats)) {
>             Format[] origFormats = getFormats();
>             for (int i = 0; i < origFormats.length; i++) {
>                 Format f = (Format) foundFormats.get(i);
>                 if (f != null) {
>                     origFormats[i] = f;
193c171
<             return (Format[]) result.toArray(new Format[result.size()]);
---
>             super.setFormats(origFormats);
194a173
>     }
196c175
<         
---
>     
199a179,181
>     public void setFormat(int formatElementIndex, Format newFormat) {
>         throw new UnsupportedOperationException();
>     }
200a183
>     
202,209d184
<         private void seekNonWs(String pattern, ParsePosition pos) {
<             int len = 0;
<             char[] buffer = pattern.toCharArray();
<             do {
<                 len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());
<                 pos.setIndex(pos.getIndex() + len);
<             } while (len > 0 && pos.getIndex() < pattern.length());
<         }
211d185
<         
212a187,189
>     public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {
>         throw new UnsupportedOperationException();
>     }
213a191
>     
217,220c195,197
<         private ParsePosition next(ParsePosition pos) {
<             pos.setIndex(pos.getIndex() + 1);
<             return pos;
<         }
---
>     public void setFormats(Format[] newFormats) {
>         throw new UnsupportedOperationException();
>     }
222c199
<         
---
>     
225a203,205
>     public void setFormatsByArgumentIndex(Format[] newFormats) {
>         throw new UnsupportedOperationException();
>     }
226a207
>     
229,244d209
<         private String readArgumentIndex(String pattern, ParsePosition pos) {
<             int start = pos.getIndex();
<             for (; pos.getIndex() < pattern.length(); next(pos)) {
<                 char c = pattern.charAt(pos.getIndex());
<                 if (c == START_FMT || c == END_FE) {
<                     return pattern.substring(start, pos.getIndex());
<                 }
<                 if (!Character.isDigit(c)) {
<                     throw new IllegalArgumentException(
<                             "Invalid format argument index at position "
<                                     + start);
<                 }
<             }
<             throw new IllegalArgumentException(
<                     "Unterminated format element at position " + start);
<         }
246d210
<         
248a213,228
>     private Format getFormat(String desc) {
>         if (registry != null) {
>             String name = desc;
>             String args = null;
>             int i = desc.indexOf(START_FMT);
>             if (i > 0) {
>                 name = desc.substring(0, i).trim();
>                 args = desc.substring(i + 1).trim();
>             }
>             FormatFactory factory = (FormatFactory) registry.get(name);
>             if (factory != null) {
>                 return factory.getFormat(name, args, getLocale());
>             }
>         }
>         return null;
>     }
249a230
>     
256,270c237,248
<         private StringBuffer appendQuotedString(String pattern,
<                 ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {
<             int start = pos.getIndex();
<             char[] c = pattern.toCharArray();
<             if (escapingOn && c[start] == QUOTE) {
<                 return appendTo == null ? null : appendTo.append(QUOTE);
<             }
<             int lastHold = start;
<             for (int i = pos.getIndex(); i < pattern.length(); i++) {
<                 if (escapingOn
<                         && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {
<                     appendTo.append(c, lastHold, pos.getIndex() - lastHold)
<                             .append(QUOTE);
<                     pos.setIndex(i + ESCAPED_QUOTE.length());
<                     lastHold = pos.getIndex();
---
>     private int readArgumentIndex(String pattern, ParsePosition pos) {
>         int start = pos.getIndex();
>         seekNonWs(pattern, pos);
>         StringBuffer result = new StringBuffer();
>         boolean error = false;
>         for (; !error && pos.getIndex() < pattern.length(); next(pos)) {
>             char c = pattern.charAt(pos.getIndex());
>             if (Character.isWhitespace(c)) {
>                 seekNonWs(pattern, pos);
>                 c = pattern.charAt(pos.getIndex());
>                 if (c != START_FMT && c != END_FE) {
>                     error = true;
273,279c251,256
<                 switch (c[pos.getIndex()]) {
<                 case QUOTE:
<                     next(pos);
<                     return appendTo == null ? null : appendTo.append(c,
<                             lastHold, pos.getIndex() - lastHold);
<                 default:
<                     next(pos);
---
>             }
>             if ((c == START_FMT || c == END_FE) && result.length() > 0) {
>                 try {
>                     return Integer.parseInt(result.toString());
>                 } catch (NumberFormatException e) {
>                     
281a259,262
>             error = !Character.isDigit(c);
>             result.append(c);
>         }
>         if (error) {
283c264,265
<                     "Unterminated quoted string at position " + start);
---
>                     "Invalid format argument index at position " + start + ": "
>                             + pattern.substring(start, pos.getIndex()));
284a267,269
>         throw new IllegalArgumentException(
>                 "Unterminated format element at position " + start);
>     }
286,296c271
<         
< 
< 
< 
< 
< 
< 
<         private void getQuotedString(String pattern, ParsePosition pos,
<                 boolean escapingOn) {
<             appendQuotedString(pattern, pos, null, escapingOn);
<         }
---
>     
298d272
<         
304,320c278,291
<         private void eatFormat(String pattern, ParsePosition pos) {
<             int start = pos.getIndex();
<             int depth = 1;
<             for (; pos.getIndex() < pattern.length(); next(pos)) {
<                 switch (pattern.charAt(pos.getIndex())) {
<                 case START_FE:
<                     depth++;
<                     break;
<                 case END_FE:
<                     depth--;
<                     if (depth == 0) {
<                         return;
<                     }
<                     break;
<                 case QUOTE:
<                     getQuotedString(pattern, pos, false);
<                     break;
---
>     private String parseFormatDescription(String pattern, ParsePosition pos) {
>         int start = pos.getIndex();
>         seekNonWs(pattern, pos);
>         int text = pos.getIndex();
>         int depth = 1;
>         for (; pos.getIndex() < pattern.length(); next(pos)) {
>             switch (pattern.charAt(pos.getIndex())) {
>             case START_FE:
>                 depth++;
>                 break;
>             case END_FE:
>                 depth--;
>                 if (depth == 0) {
>                     return pattern.substring(text, pos.getIndex());
321a293,296
>                 break;
>             case QUOTE:
>                 getQuotedString(pattern, pos, false);
>                 break;
323,324d297
<             throw new IllegalArgumentException(
<                     "Unterminated format element at position " + start);
325a299,300
>         throw new IllegalArgumentException(
>                 "Unterminated format element at position " + start);
328,332d302
<     private static final Parser PARSER = new Parser();
< 
<     private Format metaFormat;
<     private String strippedPattern;
< 
341,342c311,345
<     public ExtendedMessageFormat(String pattern, Format metaFormat) {
<         this(pattern, Locale.getDefault(), metaFormat);
---
>     private String insertFormats(String pattern, ArrayList customPatterns) {
>         if (!containsElements(customPatterns)) {
>             return pattern;
>         }
>         StringBuffer sb = new StringBuffer(pattern.length() * 2);
>         ParsePosition pos = new ParsePosition(0);
>         int fe = -1;
>         int depth = 0;
>         while (pos.getIndex() < pattern.length()) {
>             char c = pattern.charAt(pos.getIndex());
>             switch (c) {
>             case QUOTE:
>                 appendQuotedString(pattern, pos, sb, false);
>                 break;
>             case START_FE:
>                 depth++;
>                 if (depth == 1) {
>                     fe++;
>                     sb.append(START_FE).append(
>                             readArgumentIndex(pattern, next(pos)));
>                     String customPattern = (String) customPatterns.get(fe);
>                     if (customPattern != null) {
>                         sb.append(START_FMT).append(customPattern);
>                     }
>                 }
>                 break;
>             case END_FE:
>                 depth--;
>                 
>             default:
>                 sb.append(c);
>                 next(pos);
>             }
>         }
>         return sb.toString();
351,366c354,360
< 
< 
< 
<     public ExtendedMessageFormat(String pattern, Locale locale,
<             Format metaFormat) {
<         
< 
< 
< 
< 
< 
< 
<         super(pattern);
<         setLocale(locale);
<         setMetaFormat(metaFormat);
<         applyPattern(pattern);
---
>     private void seekNonWs(String pattern, ParsePosition pos) {
>         int len = 0;
>         char[] buffer = pattern.toCharArray();
>         do {
>             len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());
>             pos.setIndex(pos.getIndex() + len);
>         } while (len > 0 && pos.getIndex() < pattern.length());
374,382c368,371
<     public final void applyPattern(String pattern) {
<         if (metaFormat == null) {
<             return;
<         }
<         applyPatternPre(pattern);
<         strippedPattern = PARSER.stripFormats(pattern);
<         super.applyPattern(strippedPattern);
<         setFormats(PARSER.parseFormats(pattern, metaFormat));
<         applyPatternPost(pattern);
---
> 
>     private ParsePosition next(ParsePosition pos) {
>         pos.setIndex(pos.getIndex() + 1);
>         return pos;
391,393d379
<     protected void applyPatternPre(String pattern) {
<         
<     }
395d380
<     
399,402c384,410
< 
< 
<     protected void applyPatternPost(String pattern) {
<         
---
>     private StringBuffer appendQuotedString(String pattern, ParsePosition pos,
>             StringBuffer appendTo, boolean escapingOn) {
>         int start = pos.getIndex();
>         char[] c = pattern.toCharArray();
>         if (escapingOn && c[start] == QUOTE) {
>             return appendTo == null ? null : appendTo.append(QUOTE);
>         }
>         int lastHold = start;
>         for (int i = pos.getIndex(); i < pattern.length(); i++) {
>             if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {
>                 appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(
>                         QUOTE);
>                 pos.setIndex(i + ESCAPED_QUOTE.length());
>                 lastHold = pos.getIndex();
>                 continue;
>             }
>             switch (c[pos.getIndex()]) {
>             case QUOTE:
>                 next(pos);
>                 return appendTo == null ? null : appendTo.append(c, lastHold,
>                         pos.getIndex() - lastHold);
>             default:
>                 next(pos);
>             }
>         }
>         throw new IllegalArgumentException(
>                 "Unterminated quoted string at position " + start);
411,416d418
<     public String toPattern() {
<         return PARSER.insertFormats(strippedPattern, getFormats(), metaFormat);
<     }
< 
<     
< 
418,421c420,422
< 
< 
<     public synchronized Format getMetaFormat() {
<         return metaFormat;
---
>     private void getQuotedString(String pattern, ParsePosition pos,
>             boolean escapingOn) {
>         appendQuotedString(pattern, pos, null, escapingOn);
429,432c430,439
< 
<     public synchronized void setMetaFormat(Format metaFormat) {
<         Validate.notNull(metaFormat, "metaFormat is null");
<         this.metaFormat = metaFormat;
---
>     private boolean containsElements(Collection coll) {
>         if (coll == null || coll.size() == 0) {
>             return false;
>         }
>         for (Iterator iter = coll.iterator(); iter.hasNext();) {
>             if (iter.next() != null) {
>                 return true;
>             }
>         }
>         return false;
434d440
< 
