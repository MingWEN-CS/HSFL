18a19,20
> import java.lang.reflect.InvocationTargetException;
> import java.lang.reflect.Method;
638c640,645
<     public static String stripAccents(String input) {
---
> 
> 
> 
> 
>     
>     public static String stripAccents(CharSequence input) {
642c649,715
<         if(SystemUtils.isJavaVersionAtLeast(1.6f)) {
---
>         try {
>             String result = null;
>             if (java6Available) {
>                 result = removeAccentsJava6(input);
>             } else if (sunAvailable) {
>                 result = removeAccentsSUN(input);
>             } else {
>             	throw new UnsupportedOperationException("The stripAccents(CharSequence) method requires at least Java 1.6 or a SUN JVM");
>             }
>             
>             return result;
>         } catch(IllegalArgumentException iae) {
>             throw new RuntimeException("IllegalArgumentException occurred during 1.6 backcompat code", iae);
>         } catch(IllegalAccessException iae) {
>             throw new RuntimeException("IllegalAccessException occurred during 1.6 backcompat code", iae);
>         } catch(InvocationTargetException ite) {
>             throw new RuntimeException("InvocationTargetException occurred during 1.6 backcompat code", ite);
>         } catch(SecurityException se) {
>             throw new RuntimeException("SecurityException occurred during 1.6 backcompat code", se);
>         }
>     }
> 
>     
> 
> 
> 
> 
>     private static String removeAccentsJava6(CharSequence text) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
>         
> 
> 
> 
>         if (!java6Available || java6NormalizerFormNFD == null) {
>             throw new IllegalStateException("java.text.Normalizer is not available");
>         }
>         String result;
>         result = (String) java6NormalizeMethod.invoke(null, new Object[] {text, java6NormalizerFormNFD});
>         result = java6Pattern.matcher(result).replaceAll("");
>         return result;
>     }
> 
>     
> 
> 
>     private static String removeAccentsSUN(CharSequence text) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
>         
> 
> 
> 
>         if (! sunAvailable) {
>             throw new IllegalStateException("sun.text.Normalizer is not available");
>         }
>         String result;
>         result = (String) sunDecomposeMethod.invoke(null, new Object[] {text, Boolean.FALSE, Integer.valueOf(0)});
>         result = sunPattern.matcher(result).replaceAll("");
>         return result;
>     }
> 
>     
>     private static boolean sunAvailable = false;
>     private static Method  sunDecomposeMethod = null;
>     private static final Pattern sunPattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+");
>     
>     private static boolean java6Available = false;
>     private static Method  java6NormalizeMethod = null;
>     private static Object  java6NormalizerFormNFD = null;
>     private static final Pattern java6Pattern = sunPattern;
643a717,718
>     static {
>         try {
644a720,728
>             
>             Class<?> normalizerFormClass = Thread.currentThread().getContextClassLoader().loadClass("java.text.Normalizer$Form");
>             java6NormalizerFormNFD = normalizerFormClass.getField("NFD").get(null);
>             Class<?> normalizerClass = Thread.currentThread().getContextClassLoader().loadClass("java.text.Normalizer");
>             java6NormalizeMethod = normalizerClass.getMethod("normalize", new Class[] {CharSequence.class, normalizerFormClass});
>             java6Available = true;
>         } catch (Exception e) {
>             java6Available = false;
>         }
645a730
>         try {
647,682c732,736
<             try {
<                 
<                 Class<?> normalizerFormClass = ClassUtils.getClass("java.text.Normalizer$Form", false);
< 
<                 
<                 Class<?> normalizerClass = ClassUtils.getClass("java.text.Normalizer", false);
< 
<                 
<                 java.lang.reflect.Method method = normalizerClass.getMethod("normalize", CharSequence.class, normalizerFormClass );
< 
<                 
<                 java.lang.reflect.Field nfd = normalizerFormClass.getField("NFD");
< 
<                 
<                 String decomposed = (String) method.invoke( null, input, nfd.get(null) );
<                 
< 
<                 java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile("\\p{InCombiningDiacriticalMarks}+");
<                 return accentPattern.matcher(decomposed).replaceAll("");
<             } catch(ClassNotFoundException cnfe) {
<                 throw new RuntimeException("ClassNotFoundException occurred during 1.6 backcompat code", cnfe);
<             } catch(NoSuchMethodException nsme) {
<                 throw new RuntimeException("NoSuchMethodException occurred during 1.6 backcompat code", nsme);
<             } catch(NoSuchFieldException nsfe) {
<                 throw new RuntimeException("NoSuchFieldException occurred during 1.6 backcompat code", nsfe);
<             } catch(IllegalAccessException iae) {
<                 throw new RuntimeException("IllegalAccessException occurred during 1.6 backcompat code", iae);
<             } catch(IllegalArgumentException iae) {
<                 throw new RuntimeException("IllegalArgumentException occurred during 1.6 backcompat code", iae);
<             } catch(java.lang.reflect.InvocationTargetException ite) {
<                 throw new RuntimeException("InvocationTargetException occurred during 1.6 backcompat code", ite);
<             } catch(SecurityException se) {
<                 throw new RuntimeException("SecurityException occurred during 1.6 backcompat code", se);
<             }
<         } else {
<             throw new UnsupportedOperationException("The stripAccents(String) method is not supported until Java 1.6");
---
>             Class<?> normalizerClass = Thread.currentThread().getContextClassLoader().loadClass("sun.text.Normalizer");
>             sunDecomposeMethod = normalizerClass.getMethod("decompose", new Class[] {String.class, Boolean.TYPE, Integer.TYPE});
>             sunAvailable = true;
>         } catch (Exception e) {
>             sunAvailable = false;
