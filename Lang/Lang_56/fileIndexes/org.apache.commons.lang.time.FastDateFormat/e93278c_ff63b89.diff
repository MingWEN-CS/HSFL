56d55
< import java.io.Serializable;
88a88,94
> 
> 
> 
> 
> 
> 
> 
91a98,108
>     
>     
>     
>     
>     
>     
>     
>     
>     
>     
>     
104d120
<     private static TimeZone cDefaultTimeZone = TimeZone.getDefault();
116a133,134
>     private final boolean mTimeZoneForced;
>     
119c137
<     private final Rule[] mRules;
---
>     private final boolean mLocaleForced;
121c139,141
<     private final int mMaxLengthEstimate;
---
>     private Rule[] mRules;
>     
>     private int mMaxLengthEstimate;
178,186c198,199
<         Object key = pattern;
<         if (timeZone != null) {
<             key = new Pair(key, timeZone);
<         }
<         if (locale != null) {
<             key = new Pair(key, locale);
<         }
< 
<         FastDateFormat format = (FastDateFormat) cInstanceCache.get(key);
---
>         FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
>         FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);
188,193c201,203
<             if (locale == null) {
<                 locale = Locale.getDefault();
<             }
< 
<             format = new FastDateFormat(pattern, timeZone, locale, new DateFormatSymbols(locale));
<             cInstanceCache.put(key, format);
---
>             format = emptyFormat;
>             format.init();  
>             cInstanceCache.put(format, format);  
345a356,386
>     
>     
> 
> 
> 
> 
> 
> 
> 
> 
>     protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {
>         super();
>         if (pattern == null) {
>             throw new IllegalArgumentException("The pattern must not be null");
>         }
>         mPattern = pattern;
>         
>         mTimeZoneForced = (timeZone != null);
>         if (timeZone == null) {
>             timeZone = TimeZone.getDefault();
>         }
>         mTimeZone = timeZone;
>         
>         mLocaleForced = (locale != null);
>         if (locale == null) {
>             locale = Locale.getDefault();
>         }
>         mLocale = locale;
>     }
> 
>     
347a389,391
>     protected void init() {
>         List rulesList = parsePattern();
>         mRules = (Rule[]) rulesList.toArray(new Rule[rulesList.size()]);
348a393,396
>         int len = 0;
>         for (int i=mRules.length; --i >= 0; ) {
>             len += mRules[i].estimateLength();
>         }
349a398,399
>         mMaxLengthEstimate = len;
>     }
350a401,403
>     
>     
>     
355c408,410
<     private static List parse(String pattern, TimeZone timeZone, Locale locale, DateFormatSymbols symbols) {
---
> 
>     protected List parsePattern() {
>         DateFormatSymbols symbols = new DateFormatSymbols(mLocale);
365c420
<         int length = pattern.length();
---
>         int length = mPattern.length();
370c425
<             String token = parseToken(pattern, indexRef);
---
>             String token = parseToken(mPattern, indexRef);
387c442
<                     rule = new UnpaddedNumberField(Calendar.YEAR);
---
>                     rule = UnpaddedNumberField.INSTANCE_YEAR;
389c444
<                     rule = new TwoDigitYearField();
---
>                     rule = TwoDigitYearField.INSTANCE;
398c453
<                     rule = new TwoDigitMonthField();
---
>                     rule = TwoDigitMonthField.INSTANCE;
400c455
<                     rule = new UnpaddedMonthField();
---
>                     rule = UnpaddedMonthField.INSTANCE;
447c502,509
<                     rule = new TimeZoneRule(timeZone, locale, TimeZone.LONG);
---
>                     rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);
>                 } else {
>                     rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);
>                 }
>                 break;
>             case 'Z': 
>                 if (tokenLen == 1) {
>                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON;
449c511
<                     rule = new TimeZoneRule(timeZone, locale, TimeZone.SHORT);
---
>                     rule = TimeZoneNumberRule.INSTANCE_COLON;
477c539
<     private static String parseToken(String pattern, int[] indexRef) {
---
>     protected String parseToken(String pattern, int[] indexRef) {
536c598
<     private static NumberRule selectNumberRule(int field, int padding) {
---
>     protected NumberRule selectNumberRule(int field, int padding) {
549,581d610
< 
< 
< 
< 
< 
< 
< 
< 
<     private FastDateFormat(String pattern, TimeZone timeZone, Locale locale, DateFormatSymbols symbols) {
<         if (locale == null) {
<             locale = Locale.getDefault();
<         }
< 
<         mPattern = pattern;
<         mTimeZone = timeZone;
<         mLocale = locale;
< 
<         if (symbols == null) {
<             symbols = new DateFormatSymbols(locale);
<         }
< 
<         List rulesList = parse(pattern, timeZone, locale, symbols);
<         mRules = (Rule[]) rulesList.toArray(new Rule[rulesList.size()]);
< 
<         int len = 0;
<         for (int i=mRules.length; --i >= 0; ) {
<             len += mRules[i].estimateLength();
<         }
< 
<         mMaxLengthEstimate = len;
<     }
< 
<     
608c637
<         Calendar c = new GregorianCalendar(cDefaultTimeZone);
---
>         Calendar c = new GregorianCalendar(mTimeZone);
610,612d638
<         if (mTimeZone != null) {
<             c.setTimeZone(mTimeZone);
<         }
634c660
<         Calendar c = new GregorianCalendar(cDefaultTimeZone);
---
>         Calendar c = new GregorianCalendar(mTimeZone);
636,638d661
<         if (mTimeZone != null) {
<             c.setTimeZone(mTimeZone);
<         }
650,651c673,674
<         if (mTimeZone != null) {
<             calendar = (Calendar)calendar.clone();
---
>         if (mTimeZoneForced) {
>             calendar = (Calendar) calendar.clone();
664c687
<     private StringBuffer applyRules(Calendar calendar, StringBuffer buf) {
---
>     protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {
674a698
>     
688a713
>     
702a728,730
> 
> 
> 
711a740,749
> 
>     public boolean getTimeZoneOverridesCalendar() {
>         return mTimeZoneForced;
>     }
> 
>     
> 
> 
> 
> 
727a766,815
>     
> 
> 
> 
> 
> 
>     public boolean equals(Object obj) {
>         if (obj instanceof FastDateFormat == false) {
>             return false;
>         }
>         FastDateFormat other = (FastDateFormat) obj;
>         if (
>             (mPattern == other.mPattern || mPattern.equals(other.mPattern)) &&
>             (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) &&
>             (mLocale == other.mLocale || mLocale.equals(other.mLocale)) &&
>             (mTimeZoneForced == other.mTimeZoneForced) &&
>             (mLocaleForced == other.mLocaleForced)
>             ) {
>             return true;
>         }
>         return false;
>     }
> 
>     
> 
> 
> 
> 
>     public int hashCode() {
>         int total = 0;
>         total += mPattern.hashCode();
>         total += mTimeZone.hashCode();
>         total += (mTimeZoneForced ? 1 : 0);
>         total += mLocale.hashCode();
>         total += (mLocaleForced ? 1 : 0);
>         return total;
>     }
> 
>     
> 
> 
> 
> 
>     public String toString() {
>         return "FastDateFormat[" + mPattern + "]";
>     }
>     
>     
>     
>     
811a900,901
>         static final UnpaddedNumberField INSTANCE_YEAR = new UnpaddedNumberField(Calendar.YEAR);
>         
829,830c919
<             }
<             else if (value < 100) {
---
>             } else if (value < 100) {
833,834c922
<             }
<             else {
---
>             } else {
843a932,933
>         static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField();
>         
858,859c948
<             }
<             else {
---
>             } else {
897,898c986
<             }
<             else {
---
>             } else {
902,903c990
<                 }
<                 else {
---
>                 } else {
936,937c1023
<             }
<             else {
---
>             } else {
946a1033,1034
>         static final TwoDigitYearField INSTANCE = new TwoDigitYearField();
>         
967a1056,1057
>         static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField();
>         
1042c1132
<     private static class TimeZoneRule implements Rule {
---
>     private static class TimeZoneNameRule implements Rule {
1043a1134
>         private final boolean mTimeZoneForced;
1049c1140
<         TimeZoneRule(TimeZone timeZone, Locale locale, int style) {
---
>         TimeZoneNameRule(TimeZone timeZone, boolean timeZoneForced, Locale locale, int style) {
1050a1142
>             mTimeZoneForced = timeZoneForced;
1054c1146
<             if (timeZone != null) {
---
>             if (timeZoneForced) {
1057,1058c1149
<             }
<             else {
---
>             } else {
1065c1156
<             if (mTimeZone != null) {
---
>             if (mTimeZoneForced) {
1067,1068c1158
<             }
<             else if (mStyle == TimeZone.SHORT) {
---
>             } else if (mStyle == TimeZone.SHORT) {
1070,1071c1160
<             }
<             else {
---
>             } else {
1077,1081c1166,1167
<             TimeZone timeZone;
<             if ((timeZone = mTimeZone) != null) {
<                 if (timeZone.useDaylightTime() &&
<                     calendar.get(Calendar.DST_OFFSET) != 0) {
< 
---
>             if (mTimeZoneForced) {
>                 if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {
1083,1084c1169
<                 }
<                 else {
---
>                 } else {
1087,1098c1172,1177
<             }
<             else {
<                 timeZone = calendar.getTimeZone();
<                 if (timeZone.useDaylightTime() &&
<                     calendar.get(Calendar.DST_OFFSET) != 0) {
< 
<                     buffer.append(getTimeZoneDisplay
<                                   (timeZone, true, mStyle, mLocale));
<                 }
<                 else {
<                     buffer.append(getTimeZoneDisplay
<                                   (timeZone, false, mStyle, mLocale));
---
>             } else {
>                 TimeZone timeZone = calendar.getTimeZone();
>                 if (timeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {
>                     buffer.append(getTimeZoneDisplay(timeZone, true, mStyle, mLocale));
>                 } else {
>                     buffer.append(getTimeZoneDisplay(timeZone, false, mStyle, mLocale));
1104a1184,1224
> 
> 
>     private static class TimeZoneNumberRule implements Rule {
>         static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true);
>         static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false);
>         
>         final boolean mColon;
>         
>         TimeZoneNumberRule(boolean colon) {
>             mColon = colon;
>         }
> 
>         public int estimateLength() {
>             return 5;
>         }
> 
>         public void appendTo(StringBuffer buffer, Calendar calendar) {
>             int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
>             
>             if (offset < 0) {
>                 buffer.append('-');
>                 offset = -offset;
>             } else {
>                 buffer.append('+');
>             }
>             
>             int hours = offset / (60 * 60 * 1000);
>             buffer.append((char)(hours / 10 + '0'));
>             buffer.append((char)(hours % 10 + '0'));
>             
>             if (mColon) {
>                 buffer.append(':');
>             }
>             
>             int minutes = offset / (60 * 1000) - 60 * hours;
>             buffer.append((char)(minutes / 10 + '0'));
>             buffer.append((char)(minutes % 10 + '0'));
>         }            
>     }
> 
>     
1147c1267
<     private static class Pair implements Comparable, Serializable {
---
>     private static class Pair {
1154,1203d1273
<         }
< 
<         public int compareTo(Object obj) {
<             if (this == obj) {
<                 return 0;
<             }
< 
<             Pair other = (Pair)obj;
< 
<             Object a = mObj1;
<             Object b = other.mObj1;
< 
<             firstTest: {
<                 if (a == null) {
<                     if (b != null) {
<                         return 1;
<                     }
<                     
<                     break firstTest;
<                 }
<                 else {
<                     if (b == null) {
<                         return -1;
<                     }
<                 }
< 
<                 int result = ((Comparable)a).compareTo(b);
< 
<                 if (result != 0) {
<                     return result;
<                 }
<             }
< 
<             a = mObj2;
<             b = other.mObj2;
< 
<             if (a == null) {
<                 if (b != null) {
<                     return 1;
<                 }
<                 
<                 return 0;
<             }
<             else {
<                 if (b == null) {
<                     return -1;
<                 }
<             }
< 
<             return ((Comparable)a).compareTo(b);
