24a25
> import java.io.ObjectStreamClass;
76c77,87
<         
---
>         if (object == null) {
>             return null;
>         }
>         byte[] objectData = serialize(object);
>         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);
> 
>         ClassLoaderAwareObjectInputStream in = null;
>         try {
>             
>             in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader());
>             
81,83c92,106
<         @SuppressWarnings("unchecked")
<         final T result = (T) deserialize(serialize(object));
<         return result;
---
>             return (T) in.readObject();
> 
>         } catch (ClassNotFoundException ex) {
>             throw new SerializationException("ClassNotFoundException while reading cloned object data", ex);
>         } catch (IOException ex) {
>             throw new SerializationException("IOException while reading cloned object data", ex);
>         } finally {
>             try {
>                 if (in != null) {
>                     in.close();
>                 }
>             } catch (IOException ex) {
>                 throw new SerializationException("IOException on closing cloned object data InputStream.", ex);
>             }
>         }
195a219,266
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>      static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {
>         private ClassLoader classLoader;
> 
>         
> 
> 
> 
> 
> 
> 
>         public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {
>             super(in);
>             this.classLoader = classLoader;
>         }
> 
>         
> 
> 
> 
> 
> 
> 
> 
>         @Override
>         protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
>             String name = desc.getName();
>             try {
>                 return Class.forName(name, false, classLoader);
>             } catch (ClassNotFoundException ex) {
>                 return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
>             }
>         }
> 
