1a2,334
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> package org.joda.time.chrono;
> 
> import java.util.HashMap;
> import java.util.Map;
> 
> import org.joda.time.Chronology;
> import org.joda.time.DateTimeConstants;
> import org.joda.time.DateTimeField;
> import org.joda.time.DateTimeZone;
> import org.joda.time.field.DelegatedDateTimeField;
> import org.joda.time.field.FieldUtils;
> 
> 
> 
> 
> 
> 
> 
> public final class JulianChronology extends AbstractGJChronology {
> 
>     static final long serialVersionUID = -8731039522547897247L;
> 
>     private static final long MILLIS_PER_YEAR =
>         (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);
> 
>     private static final long MILLIS_PER_MONTH =
>         (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY / 12);
> 
>     
>     private static final JulianChronology INSTANCE_UTC;
> 
>     
>     private static final Map cCache = new HashMap();
> 
>     static {
>         INSTANCE_UTC = getInstance(DateTimeZone.UTC);
>     }
> 
>     static int adjustYearForSet(int year) {
>         if (year <= 0) {
>             if (year == 0) {
>                 throw new IllegalArgumentException("Invalid year: " + year);
>             }
>             year++;
>         }
>         return year;
>     }
> 
>     
> 
> 
> 
> 
> 
>     public static JulianChronology getInstanceUTC() {
>         return INSTANCE_UTC;
>     }
> 
>     
> 
> 
> 
> 
>     public static JulianChronology getInstance() {
>         return getInstance(DateTimeZone.getDefault(), 4);
>     }
> 
>     
> 
> 
> 
> 
> 
>     public static JulianChronology getInstance(DateTimeZone zone) {
>         return getInstance(zone, 4);
>     }
> 
>     
> 
> 
> 
> 
> 
> 
>     public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {
>         if (zone == null) {
>             zone = DateTimeZone.getDefault();
>         }
>         JulianChronology chrono;
>         synchronized (cCache) {
>             JulianChronology[] chronos = (JulianChronology[]) cCache.get(zone);
>             if (chronos == null) {
>                 chronos = new JulianChronology[7];
>                 cCache.put(zone, chronos);
>             }
>             try {
>                 chrono = chronos[minDaysInFirstWeek - 1];
>             } catch (ArrayIndexOutOfBoundsException e) {
>                 throw new IllegalArgumentException
>                     ("Invalid min days in first week: " + minDaysInFirstWeek);
>             }
>             if (chrono == null) {
>                 if (zone == DateTimeZone.UTC) {
>                     chrono = new JulianChronology(null, null, minDaysInFirstWeek);
>                 } else {
>                     chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);
>                     chrono = new JulianChronology
>                         (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);
>                 }
>                 chronos[minDaysInFirstWeek - 1] = chrono;
>             }
>         }
>         return chrono;
>     }
> 
>     
>     
> 
>     
> 
> 
>     JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {
>         super(base, param, minDaysInFirstWeek);
>     }
> 
>     
> 
> 
>     private Object readResolve() {
>         return getInstance(getBase().getDateTimeZone());
>     }
> 
>     
>     
>     
> 
> 
> 
> 
>     public Chronology withUTC() {
>         return INSTANCE_UTC;
>     }
> 
>     
> 
> 
> 
> 
> 
>     public Chronology withDateTimeZone(DateTimeZone zone) {
>         if (zone == null) {
>             zone = DateTimeZone.getDefault();
>         }
>         if (zone == getDateTimeZone()) {
>             return this;
>         }
>         return getInstance(zone);
>     }
> 
>     public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
>         throws IllegalArgumentException
>     {
>         return super.getDateOnlyMillis(adjustYearForSet(year), monthOfYear, dayOfMonth);
>     }
> 
>     boolean isLeapYear(int year) {
>         return (year & 3) == 0;
>     }
> 
>     long calculateFirstDayOfYearMillis(int year) {
>         
>         
>         
> 
>         int relativeYear = year - 1968;
>         int leapYears;
>         if (relativeYear <= 0) {
>             
>             
>             leapYears = (relativeYear + 3) >> 2;
>         } else {
>             leapYears = relativeYear >> 2;
>             
>             if (!isLeapYear(year)) {
>                 leapYears++;
>             }
>         }
>         
>         long millis = (relativeYear * 365L + leapYears)
>             * (long)DateTimeConstants.MILLIS_PER_DAY;
> 
>         
> 
>         return millis - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY;
>     }
> 
>     int getMinYear() {
>         
>         return -292269053;
>     }
> 
>     int getMaxYear() {
>         
>         return 292272992;
>     }
> 
>     long getAverageMillisPerYear() {
>         return MILLIS_PER_YEAR;
>     }
> 
>     long getAverageMillisPerMonth() {
>         return MILLIS_PER_MONTH;
>     }
> 
>     long getApproxMillisAtEpoch() {
>         return 1969L * MILLIS_PER_YEAR + 352L * DateTimeConstants.MILLIS_PER_DAY;
>     }
> 
>     protected void assemble(Fields fields) {
>         if (getBase() == null) {
>             super.assemble(fields);
>             
>             fields.year = new NoYearZeroField(this, fields.year);
>             fields.weekyear = new NoWeekyearZeroField(this, fields.weekyear);
>         }
>     }
> 
>     static class NoYearZeroField extends DelegatedDateTimeField {
>         static final long serialVersionUID = -8869148464118507846L;
> 
>         final AbstractGJChronology iChronology;
>         private transient int iMinYear;
> 
>         NoYearZeroField(AbstractGJChronology chronology, DateTimeField field) {
>             super(field);
>             iChronology = chronology;
>             int min = super.getMinimumValue();
>             if (min < 0) {
>                 iMinYear = min - 1;
>             } else if (min == 0) {
>                 iMinYear = 1;
>             } else {
>                 iMinYear = min;
>             }
>         }
>         
>         public int get(long millis) {
>             int year = super.get(millis);
>             if (year <= 0) {
>                 year--;
>             }
>             return year;
>         }
> 
>         public long set(long millis, int year) {
>             FieldUtils.verifyValueBounds(this, year, iMinYear, getMaximumValue());
>             return super.set(millis, adjustYearForSet(year));
>         }
> 
>         public int getMinimumValue() {
>             return iMinYear;
>         }
> 
>         private Object readResolve() {
>             return iChronology.year();
>         }
>     }
> 
>     static class NoWeekyearZeroField extends NoYearZeroField {
>         static final long serialVersionUID = -5013429014495501104L;
> 
>         NoWeekyearZeroField(AbstractGJChronology chronology, DateTimeField field) {
>             super(chronology, field);
>         }
>         
>         private Object readResolve() {
>             return iChronology.weekyear();
>         }
>     }
> 
> }
