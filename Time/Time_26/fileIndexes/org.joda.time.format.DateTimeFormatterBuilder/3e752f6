




















































package org.joda.time.format;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import org.joda.time.Chronology;
import org.joda.time.DateTimeConstants;
import org.joda.time.DateTimeField;
import org.joda.time.DateTimeFieldType;
import org.joda.time.DateTimeZone;
import org.joda.time.ReadablePartial;
import org.joda.time.field.MillisDurationField;
import org.joda.time.field.PreciseDateTimeField;



























public class DateTimeFormatterBuilder {

    
    private final Locale iLocale;

    
    private ArrayList iElementPairs;
    private Object iFormatter;

    
    


    public DateTimeFormatterBuilder() {
        this(Locale.getDefault());
    }

    




    public DateTimeFormatterBuilder(Locale locale) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        iLocale = locale;
        iElementPairs = new ArrayList();
    }

    
    


    public Locale getLocale() {
        return iLocale;
    }

    
    







    public DateTimePrinter toPrinter() throws UnsupportedOperationException {
        Object f = getFormatter();
        if (isPrinter(f)) {
            return (DateTimePrinter)f;
        }
        throw new UnsupportedOperationException("Printing not supported");
    }

    







    public DateTimeParser toParser() throws UnsupportedOperationException {
        Object f = getFormatter();
        if (isParser(f)) {
            return (DateTimeParser)f;
        }
        throw new UnsupportedOperationException("Parsing not supported");
    }

    







    public DateTimeFormatter toFormatter() throws UnsupportedOperationException {
        Object f = getFormatter();
        if (isFormatter(f)) {
            return (DateTimeFormatter)f;
        }
        throw new UnsupportedOperationException("Both printing and parsing not supported");
    }

    
    



    public boolean canBuildPrinter() {
        return isPrinter(getFormatter());
    }

    



    public boolean canBuildParser() {
        return isParser(getFormatter());
    }

    



    public boolean canBuildFormatter() {
        return isFormatter(getFormatter());
    }

    
    



    public void clear() {
        iFormatter = null;
        iElementPairs.clear();
    }

    
    









    public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {
        if (formatter == null) {
            throw new IllegalArgumentException("No formatter supplied");
        }
        if (formatter instanceof BaseDateTimeFormatter == false) {
            throw new IllegalArgumentException("Formatter must extend BaseDateTimeFormatter");
        }
        return append0(formatter);
    }

    










    public DateTimeFormatterBuilder append(DateTimePrinter printer) {
        checkPrinter(printer);
        return append0(printer, null);
    }

    










    public DateTimeFormatterBuilder append(DateTimeParser parser) {
        checkParser(parser);
        return append0(null, parser);
    }

    










    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) {
        checkPrinter(printer);
        checkParser(parser);
        return append0(printer, parser);
    }

    



















    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {
        if (printer != null) {
            checkPrinter(printer);
        }
        if (parsers == null) {
            throw new IllegalArgumentException("No parsers supplied");
        }
        int length = parsers.length;
        BaseDateTimeFormatter[] copyOfParsers = new BaseDateTimeFormatter[length];
        for (int i = 0; i < length; i++) {
            DateTimeParser parser = parsers[i];
            if (i == length - 1 && parser == null) {
                
            } else {
                if (parser == null) {
                    throw new IllegalArgumentException("Incomplete parser array");
                } else if (parser instanceof BaseDateTimeFormatter == false) {
                    throw new IllegalArgumentException("Parser must extend BaseDateTimeFormatter");
                }
                copyOfParsers[i] = (BaseDateTimeFormatter) parser;
            }
        }
        
        return append0(printer, new MatchingParser(copyOfParsers));
    }

    









    public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {
        checkParser(parser);
        BaseDateTimeFormatter[] parsers = new BaseDateTimeFormatter[] {
            (BaseDateTimeFormatter) parser, null};
        return append0(null, new MatchingParser(parsers));
    }

    
    




    private void checkParser(DateTimeParser parser) {
        if (parser == null) {
            throw new IllegalArgumentException("No parser supplied");
        }
        if (parser instanceof BaseDateTimeFormatter == false) {
            throw new IllegalArgumentException("Parser must extend BaseDateTimeFormatter");
        }
    }

    




    private void checkPrinter(DateTimePrinter printer) {
        if (printer == null) {
            throw new IllegalArgumentException("No printer supplied");
        }
        if (printer instanceof BaseDateTimeFormatter == false) {
            throw new IllegalArgumentException("Printer must extend BaseDateTimeFormatter");
        }
    }

    private DateTimeFormatterBuilder append0(Object element) {
        iFormatter = null;
        
        iElementPairs.add(element);
        iElementPairs.add(element);
        return this;
    }

    private DateTimeFormatterBuilder append0(
            DateTimePrinter printer, DateTimeParser parser) {
        iFormatter = null;
        iElementPairs.add(printer);
        iElementPairs.add(parser);
        return this;
    }

    
    





    public DateTimeFormatterBuilder appendLiteral(char c) {
        return append0(new CharacterLiteral(c));
    }

    






    public DateTimeFormatterBuilder appendLiteral(String text) {
        if (text == null) {
            throw new IllegalArgumentException("Literal must not be null");
        }
        switch (text.length()) {
            case 0:
                return this;
            case 1:
                return append0(new CharacterLiteral(text.charAt(0)));
            default:
                return append0(new StringLiteral(text));
        }
    }

    










    public DateTimeFormatterBuilder appendDecimal(
            DateTimeFieldType fieldType, int minDigits, int maxDigits) {
        if (fieldType == null) {
            throw new IllegalArgumentException("Field type must not be null");
        }
        if (maxDigits < minDigits) {
            maxDigits = minDigits;
        }
        if (minDigits < 0 || maxDigits <= 0) {
            throw new IllegalArgumentException();
        }
        if (minDigits <= 1) {
            return append0(new UnpaddedNumber(fieldType, maxDigits, false));
        } else {
            return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));
        }
    }

    










    public DateTimeFormatterBuilder appendSignedDecimal(
            DateTimeFieldType fieldType, int minDigits, int maxDigits) {
        if (fieldType == null) {
            throw new IllegalArgumentException("Field type must not be null");
        }
        if (maxDigits < minDigits) {
            maxDigits = minDigits;
        }
        if (minDigits < 0 || maxDigits <= 0) {
            throw new IllegalArgumentException();
        }
        if (minDigits <= 1) {
            return append0(new UnpaddedNumber(fieldType, maxDigits, true));
        } else {
            return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));
        }
    }

    







    public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {
        if (fieldType == null) {
            throw new IllegalArgumentException("Field type must not be null");
        }
        return append0(new TextField(fieldType, iLocale, false));
    }

    







    public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {
        if (fieldType == null) {
            throw new IllegalArgumentException("Field type must not be null");
        }
        return append0(new TextField(fieldType, iLocale, true));
    }

    












    public DateTimeFormatterBuilder appendFraction(
            DateTimeFieldType fieldType, int minDigits, int maxDigits) {
        if (fieldType == null) {
            throw new IllegalArgumentException("Field type must not be null");
        }
        if (maxDigits < minDigits) {
            maxDigits = minDigits;
        }
        if (minDigits < 0 || maxDigits <= 0) {
            throw new IllegalArgumentException();
        }
        return append0(new Fraction(fieldType, minDigits, maxDigits));
    }

    




    public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {
        return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);
    }

    




    public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {
        return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);
    }

    




    public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {
        return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);
    }

    




    public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {
        return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);
    }

    





    public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {
        return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);
    }

    





    public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {
        return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);
    }

    





    public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {
        return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);
    }

    





    public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {
        return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);
    }

    





    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {
        return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);
    }

    





    public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {
        return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);
    }

    





    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {
        return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);
    }

    





    public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {
        return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);
    }

    





    public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {
        return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);
    }

    





    public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {
        return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);
    }

    





    public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {
        return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);
    }

    





    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {
        return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);
    }

    





    public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {
        return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);
    }

    





    public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {
        return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);
    }

    







    public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {
        return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);
    }

    





    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {
        return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);
    }

    







    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {
        return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);
    }

    

















    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {
        return append0(new TwoDigitYear(pivot));
    }

    







    public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {
        return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);
    }

    







    public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {
        return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);
    }

    







    public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {
        return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);
    }

    





    public DateTimeFormatterBuilder appendHalfdayOfDayText() {
        return appendText(DateTimeFieldType.halfdayOfDay());
    }

    





    public DateTimeFormatterBuilder appendDayOfWeekText() {
        return appendText(DateTimeFieldType.dayOfWeek());
    }

    






    public DateTimeFormatterBuilder appendDayOfWeekShortText() {
        return appendShortText(DateTimeFieldType.dayOfWeek());
    }

    






    public DateTimeFormatterBuilder appendMonthOfYearText() { 
        return appendText(DateTimeFieldType.monthOfYear());
    }

    





    public DateTimeFormatterBuilder appendMonthOfYearShortText() {
        return appendShortText(DateTimeFieldType.monthOfYear());
    }

    





    public DateTimeFormatterBuilder appendEraText() {
        return appendText(DateTimeFieldType.era());
    }

    






    public DateTimeFormatterBuilder appendTimeZoneName() {
        return append0(new TimeZonePrinter( iLocale, false), null);
    }

    






    public DateTimeFormatterBuilder appendTimeZoneShortName() {
        return append0(new TimeZonePrinter( iLocale, true), null);
    }

    













    public DateTimeFormatterBuilder appendTimeZoneOffset(
            String zeroOffsetText, boolean showSeparators,
            int minFields, int maxFields) {
        return append0(new TimeZoneOffsetFormatter
                       (zeroOffsetText, showSeparators, minFields, maxFields));
    }

    







    public DateTimeFormatterBuilder appendPattern(String pattern) {
        DateTimeFormat.appendPatternTo(this, pattern);
        return this;
    }

    private Object getFormatter() {
        Object f = iFormatter;

        if (f == null) {
            if (iElementPairs.size() == 2) {
                Object printer = iElementPairs.get(0);
                Object parser = iElementPairs.get(1);

                if (printer != null) {
                    if (printer == parser || parser == null) {
                        f = printer;
                    }
                } else {
                    f = parser;
                }
            }

            if (f == null) {
                f = new Composite(iElementPairs);
            }

            iFormatter = f;
        }

        return f;
    }

    private boolean isPrinter(Object f) {
        if (f instanceof DateTimePrinter) {
            if (f instanceof Composite) {
                return ((Composite)f).isPrinter();
            }
            return true;
        }
        return false;
    }

    private boolean isParser(Object f) {
        if (f instanceof DateTimeParser) {
            if (f instanceof Composite) {
                return ((Composite)f).isParser();
            }
            return true;
        }
        return false;
    }

    private boolean isFormatter(Object f) {
        if (f instanceof DateTimeFormatter) {
            if (f instanceof Composite) {
                return ((Composite)f).isPrinter()
                    && ((Composite)f).isParser();
            }
            return true;
        }
        return false;
    }

    static void appendUnknownString(StringBuffer buf, int len) {
        for (int i = len; --i >= 0;) {
            buf.append('\ufffd');
        }
    }

    static void printUnknownString(Writer out, int len) throws IOException {
        for (int i = len; --i >= 0;) {
            out.write('\ufffd');
        }
    }

    
    static class CharacterLiteral
            extends BaseDateTimeFormatter
            implements DateTimeFormatter {

        private final char iValue;

        CharacterLiteral(char value) {
            super();
            iValue = value;
        }

        public int estimatePrintedLength() {
            return 1;
        }

        protected void printTo(StringBuffer buf,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) {
            buf.append(iValue);
        }

        protected void printTo(Writer out,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) throws IOException {
            out.write(iValue);
        }

        public void printTo(StringBuffer buf, ReadablePartial partial) {
            buf.append(iValue);
        }

        public void printTo(Writer out, ReadablePartial partial) throws IOException {
            out.write(iValue);
        }

        protected String print(long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) {
            return String.valueOf(iValue);
        }

        public String print(ReadablePartial partial) {
            return String.valueOf(iValue);
        }

        protected int estimateParsedLength() {
            return 1;
        }

        protected int parseInto(ParseBucket bucket, String text, int position) {
            if (position >= text.length()) {
                return ~position;
            }

            char a = text.charAt(position);
            char b = iValue;

            if (a != b) {
                a = Character.toUpperCase(a);
                b = Character.toUpperCase(b);
                if (a != b) {
                    a = Character.toLowerCase(a);
                    b = Character.toLowerCase(b);
                    if (a != b) {
                        return ~position;
                    }
                }
            }

            return position + 1;
        }
    }

    
    static class StringLiteral
            extends BaseDateTimeFormatter
            implements DateTimeFormatter {

        private final String iValue;

        StringLiteral(String value) {
            super();
            iValue = value;
        }

        public int estimatePrintedLength() {
            return iValue.length();
        }

        protected void printTo(StringBuffer buf,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) {
            buf.append(iValue);
        }

        protected void printTo(Writer out,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) throws IOException {
            out.write(iValue);
        }

        public void printTo(StringBuffer buf, ReadablePartial partial) {
            buf.append(iValue);
        }

        public void printTo(Writer out, ReadablePartial partial) throws IOException {
            out.write(iValue);
        }

        protected String print(long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) {
            return iValue;
        }

        public String print(ReadablePartial partial) {
            return iValue;
        }

        public int estimateParsedLength() {
            return iValue.length();
        }

        public int parseInto(ParseBucket bucket, String text, int position) {
            if (text.regionMatches(true, position, iValue, 0, iValue.length())) {
                return position + iValue.length();
            }
            return ~position;
        }
    }

    
    static abstract class NumberFormatter
            extends BaseDateTimeFormatter
            implements DateTimeFormatter {
        protected final DateTimeFieldType iFieldType;
        protected final int iMaxParsedDigits;
        protected final boolean iSigned;

        NumberFormatter(DateTimeFieldType fieldType,
                int maxParsedDigits, boolean signed) {
            super();
            iFieldType = fieldType;
            iMaxParsedDigits = maxParsedDigits;
            iSigned = signed;
        }

        protected int estimateParsedLength() {
            return iMaxParsedDigits;
        }

        protected int parseInto(ParseBucket bucket, String text, int position) {
            int limit = Math.min(iMaxParsedDigits, text.length() - position);

            boolean negative = false;
            int length = 0;
            while (length < limit) {
                char c = text.charAt(position + length);
                if (length == 0 && (c == '-' || c == '+') && iSigned) {
                    negative = c == '-';
                    if (negative) {
                        length++;
                    } else {
                        
                        position++;
                    }
                    
                    limit = Math.min(limit + 1, text.length() - position);
                    continue;
                }
                if (c < '0' || c > '9') {
                    break;
                }
                length++;
            }

            if (length == 0) {
                return ~position;
            }

            int value;
            if (length >= 9) {
                
                
                value = Integer.parseInt
                    (text.substring(position, position += length));
            } else {
                int i = position;
                if (negative) {
                    i++;
                }
                value = text.charAt(i++) - '0';
                position += length;
                while (i < position) {
                    value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';
                }
                if (negative) {
                    value = -value;
                }
            }

            bucket.saveField(iFieldType, value);
            return position;
        }
    }

    
    static class UnpaddedNumber extends NumberFormatter {

        protected UnpaddedNumber(DateTimeFieldType fieldType,
                       int maxParsedDigits, boolean signed)
        {
            super(fieldType, maxParsedDigits, signed);
        }

        protected int estimatePrintedLength() {
            return iMaxParsedDigits;
        }

        protected void printTo(StringBuffer buf,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) {
            try {
                DateTimeField field = iFieldType.getField(chronoLocal);
                FormatUtils.appendUnpaddedInteger(buf, field.get(instantLocal));
            } catch (RuntimeException e) {
                buf.append('\ufffd');
            }
        }

        protected void printTo(Writer out,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) throws IOException {
            try {
                DateTimeField field = iFieldType.getField(chronoLocal);
                FormatUtils.writeUnpaddedInteger(out, field.get(instantLocal));
            } catch (RuntimeException e) {
                out.write('\ufffd');
            }
        }

        public void printTo(StringBuffer buf, ReadablePartial partial) {
            if (partial.isSupported(iFieldType)) {
                try {
                    FormatUtils.appendUnpaddedInteger(buf, partial.get(iFieldType));
                } catch (RuntimeException e) {
                    buf.append('\ufffd');
                }
            } else {
                buf.append('\ufffd');
            }
        }

        public void printTo(Writer out, ReadablePartial partial) throws IOException {
            if (partial.isSupported(iFieldType)) {
                try {
                    FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType));
                } catch (RuntimeException e) {
                    out.write('\ufffd');
                }
            } else {
                out.write('\ufffd');
            }
        }
    }

    
    static class PaddedNumber extends NumberFormatter {

        protected final int iMinPrintedDigits;

        protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,
                     boolean signed, int minPrintedDigits)
        {
            super(fieldType, maxParsedDigits, signed);
            iMinPrintedDigits = minPrintedDigits;
        }

        protected int estimatePrintedLength() {
            return iMaxParsedDigits;
        }

        protected void printTo(StringBuffer buf,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) {
            try {
                DateTimeField field = iFieldType.getField(chronoLocal);
                FormatUtils.appendPaddedInteger(buf, field.get(instantLocal), iMinPrintedDigits);
            } catch (RuntimeException e) {
                appendUnknownString(buf, iMinPrintedDigits);
            }
        }

        protected void printTo(Writer out,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) throws IOException {
            try {
                DateTimeField field = iFieldType.getField(chronoLocal);
                FormatUtils.writePaddedInteger(out, field.get(instantLocal), iMinPrintedDigits);
            } catch (RuntimeException e) {
                printUnknownString(out, iMinPrintedDigits);
            }
        }

        public void printTo(StringBuffer buf, ReadablePartial partial) {
            if (partial.isSupported(iFieldType)) {
                try {
                    FormatUtils.appendPaddedInteger(buf, partial.get(iFieldType), iMinPrintedDigits);
                } catch (RuntimeException e) {
                    appendUnknownString(buf, iMinPrintedDigits);
                }
            } else {
                appendUnknownString(buf, iMinPrintedDigits);
            }
        }

        public void printTo(Writer out, ReadablePartial partial) throws IOException {
            if (partial.isSupported(iFieldType)) {
                try {
                    FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits);
                } catch (RuntimeException e) {
                    printUnknownString(out, iMinPrintedDigits);
                }
            } else {
                printUnknownString(out, iMinPrintedDigits);
            }
        }
    }

    
    static class TwoDigitYear
            extends BaseDateTimeFormatter
            implements DateTimeFormatter {

        private final int iPivot;

        TwoDigitYear(int pivot) {
            super();
            iPivot = pivot;
        }

        protected int estimateParsedLength() {
            return 2;
        }

        protected int parseInto(ParseBucket bucket, String text, int position) {
            int limit = Math.min(2, text.length() - position);
            if (limit < 2) {
                return ~position;
            }

            int year;
            char c = text.charAt(position);
            if (c < '0' || c > '9') {
                return ~position;
            }
            year = c - '0';
            c = text.charAt(position + 1);
            if (c < '0' || c > '9') {
                return ~position;
            }
            year = ((year << 3) + (year << 1)) + c - '0';

            int low = iPivot - 50;

            int t;
            if (low >= 0) {
                t = low % 100;
            } else {
                t = 99 + ((low + 1) % 100);
            }

            year += low + ((year < t) ? 100 : 0) - t;

            bucket.saveField(DateTimeFieldType.year(), year);
            return position + 2;
        }
        
        protected int estimatePrintedLength() {
            return 2;
        }

        protected void printTo(StringBuffer buf,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) {
            int year = getTwoDigitYear(instantLocal, chronoLocal);
            if (year < 0) {
                buf.append('\ufffd');
                buf.append('\ufffd');
            } else {
                FormatUtils.appendPaddedInteger(buf, year, 2);
            }
        }

        protected void printTo(Writer out,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) throws IOException {
            int year = getTwoDigitYear(instantLocal, chronoLocal);
            if (year < 0) {
                out.write('\ufffd');
                out.write('\ufffd');
            } else {
                FormatUtils.writePaddedInteger(out, year, 2);
            }
        }

        private int getTwoDigitYear(long instantLocal, Chronology chronoLocal) {
            try {
                int year = chronoLocal.year().get(instantLocal);
                if (year < 0) {
                    year = -year;
                }
                return year % 100;
            } catch (RuntimeException e) {
                return -1;
            }
        }

        public void printTo(StringBuffer buf, ReadablePartial partial) {
            int year = getTwoDigitYear(partial);
            if (year < 0) {
                buf.append('\ufffd');
                buf.append('\ufffd');
            } else {
                FormatUtils.appendPaddedInteger(buf, year, 2);
            }
        }

        public void printTo(Writer out, ReadablePartial partial) throws IOException {
            int year = getTwoDigitYear(partial);
            if (year < 0) {
                out.write('\ufffd');
                out.write('\ufffd');
            } else {
                FormatUtils.writePaddedInteger(out, year, 2);
            }
        }

        private int getTwoDigitYear(ReadablePartial partial) {
            if (partial.isSupported(DateTimeFieldType.year())) {
                try {
                    int year = partial.get(DateTimeFieldType.year());
                    if (year < 0) {
                        year = -year;
                    }
                    return year % 100;
                } catch (RuntimeException e) {}
            } 
            return -1;
        }
    }

    
    static class TextField
            extends BaseDateTimeFormatter
            implements DateTimeFormatter {

        private final DateTimeFieldType iFieldType;
        private final Locale iLocale;
        private final boolean iShort;

        TextField(DateTimeFieldType fieldType, Locale locale, boolean isShort) {
            super();
            iFieldType = fieldType;
            iLocale = locale;
            iShort = isShort;
        }

        protected int estimatePrintedLength() {
            return iShort ? 6 : 20;
        }

        protected void printTo(StringBuffer buf,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) {
            try {
                buf.append(print(instantLocal, chronoLocal, instant, chrono));
            } catch (RuntimeException e) {
                buf.append('\ufffd');
            }
        }

        protected void printTo(Writer out,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) throws IOException {
            try {
                out.write(print(instantLocal, chronoLocal, instant, chrono));
            } catch (RuntimeException e) {
                out.write('\ufffd');
            }
        }

        public void printTo(StringBuffer buf, ReadablePartial partial) {
            try {
                buf.append(print(partial));
            } catch (RuntimeException e) {
                buf.append('\ufffd');
            }
        }

        public void printTo(Writer out, ReadablePartial partial) throws IOException {
            try {
                out.write(print(partial));
            } catch (RuntimeException e) {
                out.write('\ufffd');
            }
        }

        protected String print(long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) {
            DateTimeField field = iFieldType.getField(chrono);
            if (iShort) {
                return field.getAsShortText(instantLocal, iLocale);
            } else {
                return field.getAsText(instantLocal, iLocale);
            }
        }

        public String print(ReadablePartial partial) {
            if (partial.isSupported(iFieldType)) {
                DateTimeField field = iFieldType.getField(partial.getChronology());
                if (iShort) {
                    return field.getAsShortText(partial, iLocale);
                } else {
                    return field.getAsText(partial, iLocale);
                }
            } else {
                return "\ufffd";
            }
        }

        protected int estimateParsedLength() {
            return estimatePrintedLength();
        }

        protected int parseInto(ParseBucket bucket, String text, int position) {
            int limit = text.length();
            int i = position;
            for (; i<limit; i++) {
                char c = text.charAt(i);
                if (c < 'A') {
                    break;
                }
                if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || Character.isLetter(c)) {
                    continue;
                }
                break;
            }

            if (i == position) {
                return ~position;
            }

            bucket.saveField(iFieldType, text.substring(position, i), iLocale);

            return i;
        }
    }

    
    static class Fraction
            extends BaseDateTimeFormatter
            implements DateTimeFormatter {

        private final DateTimeFieldType iFieldType;
        protected int iMinDigits;
        protected int iMaxDigits;

        protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {
            super();
            iFieldType = fieldType;
            
            if (maxDigits > 18) {
                maxDigits = 18;
            }
            iMinDigits = minDigits;
            iMaxDigits = maxDigits;
        }

        protected int estimatePrintedLength() {
            return iMaxDigits;
        }

        protected void printTo(StringBuffer buf,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) {
            try {
                printTo(buf, null, instantLocal, chronoLocal);
            } catch (IOException e) {
                
            }
        }

        protected void printTo(Writer out,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) throws IOException {
            printTo(null, out, instantLocal, chronoLocal);
        }

        public void printTo(StringBuffer buf, ReadablePartial partial) {
            if (partial.isSupported(iFieldType)) {
                long millis = partial.getChronology().set(partial, 0L);
                try {
                    printTo(buf, null, millis, partial.getChronology());
                } catch (IOException e) {
                    
                }
            } else {
                buf.append('\ufffd');
            }
        }

        public void printTo(Writer out, ReadablePartial partial) throws IOException {
            if (partial.isSupported(iFieldType)) {
                long millis = partial.getChronology().set(partial, 0L);
                printTo(null, out, millis, partial.getChronology());
            } else {
                out.write('\ufffd');
            }
        }

        protected void printTo(StringBuffer buf, Writer out, long instantLocal, Chronology chronoLocal)
            throws IOException
        {
            DateTimeField field = iFieldType.getField(chronoLocal);
            int minDigits = iMinDigits;

            long fraction;
            try {
                fraction = field.remainder(instantLocal);
            } catch (RuntimeException e) {
                if (buf != null) {
                    appendUnknownString(buf, minDigits);
                } else {
                    printUnknownString(out, minDigits);
                }
                return;
            }

            if (fraction == 0) {
                if (buf != null) {
                    while (--minDigits >= 0) {
                        buf.append('0');
                    }
                } else {
                    while (--minDigits >= 0) {
                        out.write('0');
                    }
                }
                return;
            }

            String str;
            long[] fractionData = getFractionData(fraction, field);
            long scaled = fractionData[0];
            int maxDigits = (int) fractionData[1];
            
            if ((scaled & 0x7fffffff) == scaled) {
                str = Integer.toString((int) scaled);
            } else {
                str = Long.toString(scaled);
            }

            int length = str.length();
            int digits = maxDigits;
            while (length < digits) {
                if (buf != null) {
                    buf.append('0');
                } else {
                    out.write('0');
                }
                minDigits--;
                digits--;
            }

            if (minDigits < digits) {
                
                while (minDigits < digits) {
                    if (length <= 1 || str.charAt(length - 1) != '0') {
                        break;
                    }
                    digits--;
                    length--;
                }
                if (length < str.length()) {
                    if (buf != null) {
                        for (int i=0; i<length; i++) {
                            buf.append(str.charAt(i));
                        }
                    } else {
                        for (int i=0; i<length; i++) {
                            out.write(str.charAt(i));
                        }
                    }
                    return;
                }
            }

            if (buf != null) {
                buf.append(str);
            } else {
                out.write(str);
            }
        }
        
        private long[] getFractionData(long fraction, DateTimeField field) {
            long rangeMillis = field.getDurationField().getUnitMillis();
            long scalar;
            int maxDigits = iMaxDigits;
            while (true) {
                switch (maxDigits) {
                default: scalar = 1L; break;
                case 1:  scalar = 10L; break;
                case 2:  scalar = 100L; break;
                case 3:  scalar = 1000L; break;
                case 4:  scalar = 10000L; break;
                case 5:  scalar = 100000L; break;
                case 6:  scalar = 1000000L; break;
                case 7:  scalar = 10000000L; break;
                case 8:  scalar = 100000000L; break;
                case 9:  scalar = 1000000000L; break;
                case 10: scalar = 10000000000L; break;
                case 11: scalar = 100000000000L; break;
                case 12: scalar = 1000000000000L; break;
                case 13: scalar = 10000000000000L; break;
                case 14: scalar = 100000000000000L; break;
                case 15: scalar = 1000000000000000L; break;
                case 16: scalar = 10000000000000000L; break;
                case 17: scalar = 100000000000000000L; break;
                case 18: scalar = 1000000000000000000L; break;
                }
                if (((rangeMillis * scalar) / scalar) == rangeMillis) {
                    break;
                }
                
                maxDigits--;
            }
            
            return new long[] {fraction * scalar / rangeMillis, maxDigits};
        }

        protected int estimateParsedLength() {
            return iMaxDigits;
        }

        protected int parseInto(ParseBucket bucket, String text, int position) {
            DateTimeField field = iFieldType.getField(bucket.getChronology());
            
            int limit = Math.min(iMaxDigits, text.length() - position);

            long value = 0;
            long n = field.getDurationField().getUnitMillis() * 10;
            int length = 0;
            while (length < limit) {
                char c = text.charAt(position + length);
                if (c < '0' || c > '9') {
                    break;
                }
                length++;
                long nn = n / 10;
                value += (c - '0') * nn;
                n = nn;
            }

            value /= 10;

            if (length == 0) {
                return ~position;
            }

            if (value > Integer.MAX_VALUE) {
                return ~position;
            }

            DateTimeField parseField = new PreciseDateTimeField(
                DateTimeFieldType.millisOfSecond(),
                MillisDurationField.INSTANCE,
                field.getDurationField());

            bucket.saveField(parseField, (int) value);

            return position + length;
        }
    }

    
    static class TimeZoneOffsetFormatter
            extends BaseDateTimeFormatter
            implements DateTimeFormatter {

        private final String iZeroOffsetText;
        private final boolean iShowSeparators;
        private final int iMinFields;
        private final int iMaxFields;

        TimeZoneOffsetFormatter(String zeroOffsetText,
                                boolean showSeparators,
                                int minFields, int maxFields)
        {
            super();
            iZeroOffsetText = zeroOffsetText;
            iShowSeparators = showSeparators;
            if (minFields <= 0 || maxFields < minFields) {
                throw new IllegalArgumentException();
            }
            if (minFields > 4) {
                minFields = 4;
                maxFields = 4;
            }
            iMinFields = minFields;
            iMaxFields = maxFields;
        }
            
        protected int estimatePrintedLength() {
            int est = 1 + iMinFields << 1;
            if (iShowSeparators) {
                est += iMinFields - 1;
            }
            if (iZeroOffsetText != null && iZeroOffsetText.length() > est) {
                est = iZeroOffsetText.length();
            }
            return est;
        }
        
        protected void printTo(StringBuffer buf,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) {
            int offset = (int)(instantLocal - instant);

            if (offset == 0 && iZeroOffsetText != null) {
                buf.append(iZeroOffsetText);
                return;
            }
            if (offset >= 0) {
                buf.append('+');
            } else {
                buf.append('-');
                offset = -offset;
            }

            int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;
            FormatUtils.appendPaddedInteger(buf, hours, 2);
            if (iMaxFields == 1) {
                return;
            }
            offset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;
            if (offset == 0 && iMinFields <= 1) {
                return;
            }

            int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;
            if (iShowSeparators) {
                buf.append(':');
            }
            FormatUtils.appendPaddedInteger(buf, minutes, 2);
            if (iMaxFields == 2) {
                return;
            }
            offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;
            if (offset == 0 && iMinFields <= 2) {
                return;
            }

            int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;
            if (iShowSeparators) {
                buf.append(':');
            }
            FormatUtils.appendPaddedInteger(buf, seconds, 2);
            if (iMaxFields == 3) {
                return;
            }
            offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;
            if (offset == 0 && iMinFields <= 3) {
                return;
            }

            if (iShowSeparators) {
                buf.append('.');
            }
            FormatUtils.appendPaddedInteger(buf, offset, 3);
        }
        
        protected void printTo(Writer out,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) throws IOException {
            int offset = (int)(instantLocal - instant);

            if (offset == 0 && iZeroOffsetText != null) {
                out.write(iZeroOffsetText);
                return;
            }
            if (offset >= 0) {
                out.write('+');
            } else {
                out.write('-');
                offset = -offset;
            }

            int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;
            FormatUtils.writePaddedInteger(out, hours, 2);
            if (iMaxFields == 1) {
                return;
            }
            offset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;
            if (offset == 0 && iMinFields == 1) {
                return;
            }

            int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;
            if (iShowSeparators) {
                out.write(':');
            }
            FormatUtils.writePaddedInteger(out, minutes, 2);
            if (iMaxFields == 2) {
                return;
            }
            offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;
            if (offset == 0 && iMinFields == 2) {
                return;
            }

            int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;
            if (iShowSeparators) {
                out.write(':');
            }
            FormatUtils.writePaddedInteger(out, seconds, 2);
            if (iMaxFields == 3) {
                return;
            }
            offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;
            if (offset == 0 && iMinFields == 3) {
                return;
            }

            if (iShowSeparators) {
                out.write('.');
            }
            FormatUtils.writePaddedInteger(out, offset, 3);
        }

        public void printTo(StringBuffer buf, ReadablePartial partial) {
            
        }

        public void printTo(Writer out, ReadablePartial partial) throws IOException {
            
        }

        protected int estimateParsedLength() {
            return estimatePrintedLength();
        }

        protected int parseInto(ParseBucket bucket, String text, int position) {
            int limit = text.length() - position;

            zeroOffset:
            if (iZeroOffsetText != null) {
                if (iZeroOffsetText.length() == 0) {
                    
                    if (limit > 0) {
                        char c = text.charAt(position);
                        if (c == '-' || c == '+') {
                            break zeroOffset;
                        }
                    }
                    bucket.setOffset(0);
                    return position;
                }
                if (text.regionMatches(true, position, iZeroOffsetText, 0,
                                       iZeroOffsetText.length())) {
                    bucket.setOffset(0);
                    return position + iZeroOffsetText.length();
                }
            }

            

            if (limit <= 1) {
                return ~position;
            }

            boolean negative;
            char c = text.charAt(position);
            if (c == '-') {
                negative = true;
            } else if (c == '+') {
                negative = false;
            } else {
                return ~position;
            }

            limit--;
            position++;

            
            
            
            
            
            
            
            
            

            

            if (digitCount(text, position, 2) < 2) {
                
                return ~position;
            }

            int offset;

            int hours = FormatUtils.parseTwoDigits(text, position);
            if (hours > 23) {
                return ~position;
            }
            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;
            limit -= 2;
            position += 2;

            parse: {
                
                

                if (limit <= 0) {
                    break parse;
                }

                boolean expectSeparators;
                c = text.charAt(position);
                if (c == ':') {
                    expectSeparators = true;
                    limit--;
                    position++;
                } else if (c >= '0' && c <= '9') {
                    expectSeparators = false;
                } else {
                    break parse;
                }

                

                int count = digitCount(text, position, 2);
                if (count == 0 && !expectSeparators) {
                    break parse;
                } else if (count < 2) {
                    
                    return ~position;
                }

                int minutes = FormatUtils.parseTwoDigits(text, position);
                if (minutes > 59) {
                    return ~position;
                }
                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;
                limit -= 2;
                position += 2;

                

                if (limit <= 0) {
                    break parse;
                }

                if (expectSeparators) {
                    if (text.charAt(position) != ':') {
                        break parse;
                    }
                    limit--;
                    position++;
                }

                count = digitCount(text, position, 2);
                if (count == 0 && !expectSeparators) {
                    break parse;
                } else if (count < 2) {
                    
                    return ~position;
                }

                int seconds = FormatUtils.parseTwoDigits(text, position);
                if (seconds > 59) {
                    return ~position;
                }
                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;
                limit -= 2;
                position += 2;

                

                if (limit <= 0) {
                    break parse;
                }

                if (expectSeparators) {
                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {
                        break parse;
                    }
                    limit--;
                    position++;
                }
                
                count = digitCount(text, position, 3);
                if (count == 0 && !expectSeparators) {
                    break parse;
                } else if (count < 1) {
                    
                    return ~position;
                }

                offset += (text.charAt(position++) - '0') * 100;
                if (count > 1) {
                    offset += (text.charAt(position++) - '0') * 10;
                    if (count > 2) {
                        offset += text.charAt(position++) - '0';
                    }
                }
            }

            bucket.setOffset(negative ? -offset : offset);
            return position;
        }

        



        private int digitCount(String text, int position, int amount) {
            int limit = Math.min(text.length() - position, amount);
            amount = 0;
            for (; limit > 0; limit--) {
                char c = text.charAt(position + amount);
                if (c < '0' || c > '9') {
                    break;
                }
                amount++;
            }
            return amount;
        }
    }

    
    static class TimeZonePrinter
            extends BaseDateTimeFormatter
            implements DateTimePrinter {

        private final Locale iLocale;
        private final boolean iShortFormat;

        TimeZonePrinter(Locale locale, boolean shortFormat) {
            super();
            iLocale = locale;
            iShortFormat = shortFormat;
        }

        protected int estimatePrintedLength() {
            return iShortFormat ? 4 : 20;
        }

        protected void printTo(StringBuffer buf,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) {
            buf.append(print(instantLocal, chronoLocal, instant, chrono));
        }

        protected void printTo(Writer out,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) throws IOException {
            out.write(print(instantLocal, chronoLocal, instant, chrono));
        }

        protected String print(long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) {
            DateTimeZone zone = chrono.getZone();
            if (iShortFormat) {
                return zone.getShortName(instant, this.iLocale);
            } else {
                return zone.getName(instant, this.iLocale);
            }
        }

        public void printTo(StringBuffer buf, ReadablePartial partial) {
            
        }

        public void printTo(Writer out, ReadablePartial partial) throws IOException {
            
        }
    }

    
    static class Composite
            extends BaseDateTimeFormatter
            implements DateTimeFormatter {

        private final BaseDateTimeFormatter[] iPrinters;
        private final BaseDateTimeFormatter[] iParsers;

        private final int iPrintedLengthEstimate;
        private final int iParsedLengthEstimate;

        Composite(List elementPairs) {
            super();

            List printerList = new ArrayList();
            List parserList = new ArrayList();

            decompose(elementPairs, printerList, parserList);

            if (printerList.size() <= 0) {
                iPrinters = null;
                iPrintedLengthEstimate = 0;
            } else {
                int size = printerList.size();
                iPrinters = new BaseDateTimeFormatter[size];
                int printEst = 0;
                for (int i=0; i<size; i++) {
                    BaseDateTimeFormatter printer = (BaseDateTimeFormatter) printerList.get(i);
                    printEst += printer.estimatePrintedLength();
                    iPrinters[i] = printer;
                }
                iPrintedLengthEstimate = printEst;
            }

            if (parserList.size() <= 0) {
                iParsers = null;
                iParsedLengthEstimate = 0;
            } else {
                int size = parserList.size();
                iParsers = new BaseDateTimeFormatter[size];
                int parseEst = 0;
                for (int i=0; i<size; i++) {
                    BaseDateTimeFormatter parser = (BaseDateTimeFormatter) parserList.get(i);
                    parseEst += parser.estimateParsedLength();
                    iParsers[i] = parser;
                }
                iParsedLengthEstimate = parseEst;
            }
        }

        private Composite(Composite base, BaseDateTimeFormatter[] printers) {
            iPrinters = printers;
            iParsers = base.iParsers;
            iPrintedLengthEstimate = base.iPrintedLengthEstimate;
            iParsedLengthEstimate = base.iParsedLengthEstimate;
        }

        protected int estimatePrintedLength() {
            return iPrintedLengthEstimate;
        }

        protected void printTo(StringBuffer buf,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) {
            BaseDateTimeFormatter[] elements = iPrinters;
            if (elements == null) {
                throw new UnsupportedOperationException();
            }

            int len = elements.length;
            for (int i = 0; i < len; i++) {
                elements[i].printTo(buf, instantLocal, chronoLocal, instant, chrono);
            }
        }

        protected void printTo(Writer out,
                               long instantLocal, Chronology chronoLocal,
                               long instant, Chronology chrono) throws IOException {
            BaseDateTimeFormatter[] elements = iPrinters;
            if (elements == null) {
                throw new UnsupportedOperationException();
            }

            int len = elements.length;
            for (int i = 0; i < len; i++) {
                elements[i].printTo(out, instantLocal, chronoLocal, instant, chrono);
            }
        }

        public void printTo(StringBuffer buf, ReadablePartial partial) {
            BaseDateTimeFormatter[] elements = iPrinters;
            if (elements == null) {
                throw new UnsupportedOperationException();
            }

            int len = elements.length;
            for (int i=0; i<len; i++) {
                elements[i].printTo(buf, partial);
            }
        }

        public void printTo(Writer out, ReadablePartial partial) throws IOException {
            BaseDateTimeFormatter[] elements = iPrinters;
            if (elements == null) {
                throw new UnsupportedOperationException();
            }

            int len = elements.length;
            for (int i=0; i<len; i++) {
                elements[i].printTo(out, partial);
            }
        }

        protected int estimateParsedLength() {
            return iParsedLengthEstimate;
        }

        protected int parseInto(ParseBucket bucket, String text, int position) {
            BaseDateTimeFormatter[] elements = iParsers;
            if (elements == null) {
                throw new UnsupportedOperationException();
            }

            int len = elements.length;
            for (int i=0; i<len && position >= 0; i++) {
                position = elements[i].parseInto(bucket, text, position);
            }
            return position;
        }

        boolean isPrinter() {
            return iPrinters != null;
        }

        boolean isParser() {
            return iParsers != null;
        }

        



        private void decompose(List elementPairs, List printerList, List parserList) {
            int size = elementPairs.size();
            for (int i=0; i<size; i+=2) {
                Object element = elementPairs.get(i);
                if (element != null && element instanceof DateTimePrinter) {
                    if (element instanceof Composite) {
                        addArrayToList(printerList, ((Composite)element).iPrinters);
                    } else {
                        printerList.add(element);
                    }
                }

                element = elementPairs.get(i + 1);
                if (element != null && element instanceof DateTimeParser) {
                    if (element instanceof Composite) {
                        addArrayToList(parserList, ((Composite)element).iParsers);
                    } else {
                        parserList.add(element);
                    }
                }
            }
        }

        private void addArrayToList(List list, Object[] array) {
            if (array != null) {
                for (int i=0; i<array.length; i++) {
                    list.add(array[i]);
                }
            }
        }
    }

    
    static class MatchingParser
            extends BaseDateTimeFormatter
            implements DateTimeParser {

        private final BaseDateTimeFormatter[] iParsers;
        private final int iParsedLengthEstimate;

        MatchingParser(BaseDateTimeFormatter[] parsers) {
            super();
            iParsers = parsers;
            int est = 0;
            for (int i=parsers.length; --i>=0 ;) {
                BaseDateTimeFormatter parser = parsers[i];
                if (parser != null) {
                    int len = parser.estimateParsedLength();
                    if (len > est) {
                        len = est;
                    }
                }
            }
            iParsedLengthEstimate = est;
        }

        protected int estimateParsedLength() {
            return iParsedLengthEstimate;
        }

        protected int parseInto(ParseBucket bucket, String text, int position) {
            BaseDateTimeFormatter[] parsers = iParsers;
            int length = parsers.length;

            final Object originalState = bucket.saveState();
            boolean isOptional = false;

            int bestValidPos = position;
            Object bestValidState = null;

            int bestInvalidPos = position;

            for (int i=0; i<length; i++) {
                BaseDateTimeFormatter parser = parsers[i];
                if (parser == null) {
                    
                    if (bestValidPos <= position) {
                        return position;
                    }
                    isOptional = true;
                    break;
                }
                int parsePos = parser.parseInto(bucket, text, position);
                if (parsePos >= position) {
                    if (parsePos > bestValidPos) {
                        if (parsePos >= text.length() ||
                            (i + 1) >= length || parsers[i + 1] == null) {

                            
                            
                            return parsePos;
                        }
                        bestValidPos = parsePos;
                        bestValidState = bucket.saveState();
                    }
                } else {
                    if (parsePos < 0) {
                        parsePos = ~parsePos;
                        if (parsePos > bestInvalidPos) {
                            bestInvalidPos = parsePos;
                        }
                    }
                }
                bucket.restoreState(originalState);
            }

            if (bestValidPos > position || (bestValidPos == position && isOptional)) {
                
                if (bestValidState != null) {
                    bucket.restoreState(bestValidState);
                }
                return bestValidPos;
            }

            return ~bestInvalidPos;
        }
    }
}
