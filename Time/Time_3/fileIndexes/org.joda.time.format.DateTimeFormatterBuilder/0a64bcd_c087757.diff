338,339c338,341
<             
<             return append(printer, parsers[0]);
---
>             if (parsers[0] == null) {
>                 throw new IllegalArgumentException("No parser supplied");
>             }
>             return append0(printer, parsers[0]);
700,701c702
<         return appendDecimal
<             (iChronoUTC.weekyear(), minDigits, maxDigits);
---
>         return appendSignedDecimal(iChronoUTC.weekyear(), minDigits, maxDigits);
866a868,880
>     
> 
> 
> 
> 
> 
> 
> 
>     public DateTimeFormatterBuilder appendPattern(String pattern) {
>         DateTimeFormat.appendPatternTo(this, pattern);
>         return this;
>     }
> 
1083,1085c1097,1103
<             if (length == 3 && negative) {
<                 value = -FormatUtils.parseTwoDigits(text, position + 1);
<             } else if (length == 2) {
---
>             if (length >= 9) {
>                 
>                 
>                 value = Integer.parseInt
>                     (text.substring(position, position += length));
>             } else {
>                 int i = position;
1087,1090c1105
<                     value = text.charAt(position + 1) - '0';
<                     value = -value;
<                 } else {
<                     value = FormatUtils.parseTwoDigits(text, position);
---
>                     i++;
1092,1099c1107,1113
<             } else if (length == 1 && !negative) {
<                 value = text.charAt(position) - '0';
<             } else {
<                 String sub = text.substring(position, position + length);
<                 try {
<                     value = Integer.parseInt(sub);
<                 } catch (NumberFormatException e) {
<                     return ~position;
---
>                 value = text.charAt(i++) - '0';
>                 position += length;
>                 while (i < position) {
>                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';
>                 }
>                 if (negative) {
>                     value = -value;
1104,1105c1118
< 
<             return position + length;
---
>             return position;
1268c1281
<         private final long iScaler;
---
>         private final long iScalar;
1285c1298
<             long scaler;
---
>             long scalar;
1288,1306c1301,1319
<                 default: scaler = 1L; break;
<                 case 1:  scaler = 10L; break;
<                 case 2:  scaler = 100L; break;
<                 case 3:  scaler = 1000L; break;
<                 case 4:  scaler = 10000L; break;
<                 case 5:  scaler = 100000L; break;
<                 case 6:  scaler = 1000000L; break;
<                 case 7:  scaler = 10000000L; break;
<                 case 8:  scaler = 100000000L; break;
<                 case 9:  scaler = 1000000000L; break;
<                 case 10: scaler = 10000000000L; break;
<                 case 11: scaler = 100000000000L; break;
<                 case 12: scaler = 1000000000000L; break;
<                 case 13: scaler = 10000000000000L; break;
<                 case 14: scaler = 100000000000000L; break;
<                 case 15: scaler = 1000000000000000L; break;
<                 case 16: scaler = 10000000000000000L; break;
<                 case 17: scaler = 100000000000000000L; break;
<                 case 18: scaler = 1000000000000000000L; break;
---
>                 default: scalar = 1L; break;
>                 case 1:  scalar = 10L; break;
>                 case 2:  scalar = 100L; break;
>                 case 3:  scalar = 1000L; break;
>                 case 4:  scalar = 10000L; break;
>                 case 5:  scalar = 100000L; break;
>                 case 6:  scalar = 1000000L; break;
>                 case 7:  scalar = 10000000L; break;
>                 case 8:  scalar = 100000000L; break;
>                 case 9:  scalar = 1000000000L; break;
>                 case 10: scalar = 10000000000L; break;
>                 case 11: scalar = 100000000000L; break;
>                 case 12: scalar = 1000000000000L; break;
>                 case 13: scalar = 10000000000000L; break;
>                 case 14: scalar = 100000000000000L; break;
>                 case 15: scalar = 1000000000000000L; break;
>                 case 16: scalar = 10000000000000000L; break;
>                 case 17: scalar = 100000000000000000L; break;
>                 case 18: scalar = 1000000000000000000L; break;
1308c1321
<                 if (((iRangeMillis * scaler) / scaler) == iRangeMillis) {
---
>                 if (((iRangeMillis * scalar) / scalar) == iRangeMillis) {
1316c1329
<             iScaler = scaler;
---
>             iScalar = scalar;
1372c1385
<             long scaled = fraction * iScaler / iRangeMillis;
---
>             long scaled = fraction * iScalar / iRangeMillis;
1430c1443
<             long n = iRangeMillis;
---
>             long n = iRangeMillis * 10;
1438,1441c1451,1453
<                 if (c != '0') {
<                     value += (c - '0') * n / 10;
<                 }
<                 n /= 10;
---
>                 long nn = n / 10;
>                 value += (c - '0') * nn;
>                 n = nn;
1443a1456,1457
>             value /= 10;
> 
1750c1764
<                     if (text.charAt(position) != '.') {
---
>                     if (text.charAt(position) != '.' && text.charAt(position) != ',') {
1988c2002
<         public int parseInto(DateTimeParserBucket bucket, String text, int position) {
---
>         public int parseInto(final DateTimeParserBucket bucket, final String text, final int position) {
1992,1995c2006,2008
<             Object state = bucket.saveState();
<             
<             int bestInvalidPos = position;
<             int bestInvalidParser = 0;
---
>             final Object originalState = bucket.saveState();
>             boolean isOptional = false;
> 
1997c2010
<             int bestValidParser = 0;
---
>             Object bestValidState = null;
1999,2002c2012
<             for (int i=0; i<length; i++) {
<                 if (i != 0) {
<                     bucket.undoChanges(state);
<                 }
---
>             int bestInvalidPos = position;
2003a2014
>             for (int i=0; i<length; i++) {
2007,2008c2018,2019
<                     if (bestValidPos > position) {
<                         break;
---
>                     if (bestValidPos <= position) {
>                         return position;
2010c2021,2022
<                     return position;
---
>                     isOptional = true;
>                     break;
2012d2023
< 
2015,2017d2025
<                     if (parsePos >= text.length()) {
<                         return parsePos;
<                     }
2018a2027,2033
>                         if (parsePos >= text.length() ||
>                             (i + 1) >= length || parsers[i + 1] == null) {
> 
>                             
>                             
>                             return parsePos;
>                         }
2020c2035
<                         bestValidParser = i;
---
>                         bestValidState = bucket.saveState();
2023,2026c2038,2042
<                     parsePos = ~parsePos;
<                     if (parsePos > bestInvalidPos) {
<                         bestInvalidPos = parsePos;
<                         bestInvalidParser = i;
---
>                     if (parsePos < 0) {
>                         parsePos = ~parsePos;
>                         if (parsePos > bestInvalidPos) {
>                             bestInvalidPos = parsePos;
>                         }
2028a2045
>                 bucket.restoreState(originalState);
2031,2037c2048
<             if (bestValidPos > position) {
<                 if (bestValidParser == length - 1) {
<                     
<                     
<                     return bestValidPos;
<                 }
<                 bucket.undoChanges(state);
---
>             if (bestValidPos > position || (bestValidPos == position && isOptional)) {
2039,2045c2050,2053
<                 return parsers[bestValidParser].parseInto(bucket, text, position);
<             }
< 
<             if (bestInvalidParser == length - 1) {
<                 
<                 
<                 return ~bestInvalidPos;
---
>                 if (bestValidState != null) {
>                     bucket.restoreState(bestValidState);
>                 }
>                 return bestValidPos;
2048,2050c2056
<             bucket.undoChanges(state);
<             
<             return parsers[bestInvalidParser].parseInto(bucket, text, position);
---
>             return ~bestInvalidPos;
