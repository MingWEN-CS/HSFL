33a34
> import org.joda.time.format.DateTimeFormat;
194d194
<                 StringBuffer buf = new StringBuffer();
238c238
<             int hoursInMinutes = FieldUtils.safeMultiplyToInt(hoursOffset, 60);
---
>             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);
244c244
<             offset = FieldUtils.safeMultiplyToInt(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
---
>             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
273a274,276
> 
> 
> 
320,356d322
<     public static DateTimeZone getInstance(String id) {
<         return forID(id);
<     }
< 
<     
< 
< 
< 
< 
<     public static DateTimeZone getInstance(int hours) {
<         return forOffsetHours(hours);
<     }
< 
<     
< 
< 
< 
< 
<     public static DateTimeZone getInstance(int hours, int mins) {
<         return forOffsetHoursMinutes(hours, mins);
<     }
< 
<     
< 
< 
< 
< 
<     public static DateTimeZone getInstance(TimeZone jdkZone) {
<         return forTimeZone(jdkZone);
<     }
< 
<     
<     
< 
< 
< 
< 
634c600
<         return -(int) offsetFormatter().parseMillis(str, chrono);
---
>         return -(int) offsetFormatter().withChronology(chrono).parseMillis(str);
857a824,855
>     public boolean isStandardOffset(long instant) {
>         return getOffset(instant) == getStandardOffset(instant);
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
861c859,949
<         return getOffset(instantLocal - getOffset(instantLocal));
---
>         
>         int offsetLocal = getOffset(instantLocal);
>         
>         int offsetAdjusted = getOffset(instantLocal - offsetLocal);
>         
>         if (offsetLocal != offsetAdjusted) {
>             
>             
>             if ((offsetLocal - offsetAdjusted) < 0) {
>                 
>                 
>                 
>                 long nextLocal = nextTransition(instantLocal - offsetLocal);
>                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
>                 if (nextLocal != nextAdjusted) {
>                     return offsetLocal;
>                 }
>             }
>         }
>         return offsetAdjusted;
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public long convertUTCToLocal(long instantUTC) {
>         int offset = getOffset(instantUTC);
>         long instantLocal = instantUTC + offset;
>         
>         if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {
>             throw new ArithmeticException("Adding time zone offset caused overflow");
>         }
>         return instantLocal;
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public long convertLocalToUTC(long instantLocal, boolean strict) {
>         
>         int offsetLocal = getOffset(instantLocal);
>         
>         int offset = getOffset(instantLocal - offsetLocal);
>         
>         if (offsetLocal != offset) {
>             
>             
>             
>             if (strict || offsetLocal < 0) {
>                 
>                 long nextLocal = nextTransition(instantLocal - offsetLocal);
>                 long nextAdjusted = nextTransition(instantLocal - offset);
>                 if (nextLocal != nextAdjusted) {
>                     
>                     if (strict) {
>                         
>                         throw new IllegalArgumentException("Illegal instant due to time zone offset transition: " +
>                                 DateTimeFormat.forPattern("yyyy-MM-dd'T'HH:mm:ss.SSS").print(new Instant(instantLocal)) +
>                                 " (" + getID() + ")");
>                     } else {
>                         
>                         
>                         
>                         offset = offsetLocal;
>                     }
>                 }
>             }
>         }
>         
>         long instantUTC = instantLocal - offset;
>         
>         if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {
>             throw new ArithmeticException("Subtracting time zone offset caused overflow");
>         }
>         return instantUTC;
877a966,968
>         if (newZone == this) {
>             return oldInstant;
>         }
881a973,1091
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>         
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public boolean isLocalDateTimeGap(LocalDateTime localDateTime) {
>         if (isFixed()) {
>             return false;
>         }
>         try {
>             localDateTime.toDateTime(this);
>             return false;
>         } catch (IllegalArgumentException ex) {
>             return true;
>         }
>     }
> 
>     
