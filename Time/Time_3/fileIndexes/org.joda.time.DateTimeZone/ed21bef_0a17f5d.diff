60a61,62
> import java.lang.ref.Reference;
> import java.lang.ref.SoftReference;
65a68
> import org.joda.time.field.FieldUtils;
68d70
< import org.joda.time.tz.DateTimeZonePermission;
121c123,124
<     static final long serialVersionUID = 5546345482340108586L;
---
>     
>     private static final long serialVersionUID = 5546345482340108586L;
134a138
>     private static Map iFixedOffsetCache;
136c140
< 
---
>     
142a147,157
>         
>         
>         
>         
>         
>         
>         
>         
>         
>         
> 
177c192
<             sm.checkPermission(new DateTimeZonePermission("setDefault"));
---
>             sm.checkPermission(new JodaTimePermission("DateTimeZone.setDefault"));
202c217
<             throw new IllegalArgumentException("The datetime zone id must not be null");
---
>             return getDefault();
207c222
<         DateTimeZone zone = cProvider.getDateTimeZone(id);
---
>         DateTimeZone zone = cProvider.getZone(id);
212,215c227,233
<             int offset = -(int)offsetFormatter().parseMillis(id);
<             
<             id = offsetFormatter().print(0, UTC, offset);
<             return new FixedDateTimeZone(id, null, offset, offset);
---
>             int offset = -(int) offsetFormatter().parseMillis(id);
>             if (offset == 0L) {
>                 return DateTimeZone.UTC;
>             } else {
>                 id = offsetFormatter().print(0, UTC, offset);
>                 return fixedOffsetZone(id, offset);
>             }
228a247,294
>     public static DateTimeZone getInstance(int hoursOffset) throws IllegalArgumentException {
>         return getInstance(hoursOffset, 0);
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
>     public static DateTimeZone getInstance(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
>         if (hoursOffset == 0 && minutesOffset == 0) {
>             return DateTimeZone.UTC;
>         }
>         if (minutesOffset < 0 || minutesOffset > 59) {
>             throw new IllegalArgumentException("Minutes out of range: " + minutesOffset);
>         }
>         int offset = 0;
>         try {
>             int hoursInMinutes = FieldUtils.safeMultiplyToInt(hoursOffset, 60);
>             if (hoursInMinutes < 0) {
>                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);
>             } else {
>                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);
>             }
>             offset = FieldUtils.safeMultiplyToInt(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
>         } catch (ArithmeticException ex) {
>             throw new IllegalArgumentException("Offset is too large");
>         }
>         String id = offsetFormatter().print(0, UTC, offset);
>         return fixedOffsetZone(id, offset);
>     }
> 
>     
> 
> 
> 
> 
> 
> 
> 
> 
234c300
<             throw new IllegalArgumentException("The TimeZone must not be null");
---
>             return getDefault();
241d306
<         DateTimeZone dtz;
242a308
>         DateTimeZone dtz = null;
244,245c310,314
<         if (convId == null || (dtz = cProvider.getDateTimeZone(convId)) == null) {
<             dtz = cProvider.getDateTimeZone(id);
---
>         if (convId != null) {
>             dtz = cProvider.getZone(convId);
>         }
>         if (dtz == null) {
>             dtz = cProvider.getZone(id);
257,259c326,331
<                 
<                 convId = offsetFormatter().print(0, UTC, offset);
<                 return new FixedDateTimeZone(convId, null, offset, offset);
---
>                 if (offset == 0L) {
>                     return DateTimeZone.UTC;
>                 } else {
>                     convId = offsetFormatter().print(0, UTC, offset);
>                     return fixedOffsetZone(convId, offset);
>                 }
266,269c338,353
<     
< 
< 
< 
---
>     private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {
>         if (iFixedOffsetCache == null) {
>             iFixedOffsetCache = new HashMap();
>         }
>         DateTimeZone zone;
>         Reference ref = (Reference) iFixedOffsetCache.get(id);
>         if (ref != null) {
>             zone = (DateTimeZone) ref.get();
>             if (zone != null) {
>                 return zone;
>             }
>         }
>         zone = new FixedDateTimeZone(id, null, offset, offset);
>         iFixedOffsetCache.put(id, new SoftReference(zone));
>         return zone;
>     }
270a355
>     
274a360,362
>     public static Set getAvailableIDs() {
>         return cAvailableIDs;
>     }
276a365
>     
284,287c373,375
< 
< 
< 
< 
---
>     public static Provider getProvider() {
>         return cProvider;
>     }
294,296d381
<     public static Set getAvailableIDs() {
<         return cAvailableIDs;
<     }
298,300d382
<     public static Provider getProvider() {
<         return cProvider;
<     }
302c384
<     
---
> 
308c390
<             sm.checkPermission(new DateTimeZonePermission("setProvider"));
---
>             sm.checkPermission(new JodaTimePermission("DateTimeZone.setProvider"));
315a398,400
> 
> 
> 
328c413
<         if (!UTC.equals(provider.getDateTimeZone("UTC"))) {
---
>         if (!UTC.equals(provider.getZone("UTC"))) {
334a420,471
>     
> 
> 
> 
> 
> 
> 
> 
> 
>     private static Provider getDefaultProvider() {
>         Provider provider = null;
> 
>         try {
>             String providerClass =
>                 System.getProperty("org.joda.time.DateTimeZone.Provider");
>             if (providerClass != null) {
>                 try {
>                     provider = (Provider)Class.forName(providerClass).newInstance();
>                 }
>                 catch (Exception ex) {
>                     Thread thread = Thread.currentThread();
>                     thread.getThreadGroup().uncaughtException(thread, ex);
>                 }
>             }
>         } catch (SecurityException ex) {
>         }
> 
>         if (provider == null) {
>             try {
>                 provider = new ZoneInfoProvider("org/joda/time/tz/data");
>             } catch (Exception ex) {
>                 Thread thread = Thread.currentThread();
>                 thread.getThreadGroup().uncaughtException(thread, ex);
>             }
>         }
> 
>         if (provider == null) {
>             provider = new UTCProvider();
>         }
> 
>         return provider;
>     }
> 
>     
>     
> 
> 
> 
> 
> 
> 
> 
341a479,485
> 
> 
> 
> 
> 
> 
> 
345c489
<             sm.checkPermission(new DateTimeZonePermission("setNameProvider"));
---
>             sm.checkPermission(new JodaTimePermission("DateTimeZone.setNameProvider"));
352a497,499
> 
> 
> 
359a507,544
>     
> 
> 
> 
> 
> 
> 
> 
>     private static NameProvider getDefaultNameProvider() {
>         NameProvider nameProvider = null;
>         try {
>             String providerClass = System.getProperty("org.joda.time.DateTimeZone.NameProvider");
>             if (providerClass != null) {
>                 try {
>                     nameProvider = (NameProvider) Class.forName(providerClass).newInstance();
>                 } catch (Exception ex) {
>                     Thread thread = Thread.currentThread();
>                     thread.getThreadGroup().uncaughtException(thread, ex);
>                 }
>             }
>         } catch (SecurityException ex) {
>             
>         }
> 
>         if (nameProvider == null) {
>             nameProvider = new DefaultNameProvider();
>         }
> 
>         return nameProvider;
>     }
> 
>     
>     
> 
> 
> 
> 
> 
399c584
<         return (String)map.get(id);
---
>         return (String) map.get(id);
401a587,591
>     
> 
> 
> 
> 
404c594
<             cOffsetFormatter = new DateTimeFormatterBuilder(UTC)
---
>             cOffsetFormatter = new DateTimeFormatterBuilder((Chronology)null, null)
411,443c601,602
<     private static Provider getDefaultProvider() {
<         Provider provider = null;
< 
<         try {
<             String providerClass =
<                 System.getProperty("org.joda.time.DateTimeZone.Provider");
<             if (providerClass != null) {
<                 try {
<                     provider = (Provider)Class.forName(providerClass).newInstance();
<                 }
<                 catch (Exception e) {
<                     Thread t = Thread.currentThread();
<                     t.getThreadGroup().uncaughtException(t, e);
<                 }
<             }
<         } catch (SecurityException e) {
<         }
< 
<         if (provider == null) {
<             try {
<                 provider = new ZoneInfoProvider("org/joda/time/tz/data");
<             } catch (Exception e) {
<                 Thread t = Thread.currentThread();
<                 t.getThreadGroup().uncaughtException(t, e);
<             }
<         }
< 
<         if (provider == null) {
<             provider = new UTCProvider();
<         }
< 
<         return provider;
<     }
---
>     
>     
445,446c604
<     private static NameProvider getDefaultNameProvider() {
<         NameProvider nameProvider = null;
---
>     private final String iID;
448,461c606
<         try {
<             String providerClass =
<                 System.getProperty("org.joda.time.DateTimeZone.NameProvider");
<             if (providerClass != null) {
<                 try {
<                     nameProvider = (NameProvider)Class.forName(providerClass).newInstance();
<                 }
<                 catch (Exception e) {
<                     Thread t = Thread.currentThread();
<                     t.getThreadGroup().uncaughtException(t, e);
<                 }
<             }
<         } catch (SecurityException e) {
<         }
---
>     
463,465d607
<         if (nameProvider == null) {
<             nameProvider = new DefaultNameProvider();
<         }
467,468d608
<         return nameProvider;
<     }
470,471d609
<     
<     
473d610
<     private final String iID;
475c612
<     public DateTimeZone(String id) {
---
>     protected DateTimeZone(String id) {
595d731
< 
598c734
<             throw new IllegalArgumentException("The instant must not be null");
---
>             return getOffset(DateTimeUtils.currentTimeMillis());
637a774,791
> 
> 
> 
> 
> 
>     public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {
>         if (newZone == null) {
>             newZone = DateTimeZone.getDefault();
>         }
>         long instantLocal = oldInstant + getOffset(oldInstant);
>         return instantLocal - newZone.getOffsetFromLocal(instantLocal);
>     }
> 
>     
> 
> 
> 
> 
709c863
<         static final long serialVersionUID = -6471952376487863581L;
---
>         private static final long serialVersionUID = -6471952376487863581L;
