














package org.joda.time.base;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Locale;
import java.util.TimeZone;

import org.joda.time.DateTimeFieldType;
import org.joda.time.DateTimeZone;
import org.joda.time.ReadableDateTime;
import org.joda.time.format.DateTimeFormat;

















public abstract class AbstractDateTime
        extends AbstractInstant
        implements ReadableDateTime {

    
    private static final Method OFFSET_METHOD;
    static {
        Method m = null;
        try {
            m = TimeZone.class.getDeclaredMethod("getOffset", new Class[] {Long.TYPE});
        } catch (SecurityException ex) {
            
        } catch (NoSuchMethodException ex) {
            try {
                m = TimeZone.class.getDeclaredMethod("getOffsets", new Class[] {Long.TYPE, int[].class});
                m.setAccessible(true);
            } catch (SecurityException e) {
                
            } catch (NoSuchMethodException e) {
                
            }
        }
        OFFSET_METHOD = m;
    }

    
    


    protected AbstractDateTime() {
        super();
    }

    
    









    public int get(DateTimeFieldType type) {
        if (type == null) {
            throw new IllegalArgumentException("The DateTimeFieldType must not be null");
        }
        return type.getField(getChronology()).get(getMillis());
    }

    
    




    public int getEra() {
        return getChronology().era().get(getMillis());
    }

    




    public int getCenturyOfEra() {
        return getChronology().centuryOfEra().get(getMillis());
    }

    




    public int getYearOfEra() {
        return getChronology().yearOfEra().get(getMillis());
    }

    




    public int getYearOfCentury() {
        return getChronology().yearOfCentury().get(getMillis());
    }

    




    public int getYear() {
        return getChronology().year().get(getMillis());
    }

    




    public int getWeekyear() {
        return getChronology().weekyear().get(getMillis());
    }

    




    public int getMonthOfYear() {
        return getChronology().monthOfYear().get(getMillis());
    }

    




    public int getWeekOfWeekyear() {
        return getChronology().weekOfWeekyear().get(getMillis());
    }

    




    public int getDayOfYear() {
        return getChronology().dayOfYear().get(getMillis());
    }

    






    public int getDayOfMonth() {
        return getChronology().dayOfMonth().get(getMillis());
    }

    






    public int getDayOfWeek() {
        return getChronology().dayOfWeek().get(getMillis());
    }

    
    




    public int getHourOfDay() {
        return getChronology().hourOfDay().get(getMillis());
    }

    




    public int getMinuteOfDay() {
        return getChronology().minuteOfDay().get(getMillis());
    }

    




    public int getMinuteOfHour() {
        return getChronology().minuteOfHour().get(getMillis());
    }

    




    public int getSecondOfDay() {
        return getChronology().secondOfDay().get(getMillis());
    }

    




    public int getSecondOfMinute() {
        return getChronology().secondOfMinute().get(getMillis());
    }

    




    public int getMillisOfDay() {
        return getChronology().millisOfDay().get(getMillis());
    }

    




    public int getMillisOfSecond() {
        return getChronology().millisOfSecond().get(getMillis());
    }

    
    









    public Date toDate() {
        long millis = getMillis();
        millis = fixMillisForTimeZone(millis, TimeZone.getDefault());
        return new Date(millis);
    }

    












    public Calendar toCalendar(Locale locale) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        DateTimeZone zone = getZone();
        Calendar cal = Calendar.getInstance(zone.toTimeZone(), locale);
        cal.setTime(convertToDate(cal));
        return cal;
    }

    









    public GregorianCalendar toGregorianCalendar() {
        DateTimeZone zone = getZone();
        GregorianCalendar cal = new GregorianCalendar(zone.toTimeZone());
        cal.setTime(convertToDate(cal));
        return cal;
    }

    private Date convertToDate(Calendar cal) {
        long millis = getMillis();
        millis = fixMillisForTimeZone(millis, cal.getTimeZone());
        return new Date(millis);
    }

    private long fixMillisForTimeZone(long millis, TimeZone zone) {
        if (OFFSET_METHOD == null) {
            return millis;
        }
        Integer val;
        try {
            if ("getOffset".equals(OFFSET_METHOD.getName())) {
                val = (Integer) OFFSET_METHOD.invoke(
                        zone, new Object[] {new Long(millis)});
            } else {
                val = (Integer) OFFSET_METHOD.invoke(
                        zone, new Object[] {new Long(millis), null});
            }
        } catch (IllegalAccessException ex) {
            return millis;
        } catch (InvocationTargetException ex) {
            return millis;
        }
        
        long millisLocal = millis - val.intValue();
        return millisLocal + getZone().getOffsetFromLocal(millisLocal);
    }

    
    





    public String toString(String pattern) {
        if (pattern == null) {
            return toString();
        }
        return DateTimeFormat.forPattern(pattern).print(this);
    }

    






    public String toString(String pattern, Locale locale) throws IllegalArgumentException {
        if (pattern == null) {
            return toString();
        }
        return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);
    }

}
