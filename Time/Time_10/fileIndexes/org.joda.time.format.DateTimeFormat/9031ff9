




















































package org.joda.time.format;

import java.io.IOException;
import java.io.Writer;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import org.joda.time.Chronology;
import org.joda.time.DateTime;
import org.joda.time.DateTimeField;
import org.joda.time.DateTimeFieldType;
import org.joda.time.DateTimeZone;
import org.joda.time.DurationFieldType;
import org.joda.time.MutableDateTime;
import org.joda.time.ReadWritableInstant;
import org.joda.time.ReadableInstant;
import org.joda.time.ReadablePartial;
import org.joda.time.field.RemainderDateTimeField;























































































public class DateTimeFormat {

    



    private static Map cInstanceCache = new HashMap(7);

    
    




    public static DateTimeFormat getInstance() {
        return getInstance(Locale.getDefault());
    }

    





    public synchronized static DateTimeFormat getInstance(Locale locale) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        DateTimeFormat dtf = (DateTimeFormat) cInstanceCache.get(locale);
        if (dtf == null) {
            dtf = new DateTimeFormat(locale);
            cInstanceCache.put(locale, dtf);
        }
        return dtf;
    }

    
    







    public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {
        int length = pattern.length();
        int[] indexRef = new int[1];

        for (int i=0; i<length; i++) {
            indexRef[0] = i;
            String token = parseToken(pattern, indexRef);
            i = indexRef[0];

            int tokenLen = token.length();
            if (tokenLen == 0) {
                break;
            }
            char c = token.charAt(0);

            switch (c) {
            case 'G': 
                builder.appendEraText();
                break;
            case 'C': 
                builder.appendCenturyOfEra(tokenLen, tokenLen);
                break;
            case 'x': 
            case 'y': 
            case 'Y': 
                if (tokenLen == 2) {
                    
                    
                    DateTimeFieldType type;
                    switch (c) {
                    case 'x':
                        type = new RemainderType(DateTimeFieldType.weekyear(),
                                                 DateTimeFieldType.weekyearOfCentury(), 100);
                        break;
                    case 'y': default:
                        type = new RemainderType(DateTimeFieldType.year(),
                                                 DateTimeFieldType.yearOfCentury(), 100);
                        break;
                    case 'Y':
                        type = new RemainderType(DateTimeFieldType.yearOfEra(),
                                                 DateTimeFieldType.yearOfCentury(), 100);
                        break;
                    }
                    builder.appendDecimal(type, 2, 2);
                } else {
                    
                    int maxDigits = 9;

                    
                    if (i + 1 < length) {
                        indexRef[0]++;
                        if (isNumericToken(parseToken(pattern, indexRef))) {
                            
                            maxDigits = tokenLen;
                        }
                        indexRef[0]--;
                    }

                    switch (c) {
                    case 'x':
                        builder.appendWeekyear(tokenLen, maxDigits);
                        break;
                    case 'y':
                        builder.appendYear(tokenLen, maxDigits);
                        break;
                    case 'Y':
                        builder.appendYearOfEra(tokenLen, maxDigits);
                        break;
                    }
                }
                break;
            case 'M': 
                if (tokenLen >= 3) {
                    if (tokenLen >= 4) {
                        builder.appendMonthOfYearText();
                    } else {
                        builder.appendMonthOfYearShortText();
                    }
                } else {
                    builder.appendMonthOfYear(tokenLen);
                }
                break;
            case 'd': 
                builder.appendDayOfMonth(tokenLen);
                break;
            case 'h': 
                builder.appendClockhourOfHalfday(tokenLen);
                break;
            case 'H': 
                builder.appendHourOfDay(tokenLen);
                break;
            case 'm': 
                builder.appendMinuteOfHour(tokenLen);
                break;
            case 's': 
                builder.appendSecondOfMinute(tokenLen);
                break;
            case 'S': 
                builder.appendFractionOfSecond(tokenLen, tokenLen);
                break;
            case 'e': 
                builder.appendDayOfWeek(tokenLen);
                break;
            case 'E': 
                if (tokenLen >= 4) {
                    builder.appendDayOfWeekText();
                } else {
                    builder.appendDayOfWeekShortText();
                }
                break;
            case 'D': 
                builder.appendDayOfYear(tokenLen);
                break;
            case 'w': 
                builder.appendWeekOfWeekyear(tokenLen);
                break;
            case 'a': 
                builder.appendHalfdayOfDayText();
                break;
            case 'k': 
                builder.appendClockhourOfDay(tokenLen);
                break;
            case 'K': 
                builder.appendClockhourOfHalfday(tokenLen);
                break;
            case 'z': 
                if (tokenLen >= 4) {
                    builder.appendTimeZoneName();
                } else {
                    builder.appendTimeZoneShortName();
                }
                break;
            case 'Z': 
                if (tokenLen >= 4) {
                    builder.appendTimeZoneOffset(null, true, 2, 2);
                } else {
                    builder.appendTimeZoneOffset(null, false, 2, 2);
                }
                break;
            case '\'': 
                String sub = token.substring(1);
                if (sub.length() == 1) {
                    builder.appendLiteral(sub.charAt(0));
                } else {
                    
                    
                    builder.appendLiteral(new String(sub));
                }
                break;
            default:
                throw new IllegalArgumentException
                    ("Illegal pattern component: " + token);
            }
        }
    }

    private static String parseToken(final String pattern, final int[] indexRef) {
        StringBuffer buf = new StringBuffer();

        int i = indexRef[0];
        int length = pattern.length();

        char c = pattern.charAt(i);
        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
            
            
            buf.append(c);

            while (i + 1 < length) {
                char peek = pattern.charAt(i + 1);
                if (peek == c) {
                    buf.append(c);
                    i++;
                } else {
                    break;
                }
            }
        } else {
            
            buf.append('\'');

            boolean inLiteral = false;

            for (; i < length; i++) {
                c = pattern.charAt(i);
                
                if (c == '\'') {
                    if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                        
                        i++;
                        buf.append(c);
                    } else {
                        inLiteral = !inLiteral;
                    }
                } else if (!inLiteral &&
                           (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                    i--;
                    break;
                } else {
                    buf.append(c);
                }
            }
        }

        indexRef[0] = i;
        return buf.toString();
    }

    
    private static boolean isNumericToken(final String token) {
        int tokenLen = token.length();
        if (tokenLen > 0) {
            char c = token.charAt(0);
            switch (c) {
            case 'c': 
            case 'C': 
            case 'x': 
            case 'y': 
            case 'Y': 
            case 'd': 
            case 'h': 
            case 'H': 
            case 'm': 
            case 's': 
            case 'S': 
            case 'e': 
            case 'D': 
            case 'F': 
            case 'w': 
            case 'W': 
            case 'k': 
            case 'K': 
                return true;
            case 'M': 
                if (tokenLen <= 2) {
                    return true;
                }
            }
        }
            
        return false;
    }

    
    
    private final Locale iLocale;

    
    private transient Map iPatternedCache = new HashMap(7);

    
    private transient Map iStyledCache = new HashMap(7);

    




    private DateTimeFormat(final Locale locale) {
        super();
        iLocale = locale;
    }

    
    






    public synchronized DateTimeFormatter forPattern(final String pattern) {
        DateTimeFormatter formatter = (DateTimeFormatter) iPatternedCache.get(pattern);
        if (formatter != null) {
            return formatter;
        }

        if (pattern == null) {
            throw new IllegalArgumentException("Invalid pattern specification");
        }

        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(iLocale);
        appendPatternTo(builder, pattern);

        if (builder.canBuildFormatter()) {
            formatter = builder.toFormatter();
        } else if (builder.canBuildPrinter()) {
            formatter = new FPrinter(builder.toPrinter());
        } else if (builder.canBuildParser()) {
            
            formatter = new FParser(builder.toParser());
        } else {
            throw new UnsupportedOperationException("Pattern unsupported: " + pattern);
        }

        iPatternedCache.put(pattern, formatter);
        return formatter;
    }

    








    public synchronized DateTimeFormatter forStyle(final String style) {
        DateTimeFormatter formatter = (DateTimeFormatter)iStyledCache.get(style);
        if (formatter == null) {
            formatter = forPattern(getPatternForStyle(style));
            iStyledCache.put(style, formatter);
        }
        return formatter;
    }

    









    public String getPatternForStyle(final String style) {
        if (style == null || style.length() != 2) {
            throw new IllegalArgumentException("Invalid style specification: " + style);
        }

        if (style.charAt(1) == '-') {
            
            return getDatePattern(style.charAt(0));
        } else if (style.charAt(0) == '-') {
            
            return getTimePattern(style.charAt(1));
        } else {
            
            return getDateTimePattern(style.charAt(0), style.charAt(1));
        }
    }

    private String getDatePattern(final char style) {
        int istyle = selectStyle(style);
        try {
            return ((SimpleDateFormat)DateFormat.getDateInstance(istyle, iLocale)).toPattern();
        } catch (ClassCastException e) {
            throw new IllegalArgumentException("No date pattern for locale: " + iLocale);
        }
    }

    private String getTimePattern(final char style) {
        int istyle = selectStyle(style);
        try {
            return ((SimpleDateFormat)DateFormat.getTimeInstance(istyle, iLocale)).toPattern();
        } catch (ClassCastException e) {
            throw new IllegalArgumentException("No time pattern for locale: " + iLocale);
        }
    }

    private String getDateTimePattern(final char dateStyle, final char timeStyle) {
        int idateStyle = selectStyle(dateStyle);
        int itimeStyle = selectStyle(dateStyle);
        try {
            return ((SimpleDateFormat)DateFormat.getDateTimeInstance
                    (idateStyle, itimeStyle, iLocale)).toPattern();
        } catch (ClassCastException e) {
            throw new IllegalArgumentException("No datetime pattern for locale: " + iLocale);
        }
    }

    private int selectStyle(final char c) {
        switch (c) {
        case 'S':
            return DateFormat.SHORT;
        case 'M':
            return DateFormat.MEDIUM;
        case 'L':
            return DateFormat.LONG;
        case 'F':
            return DateFormat.FULL;
        default:
            throw new IllegalArgumentException("Invalid style character: " + c);
        }
    }

    
    


    static class RemainderType extends DateTimeFieldType {
        private final DateTimeFieldType iWrappedType;
        private final DateTimeFieldType iType;
        private final int iDivisor;

        private transient RemainderDateTimeField iRecent;

        RemainderType(DateTimeFieldType wrappedType, DateTimeFieldType type, int divisor) {
            super(type.getName());
            iWrappedType = wrappedType;
            iType = type;
            iDivisor = divisor;
        }

        public DurationFieldType getDurationType() {
            return iType.getDurationType();
        }

        public DurationFieldType getRangeDurationType() {
            return iType.getRangeDurationType();
        }

        public DateTimeField getField(Chronology chrono) {
            DateTimeField wrappedField = iWrappedType.getField(chrono);
            RemainderDateTimeField field = iRecent;
            if (field != null && field.getWrappedField() == wrappedField) {
                return field;
            }
            field = new RemainderDateTimeField(wrappedField, iType, iDivisor);
            iRecent = field;
            return field;
        }
    }

    


    static class FPrinter implements DateTimeFormatter {
        private final DateTimePrinter mPrinter;

        FPrinter(DateTimePrinter printer) {
            super();
            mPrinter = printer;
        }

        public void printTo(StringBuffer buf, ReadableInstant instant) {
            mPrinter.printTo(buf, instant);
        }

        public void printTo(Writer out, ReadableInstant instant) throws IOException {
            mPrinter.printTo(out, instant);
        }

        public void printTo(StringBuffer buf, long instant) {
            mPrinter.printTo(buf, instant);
        }

        public void printTo(Writer out, long instant) throws IOException {
            mPrinter.printTo(out, instant);
        }

        public void printTo(StringBuffer buf, long instant, DateTimeZone zone) {
            mPrinter.printTo(buf, instant, zone);
        }

        public void printTo(Writer out, long instant, DateTimeZone zone)
            throws IOException {
            mPrinter.printTo(out, instant, zone);
        }

        public void printTo(StringBuffer buf, long instant, Chronology chrono) {
            mPrinter.printTo(buf, instant, chrono);
        }

        public void printTo(Writer out, long instant, Chronology chrono) throws IOException {
            mPrinter.printTo(out, instant, chrono);
        }

        public void printTo(StringBuffer buf, ReadablePartial instant) {
            mPrinter.printTo(buf, instant);
        }

        public void printTo(Writer out, ReadablePartial instant) throws IOException {
            mPrinter.printTo(out, instant);
        }

        public String print(ReadableInstant instant) {
            return mPrinter.print(instant);
        }

        public String print(long instant) {
            return mPrinter.print(instant);
        }

        public String print(long instant, DateTimeZone zone) {
            return mPrinter.print(instant, zone);
        }

        public String print(long instant, Chronology chrono) {
            return mPrinter.print(instant, chrono);
        }

        public String print(ReadablePartial partial) {
            return mPrinter.print(partial);
        }

        public int estimateParsedLength() {
            return 0;
        }

        public int parseInto(ReadWritableInstant instant, String text, int position) {
            throw unsupported();
        }

        public long parseMillis(String text) {
            throw unsupported();
        }

        public long parseMillis(String text, Chronology chrono) {
            throw unsupported();
        }

        public long parseMillis(String text, long instantLocal) {
            throw unsupported();
        }

        public long parseMillis(String text, long instant, Chronology chrono) {
            throw unsupported();
        }

        public DateTime parseDateTime(String text) {
            throw unsupported();
        }

        public DateTime parseDateTime(String text, Chronology chrono) {
            throw unsupported();
        }

        public DateTime parseDateTime(String text, ReadableInstant instant) {
            throw unsupported();
        }

        public MutableDateTime parseMutableDateTime(String text) {
            throw unsupported();
        }

        public MutableDateTime parseMutableDateTime(String text, Chronology chrono) {
            throw unsupported();
        }

        public MutableDateTime parseMutableDateTime(String text,
                                                    ReadableInstant instant) {
            throw unsupported();
        }

        private UnsupportedOperationException unsupported() {
            return new UnsupportedOperationException("Parsing not supported");
        }
    }

    
    


    static class FParser implements DateTimeFormatter {
        private final DateTimeParser mParser;

        FParser(DateTimeParser parser) {
            super();
            mParser = parser;
        }

        public void printTo(StringBuffer buf, ReadableInstant instant) {
            throw unsupported();
        }

        public void printTo(Writer out, ReadableInstant instant) throws IOException {
            throw unsupported();
        }

        public void printTo(StringBuffer buf, long instant) {
            throw unsupported();
        }

        public void printTo(Writer out, long instant) throws IOException {
            throw unsupported();
        }

        public void printTo(StringBuffer buf, long instant, DateTimeZone zone) {
            throw unsupported();
        }

        public void printTo(Writer out, long instant, DateTimeZone zone) {
            throw unsupported();
        }

        public void printTo(StringBuffer buf, long instant, Chronology chrono) {
            throw unsupported();
        }

        public void printTo(Writer out, long instant, Chronology chrono) throws IOException {
            throw unsupported();
        }

        public void printTo(StringBuffer buf, ReadablePartial instant) {
            throw unsupported();
        }

        public void printTo(Writer out, ReadablePartial instant) throws IOException {
            throw unsupported();
        }

        public String print(ReadableInstant instant) {
            throw unsupported();
        }

        public String print(long instant) {
            throw unsupported();
        }

        public String print(long instant, DateTimeZone zone) {
            throw unsupported();
        }

        public String print(long instant, Chronology chrono) {
            throw unsupported();
        }

        public String print(ReadablePartial partial) {
            throw unsupported();
        }

        public int parseInto(ReadWritableInstant instant, String text, int position) {
            return mParser.parseInto(instant, text, position);
        }

        public long parseMillis(String text) {
            return mParser.parseMillis(text);
        }

        public long parseMillis(String text, Chronology chrono) {
            return mParser.parseMillis(text, chrono);
        }

        public long parseMillis(String text, long instant) {
            return mParser.parseMillis(text, instant);
        }

        public long parseMillis(String text, long instant, Chronology chrono) {
            return mParser.parseMillis(text, instant, chrono);
        }

        public DateTime parseDateTime(String text) {
            return mParser.parseDateTime(text);
        }

        public DateTime parseDateTime(String text, Chronology chrono) {
            return mParser.parseDateTime(text, chrono);
        }

        public DateTime parseDateTime(String text, ReadableInstant instant) {
            return mParser.parseDateTime(text, instant);
        }

        public MutableDateTime parseMutableDateTime(String text) {
            return mParser.parseMutableDateTime(text);
        }

        public MutableDateTime parseMutableDateTime(String text, Chronology chrono) {
            return mParser.parseMutableDateTime(text, chrono);
        }

        public MutableDateTime parseMutableDateTime(String text, ReadableInstant instant) {
            return mParser.parseMutableDateTime(text, instant);
        }

        private UnsupportedOperationException unsupported() {
            return new UnsupportedOperationException("Printing not supported");
        }
    }
}
